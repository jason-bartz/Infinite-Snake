// Admin Panel JavaScript
let allElements = {};
let allCombinations = {};
let currentTab = 'database';
let currentPage = 1;
const elementsPerPage = 12; // Reduced for better performance

// Initialize
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOMContentLoaded fired, initializing admin panel...');
    
    try {
        await loadElementData();
        console.log('Element data loaded successfully');
        
        await loadCombinationData();
        console.log('Combination data loaded successfully');
        
        console.log('Rendering empty database...');
        renderDatabaseEmpty();
        console.log('Empty database rendered');
        
        console.log('Rendering stats...');
        renderStats();
        console.log('Stats rendered');
        
        console.log('Admin panel initialization complete');
    } catch (error) {
        console.error('Error during initialization:', error);
        showMessage('Error initializing admin panel', 'error');
    }
});

// Tab switching
function switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Update content
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });
    document.getElementById(`${tabName}-tab`).classList.add('active');
    
    currentTab = tabName;
    
    // Render appropriate content
    switch(tabName) {
        case 'database':
            renderDatabase();
            break;
        case 'combinations':
            renderCombinations();
            break;
        case 'trees':
            // Tree view handled separately
            break;
        case 'stats':
            renderStats();
            break;
    }
}

// Load element data from game files
async function loadElementData() {
    console.log('Starting loadElementData...');
    try {
        // Load all element files - correct paths
        const files = [
            '/elements/elements-new/elements-core.json',
            '/elements/elements-new/elements-life.json',
            '/elements/elements-new/elements-civilization.json',
            '/elements/elements-new/elements-modern.json',
            '/elements/elements-new/elements-fictional.json',
            '/elements/elements-new/elements-humorous-fusions.json'
        ];
        
        console.log('Loading element files:', files);
        
        for (const file of files) {
            try {
                console.log(`Fetching ${file}...`);
                const response = await fetch(file);
                console.log(`Response status for ${file}:`, response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Handle both array format and object format
                if (Array.isArray(data)) {
                    console.log(`Loaded ${data.length} elements from ${file} (array format)`);
                    // Convert array format to object format
                    data.forEach(elem => {
                        const id = elem.i;
                        allElements[id] = {
                            name: elem.n,
                            tier: elem.t,
                            emoji: elem.e,
                            flags: elem.f
                        };
                    });
                } else {
                    console.log(`Loaded ${Object.keys(data).length} elements from ${file} (object format)`);
                    Object.assign(allElements, data);
                }
            } catch (err) {
                console.error(`Could not load ${file}:`, err);
            }
        }
        
        console.log(`Total elements loaded: ${Object.keys(allElements).length}`);
        
        // Load emojis using dynamic import
        try {
            console.log('Loading emojis...');
            const emojiModule = await import('/elements/elements-new/emojis.js');
            window.elementEmojis = emojiModule.EMOJI_MAP;
            console.log('Emojis loaded successfully');
        } catch (err) {
            console.error('Could not load emojis:', err);
        }
        
    } catch (error) {
        console.error('Error loading element data:', error);
        showMessage('Error loading element data', 'error');
    }
}

// Load combination data
async function loadCombinationData() {
    console.log('Starting loadCombinationData...');
    try {
        const file = '/elements/elements-new/combinations.json';
        console.log(`Fetching ${file}...`);
        const response = await fetch(file);
        console.log(`Response status for combinations:`, response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log(`Loaded ${Object.keys(data).length} combinations`);
        
        // Convert the object format to our expected format
        Object.entries(data).forEach(([key, result]) => {
            const [elem1, elem2] = key.split('+').map(Number);
            const combo = {
                element1: elem1,
                element2: elem2,
                result: result
            };
            const comboKey = `${elem1}_${elem2}`;
            const reverseKey = `${elem2}_${elem1}`;
            allCombinations[comboKey] = combo;
            allCombinations[reverseKey] = combo;
        });
        
        console.log(`Total combination pairs stored: ${Object.keys(allCombinations).length}`);
        
    } catch (error) {
        console.error('Error loading combination data:', error);
        showMessage('Error loading combination data', 'error');
    }
}

// Render empty database view
function renderDatabaseEmpty() {
    const grid = document.getElementById('element-grid');
    if (!grid) return;
    
    grid.innerHTML = `
        <div style="text-align: center; padding: 50px; color: #888;">
            <h2 style="color: #4ecdc4; margin-bottom: 20px;">üîç Search Elements</h2>
            <p style="font-size: 18px; margin-bottom: 10px;">Enter an element name or ID in the search box above</p>
            <p style="font-size: 16px;">Or use the tier filter and checkboxes to browse specific categories</p>
            <p style="font-size: 14px; margin-top: 20px; color: #4ecdc4;">Total elements loaded: ${Object.keys(allElements).length}</p>
        </div>
    `;
    
    // Update tier filter
    updateTierFilter();
    
    // Clear pagination
    const pagination = document.getElementById('pagination');
    if (pagination) pagination.innerHTML = '';
}

// Render database view
function renderDatabase() {
    const grid = document.getElementById('element-grid');
    
    if (!grid) {
        console.error('Element grid not found');
        return;
    }
    
    // Check if we have loaded elements
    if (Object.keys(allElements).length === 0) {
        grid.innerHTML = '<div class="loading">No elements loaded yet. Please refresh the page or check the console for errors.</div>';
        return;
    }
    
    // Check if there are any search criteria
    const searchTerm = document.getElementById('element-search')?.value || '';
    const tierFilter = document.getElementById('tier-filter')?.value || '';
    const showOrphans = document.getElementById('show-orphans')?.checked || false;
    const showNoRecipe = document.getElementById('show-no-recipe')?.checked || false;
    
    if (!searchTerm && !tierFilter && !showOrphans && !showNoRecipe) {
        renderDatabaseEmpty();
        return;
    }
    
    // Require at least 2 characters for search
    if (searchTerm && searchTerm.length < 2) {
        grid.innerHTML = '<div style="text-align: center; padding: 50px; color: #888;">Please enter at least 2 characters to search</div>';
        document.getElementById('pagination').innerHTML = '';
        return;
    }
    
    const filtered = filterElementsData();
    const paged = paginate(filtered, currentPage, elementsPerPage);
    
    // Update tier filter if needed
    updateTierFilter();
    
    // Render elements
    grid.innerHTML = '';
    
    if (paged.items.length === 0) {
        grid.innerHTML = '<div class="loading">No elements match your filters.</div>';
        return;
    }
    
    paged.items.forEach(([id, element]) => {
        const card = createElementCard(id, element);
        if (card) {
            grid.innerHTML += card;
        }
    });
    
    // Render pagination
    renderPagination(paged.totalPages);
}

// Create element card HTML
function createElementCard(id, element) {
    if (!element) {
        console.error(`Element not found for ID: ${id}`);
        return '';
    }
    
    const emoji = window.elementEmojis?.[id] || '‚ùì';
    const combinations = findCombinationsForElement(id);
    
    return `
        <div class="element-card" data-id="${id}">
            <div class="element-header">
                <div class="element-emoji" onclick="copyEmoji('${emoji}')">${emoji}</div>
                <div class="element-info">
                    <div class="element-id">ID: ${id}</div>
                    <div class="element-name">${element.name}</div>
                    <div class="element-tier tier-${element.tier || 0}">Tier ${element.tier || 0}</div>
                </div>
            </div>
            ${combinations.length > 0 ? `
                <div class="combinations-list">
                    <strong>Recipes (${combinations.length}):</strong>
                    ${combinations.slice(0, 3).map(combo => `
                        <div class="combination-item">
                            ${getElementDisplay(combo.element1)} + ${getElementDisplay(combo.element2)} ‚Üí ${getElementDisplay(combo.result)}
                        </div>
                    `).join('')}
                    ${combinations.length > 3 ? `<div style="color: #888;">... and ${combinations.length - 3} more</div>` : ''}
                </div>
            ` : '<div class="combinations-list" style="color: #888;">No recipes found</div>'}
            <div style="margin-top: 15px;">
                <button onclick="editElement('${id}')">‚úèÔ∏è Edit</button>
                <button class="danger" onclick="deleteElement('${id}')">üóëÔ∏è Delete</button>
            </div>
        </div>
    `;
}

// Get element display (emoji + name)
function getElementDisplay(elementId) {
    const element = allElements[elementId];
    if (!element) return `Unknown (${elementId})`;
    const emoji = window.elementEmojis?.[elementId] || '‚ùì';
    return `${emoji} ${element.name}`;
}

// Find combinations that create or use an element
function findCombinationsForElement(elementId) {
    const combinations = [];
    
    Object.values(allCombinations).forEach(combo => {
        if (combo.result === parseInt(elementId)) {
            // Avoid duplicates
            const exists = combinations.some(c => 
                (c.element1 === combo.element1 && c.element2 === combo.element2) ||
                (c.element1 === combo.element2 && c.element2 === combo.element1)
            );
            if (!exists) {
                combinations.push(combo);
            }
        }
    });
    
    return combinations;
}

// Filter elements based on search and filters
function filterElementsData() {
    const searchTerm = document.getElementById('element-search')?.value.toLowerCase() || '';
    const tierFilter = document.getElementById('tier-filter')?.value || '';
    const showOrphans = document.getElementById('show-orphans')?.checked || false;
    const showNoRecipe = document.getElementById('show-no-recipe')?.checked || false;
    
    return Object.entries(allElements).filter(([id, element]) => {
        // Search filter
        if (searchTerm && !element.name.toLowerCase().includes(searchTerm) && !id.includes(searchTerm)) {
            return false;
        }
        
        // Tier filter
        if (tierFilter && element.tier != tierFilter) {
            return false;
        }
        
        // Orphan filter (elements not used in any combination)
        if (showOrphans) {
            const usedInCombos = Object.values(allCombinations).some(combo => 
                combo.element1 == id || combo.element2 == id
            );
            if (usedInCombos) return false;
        }
        
        // No recipe filter
        if (showNoRecipe) {
            const hasRecipe = findCombinationsForElement(id).length > 0;
            if (hasRecipe) return false;
        }
        
        return true;
    });
}

// Update tier filter options
function updateTierFilter() {
    const filter = document.getElementById('tier-filter');
    if (!filter || filter.options.length > 1) return;
    
    const tiers = new Set();
    Object.values(allElements).forEach(element => {
        tiers.add(element.tier || 1);
    });
    
    Array.from(tiers).sort((a, b) => a - b).forEach(tier => {
        const option = document.createElement('option');
        option.value = tier;
        option.textContent = `Tier ${tier}`;
        filter.appendChild(option);
    });
}

// Pagination
function paginate(items, page, perPage) {
    const totalPages = Math.ceil(items.length / perPage);
    const start = (page - 1) * perPage;
    const end = start + perPage;
    
    return {
        items: items.slice(start, end),
        totalPages,
        currentPage: page,
        totalItems: items.length
    };
}

// Render pagination controls
function renderPagination(totalPages) {
    const container = document.getElementById('pagination');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Previous button
    if (currentPage > 1) {
        container.innerHTML += `<button class="page-button" onclick="changePage(${currentPage - 1})">‚Üê Previous</button>`;
    }
    
    // Page numbers
    for (let i = 1; i <= totalPages; i++) {
        if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
            container.innerHTML += `<button class="page-button ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
        } else if (i === currentPage - 3 || i === currentPage + 3) {
            container.innerHTML += `<span style="padding: 0 10px;">...</span>`;
        }
    }
    
    // Next button
    if (currentPage < totalPages) {
        container.innerHTML += `<button class="page-button" onclick="changePage(${currentPage + 1})">Next ‚Üí</button>`;
    }
}

// Change page
function changePage(page) {
    currentPage = page;
    renderDatabase();
}

// Filter elements
function filterElements() {
    currentPage = 1;
    renderDatabase();
}

// Refresh database
function refreshDatabase() {
    loadElementData().then(() => {
        loadCombinationData().then(() => {
            renderDatabase();
            showMessage('Database refreshed successfully', 'success');
        });
    });
}

// Edit element
function editElement(elementId) {
    const element = allElements[elementId];
    if (!element) return;
    
    const modal = document.getElementById('edit-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');
    
    modalTitle.textContent = `Edit Element: ${element.name}`;
    
    modalBody.innerHTML = `
        <form onsubmit="saveElement(event, '${elementId}')">
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">ID:</label>
                <input type="text" value="${elementId}" disabled style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Name:</label>
                <input type="text" id="edit-name" value="${element.name}" required style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Tier:</label>
                <input type="number" id="edit-tier" value="${element.tier || 1}" min="1" max="10" required style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px;">Emoji:</label>
                <input type="text" id="edit-emoji" value="${window.elementEmojis?.[elementId] || element.emoji || ''}" style="width: 100%;">
            </div>
            
            <div style="margin-top: 20px; text-align: right;">
                <button type="button" onclick="closeModal()" style="margin-right: 10px;">Cancel</button>
                <button type="submit">Save Changes</button>
            </div>
        </form>
    `;
    
    modal.classList.add('active');
}

// Save element changes
function saveElement(event, elementId) {
    event.preventDefault();
    
    const name = document.getElementById('edit-name').value;
    const tier = parseInt(document.getElementById('edit-tier').value);
    const emoji = document.getElementById('edit-emoji').value;
    
    // Update element
    allElements[elementId] = {
        ...allElements[elementId],
        name,
        tier
    };
    
    if (window.elementEmojis) {
        window.elementEmojis[elementId] = emoji;
    }
    
    closeModal();
    renderDatabase();
    showMessage(`Element "${name}" updated successfully`, 'success');
}

// Delete element
function deleteElement(elementId) {
    if (!confirm(`Are you sure you want to delete "${allElements[elementId].name}"? This will also remove all combinations using this element.`)) {
        return;
    }
    
    // Remove element
    delete allElements[elementId];
    
    // Remove related combinations
    Object.keys(allCombinations).forEach(key => {
        const combo = allCombinations[key];
        if (combo.element1 == elementId || combo.element2 == elementId || combo.result == elementId) {
            delete allCombinations[key];
        }
    });
    
    renderDatabase();
    showMessage('Element deleted successfully', 'success');
}

// Copy emoji to clipboard
function copyEmoji(emoji) {
    navigator.clipboard.writeText(emoji).then(() => {
        showMessage('Emoji copied to clipboard!', 'success');
    });
}

// Close modal
function closeModal() {
    document.getElementById('edit-modal').classList.remove('active');
}

// Show message
function showMessage(text, type = 'success') {
    const message = document.getElementById('message');
    message.textContent = text;
    message.className = `message ${type} active`;
    
    setTimeout(() => {
        message.classList.remove('active');
    }, 3000);
}

// Render combinations view
function renderCombinations() {
    const grid = document.getElementById('combinations-grid');
    const searchTerm = document.getElementById('combo-search')?.value.toLowerCase() || '';
    
    grid.innerHTML = '';
    
    // Get unique combinations
    const uniqueCombos = [];
    const seen = new Set();
    
    Object.values(allCombinations).forEach(combo => {
        const key = [combo.element1, combo.element2].sort().join('_');
        if (!seen.has(key)) {
            seen.add(key);
            uniqueCombos.push(combo);
        }
    });
    
    // Filter and render
    uniqueCombos.forEach(combo => {
        const elem1 = allElements[combo.element1];
        const elem2 = allElements[combo.element2];
        const result = allElements[combo.result];
        
        if (!elem1 || !elem2 || !result) return;
        
        if (searchTerm) {
            const matchesSearch = 
                elem1.name.toLowerCase().includes(searchTerm) ||
                elem2.name.toLowerCase().includes(searchTerm) ||
                result.name.toLowerCase().includes(searchTerm);
            
            if (!matchesSearch) return;
        }
        
        grid.innerHTML += `
            <div class="element-card">
                <div style="text-align: center; font-size: 20px; margin-bottom: 15px;">
                    ${getElementDisplay(combo.element1)} + ${getElementDisplay(combo.element2)}
                </div>
                <div style="text-align: center; font-size: 24px; margin: 20px 0;">
                    ‚Üì
                </div>
                <div style="text-align: center; font-size: 24px; font-weight: bold;">
                    ${getElementDisplay(combo.result)}
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button onclick="editCombination('${combo.element1}', '${combo.element2}')">‚úèÔ∏è Edit</button>
                    <button class="danger" onclick="deleteCombination('${combo.element1}', '${combo.element2}')">üóëÔ∏è Delete</button>
                </div>
            </div>
        `;
    });
}

// Search combinations
function searchCombinations() {
    renderCombinations();
}

// Show all combinations
function showAllCombinations() {
    document.getElementById('combo-search').value = '';
    renderCombinations();
}

// Generate discovery tree
function generateTree() {
    const searchInput = document.getElementById('tree-search').value;
    const container = document.getElementById('tree-container');
    
    if (!searchInput || searchInput.trim() === '') {
        container.innerHTML = '<p style="color: #888;">Enter an element name or ID to generate its discovery tree.</p>';
        return;
    }
    
    // Find element
    let targetId = null;
    const searchLower = searchInput.trim().toLowerCase();
    
    for (const [id, element] of Object.entries(allElements)) {
        if (id === searchInput || element.name.toLowerCase() === searchLower) {
            targetId = id;
            break;
        }
    }
    
    if (!targetId) {
        container.innerHTML = '<p style="color: #e74c3c;">Element not found.</p>';
        return;
    }
    
    // Build discovery tree
    const tree = buildDiscoveryTree(targetId);
    container.innerHTML = '<h3>Discovery Tree</h3>' + renderTree(tree);
}

// Build discovery tree recursively
function buildDiscoveryTree(elementId, visited = new Set(), depth = 0) {
    if (visited.has(elementId) || depth > 5) {
        return { id: elementId, circular: true, children: [] };
    }
    
    visited.add(elementId);
    
    const recipes = findCombinationsForElement(elementId);
    const children = [];
    
    recipes.forEach(recipe => {
        children.push({
            recipe,
            left: buildDiscoveryTree(recipe.element1.toString(), new Set(visited), depth + 1),
            right: buildDiscoveryTree(recipe.element2.toString(), new Set(visited), depth + 1)
        });
    });
    
    return {
        id: elementId,
        children
    };
}

// Render tree HTML
function renderTree(node, level = 0) {
    const element = allElements[node.id];
    if (!element) return '';
    
    let html = `<div class="tree-container" style="margin-left: ${level * 30}px;">`;
    html += `<div class="tree-element">${getElementDisplay(node.id)}</div>`;
    
    if (node.circular) {
        html += '<span style="color: #888; margin-left: 10px;">(circular reference)</span>';
    }
    
    if (node.children.length > 0) {
        node.children.forEach(child => {
            html += '<div class="tree-node">';
            html += '<div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">';
            html += renderTree(child.left, 0);
            html += '<span class="tree-operator">+</span>';
            html += renderTree(child.right, 0);
            html += '</div>';
            html += '</div>';
        });
    }
    
    html += '</div>';
    return html;
}

// Render statistics
function renderStats() {
    const grid = document.getElementById('stats-grid');
    const detailed = document.getElementById('detailed-stats');
    
    // Calculate stats
    const totalElements = Object.keys(allElements).length;
    const totalCombinations = Object.keys(allCombinations).length / 2; // Divided by 2 because we store both directions
    
    const tierCounts = {};
    const orphanElements = [];
    const noRecipeElements = [];
    
    Object.entries(allElements).forEach(([id, element]) => {
        const tier = element.tier || 1;
        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
        
        // Check if orphan
        const usedInCombos = Object.values(allCombinations).some(combo => 
            combo.element1 == id || combo.element2 == id
        );
        if (!usedInCombos) {
            orphanElements.push({ id, element });
        }
        
        // Check if has recipe
        const hasRecipe = findCombinationsForElement(id).length > 0;
        if (!hasRecipe) {
            noRecipeElements.push({ id, element });
        }
    });
    
    // Render main stats
    grid.innerHTML = `
        <div class="stat-card">
            <div class="stat-value">${totalElements}</div>
            <div class="stat-label">Total Elements</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${totalCombinations}</div>
            <div class="stat-label">Total Combinations</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${orphanElements.length}</div>
            <div class="stat-label">Orphan Elements</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${noRecipeElements.length}</div>
            <div class="stat-label">Elements Without Recipes</div>
        </div>
    `;
    
    // Render detailed stats
    detailed.innerHTML = `
        <div class="tree-container">
            <h3>Elements by Tier</h3>
            ${Object.entries(tierCounts).sort(([a], [b]) => a - b).map(([tier, count]) => `
                <div style="margin: 10px 0;">
                    <strong>Tier ${tier}:</strong> ${count} elements
                    <div style="background: #333; height: 20px; margin-top: 5px; border-radius: 4px;">
                        <div style="background: #4ecdc4; height: 100%; width: ${(count / totalElements * 100).toFixed(1)}%; border-radius: 4px;"></div>
                    </div>
                </div>
            `).join('')}
        </div>
        
        <div class="tree-container" style="margin-top: 30px;">
            <h3>Orphan Elements (${orphanElements.length})</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                ${orphanElements.slice(0, 20).map(({ id, element }) => `
                    <div class="tree-element">${getElementDisplay(id)}</div>
                `).join('')}
                ${orphanElements.length > 20 ? `<div style="color: #888;">... and ${orphanElements.length - 20} more</div>` : ''}
            </div>
        </div>
        
        <div class="tree-container" style="margin-top: 30px;">
            <h3>Elements Without Recipes (${noRecipeElements.length})</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                ${noRecipeElements.slice(0, 20).map(({ id, element }) => `
                    <div class="tree-element">${getElementDisplay(id)}</div>
                `).join('')}
                ${noRecipeElements.length > 20 ? `<div style="color: #888;">... and ${noRecipeElements.length - 20} more</div>` : ''}
            </div>
        </div>
    `;
}

// Additional combination functions
function editCombination(elem1, elem2) {
    showMessage('Edit combination feature coming soon!', 'success');
}

function deleteCombination(elem1, elem2) {
    if (!confirm('Are you sure you want to delete this combination?')) {
        return;
    }
    
    const key1 = `${elem1}_${elem2}`;
    const key2 = `${elem2}_${elem1}`;
    
    delete allCombinations[key1];
    delete allCombinations[key2];
    
    renderCombinations();
    showMessage('Combination deleted successfully', 'success');
}