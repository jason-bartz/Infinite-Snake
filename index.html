<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Snake - Elemental Mastery</title>
    <link rel="icon" type="image/png" href="skins/favicon.png">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #discoveries {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #recentDiscovery {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #00FF00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #elementQueue {
            position: absolute;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #444;
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 14px;
            z-index: 10;
        }
        .queueElement {
            font-size: 20px;
            padding: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            position: relative;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .queueElement:hover {
            transform: scale(1.1);
            background: rgba(255,255,255,0.2);
        }
        .queueElement.compatible {
            animation: glow 1s infinite;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255,215,0,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,215,0,0.8); }
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 1px solid #444;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 14px;
            border: 1px solid #444;
        }
        #discoveryLog {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #444;
        }
        #discoveryLog h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #FFD700;
        }
        .discovery-item {
            margin: 5px 0;
            font-size: 12px;
            padding: 3px 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0033, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        #splashScreen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B, #4ECDC4, #FFD700);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        #gameModeSelect {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 50;
        }
        #gameModeSelect button {
            margin: 5px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        #powerUpIndicator {
            position: absolute;
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            z-index: 200;
            opacity: 0;
            animation: achievementPop 3s ease-out;
            text-align: center;
        }
        @keyframes achievementPop {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1);
            }
            30% {
                transform: translate(-50%, -50%) scale(1);
            }
            80% {
                opacity: 1;
            }
            100% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }
        .achievement h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .achievement .element-display {
            font-size: 48px;
            margin: 10px 0;
        }
        .achievement .element-name {
            font-size: 20px;
            color: white;
            margin-bottom: 5px;
        }
        .achievement .tier-info {
            font-size: 14px;
            color: #AAA;
        }
        .score-popup {
            position: fixed;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            animation: scoreFloat 1.5s ease-out;
        }
        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }
        @keyframes flashExpand {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
        .combining-animation {
            position: fixed;
            pointer-events: none;
            z-index: 150;
            font-size: 24px;
            text-align: center;
            animation: combineFloat 2s ease-out;
        }
        @keyframes combineFloat {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -100px) scale(1);
            }
        }
    </style>
</head>
<body>
    <div id="splashScreen">
        <h1>Infinite Snake</h1>
        <p>You are an Infinite Snake - a mystical serpent capable of endless growth and elemental mastery. Consume the scattered elements of creation, combine them within your ever-expanding form, and unlock the infinite possibilities that lie within the realm.</p>
        <button id="startButton">Begin Your Journey</button>
    </div>
    
    <div id="score">Score: 0</div>
    <div id="discoveries">Discoveries: 0 / ?</div>
    <div id="recentDiscovery"></div>
    <div id="powerUpIndicator"></div>
    
    <div id="elementQueue"></div>
    
    <div id="discoveryLog">
        <h3>Discovered Elements</h3>
        <div id="discoveryList"></div>
    </div>
    
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-list"></div>
    </div>
    
    <div id="controls">
        Arrow Keys: Move â€¢ P: Pause â€¢ M: Mute Music â€¢ S: Skins (while paused)
    </div>
    
    <div id="musicControls" style="position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #444;">
        <span style="color: white; font-size: 14px; margin-right: 10px;">ðŸŽµ Music:</span>
        <input type="range" id="volumeSlider" min="0" max="100" value="30" style="width: 100px; vertical-align: middle;">
        <span id="volumeLabel" style="color: white; font-size: 12px; margin-left: 5px;">30%</span>
    </div>
    
    <div id="gameModeSelect">
        <h3>Select Victory Condition</h3>
        <button onclick="startGame(100)">Discovery Race: 100</button>
        <button onclick="startGame(200)">Discovery Race: 200</button>
        <button onclick="startGame(500)">Discovery Race: 500</button>
        <button onclick="startGame(1000)">Discovery Race: 1000</button>
        <button onclick="startGame(0)">Infinite Mode</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 40;
        
        // Game constants
        const WORLD_SIZE = 2000;
        const SEGMENT_SIZE = 20;
        const ELEMENT_SIZE = 15;
        const SPEED = 4;
        const TURN_SPEED = 0.08;
        
        // Element System
        const BASIC_ELEMENTS = {
            fire: { emoji: 'ðŸ”¥', name: 'Fire', tier: 0 },
            water: { emoji: 'ðŸ’§', name: 'Water', tier: 0 },
            earth: { emoji: 'ðŸŒ', name: 'Earth', tier: 0 },
            air: { emoji: 'ðŸ’¨', name: 'Air', tier: 0 }
        };
        
        // Combination database - will be loaded from JSON files
        let COMBINATIONS = {};
        let ALL_ELEMENTS = {};
        let totalCombinations = 0;
        
        // Temporary fallback combinations
        const FALLBACK_COMBINATIONS = {
            'fire+water': { emoji: 'ðŸ’¨', name: 'Steam', tier: 1 },
            'fire+earth': { emoji: 'ðŸŒ‹', name: 'Lava', tier: 1 },
            'water+earth': { emoji: 'ðŸŒ±', name: 'Plant', tier: 1 },
            'air+air': { emoji: 'ðŸŒªï¸', name: 'Wind', tier: 1 },
            'fire+air': { emoji: 'âš¡', name: 'Energy', tier: 1 },
            'water+air': { emoji: 'â˜ï¸', name: 'Cloud', tier: 1 },
            'earth+earth': { emoji: 'ðŸª¨', name: 'Stone', tier: 1 },
            'water+water': { emoji: 'ðŸŒŠ', name: 'Wave', tier: 1 },
            'fire+fire': { emoji: 'ðŸ”¥', name: 'Blaze', tier: 1 }
        };
        
        // Initialize with fallback
        COMBINATIONS = { ...FALLBACK_COMBINATIONS };
        
        // Power-up mappings
        const ELEMENT_POWERS = {
            'lava': { type: 'lava_body', duration: 5000, color: '#FF4500' },
            'lightning': { type: 'speed', duration: 6000, color: '#FFD700' },
            'crystal': { type: 'armor', duration: 7000, color: '#00BFFF' },
            'ice': { type: 'ice_trail', duration: 5000, color: '#87CEEB' },
            'wind': { type: 'magnet', duration: 8000, color: '#98FB98' },
            'hurricane': { type: 'magnet', duration: 10000, color: '#4169E1' },
            'dragon': { type: 'lava_body', duration: 10000, color: '#FF6347' },
            'magic': { type: 'speed', duration: 8000, color: '#FF1493' }
        };
        
        // Game state
        let gameMode = 0;
        let targetDiscoveries = 0;
        let paused = false;
        let gameStarted = false;
        const camera = { x: 0, y: 0 };
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            p: false,
            P: false,
            m: false,
            M: false,
            s: false,
            S: false
        };
        
        // Game arrays
        let snakes = [];
        let elements = [];
        let particles = [];
        let playerSnake = null;
        
        // Music system
        const musicTracks = [
            'music/track1.mp3',
            'music/track2.mp3',
            'music/track3.mp3',
            'music/track4.mp3',
            'music/track5.mp3'
        ];
        let currentTrackIndex = -1;
        let audioPlayer = null;
        let musicEnabled = true;
        let musicVolume = 0.3; // 30% default volume
        
        // Snake skins system
        const SNAKE_SKINS = [
            // Default emoji skins (always available)
            { id: 'emoji1', type: 'emoji', emoji: 'ðŸ˜Š', primary: '#FF6B6B', secondary: '#FF5252', name: 'Happy', unlockScore: 0 },
            { id: 'emoji2', type: 'emoji', emoji: 'ðŸ˜„', primary: '#4ECDC4', secondary: '#45B7AA', name: 'Joyful', unlockScore: 0 },
            { id: 'emoji3', type: 'emoji', emoji: 'ðŸ˜', primary: '#FFE66D', secondary: '#FFD93D', name: 'Grinning', unlockScore: 0 },
            { id: 'emoji4', type: 'emoji', emoji: 'ðŸ˜Ž', primary: '#A8E6CF', secondary: '#81C784', name: 'Cool', unlockScore: 0 },
            { id: 'emoji5', type: 'emoji', emoji: 'ðŸ¤—', primary: '#C7CEEA', secondary: '#B39DDB', name: 'Hugging', unlockScore: 0 },
            
            // Image skins (unlockable)
            { id: 'black', type: 'image', image: 'skins/black.png', primary: '#333333', secondary: '#1a1a1a', name: 'Shadow', unlockScore: 100 },
            { id: 'blue', type: 'image', image: 'skins/blue.png', primary: '#4A90E2', secondary: '#357ABD', name: 'Azure', unlockScore: 200 },
            { id: 'green', type: 'image', image: 'skins/green.png', primary: '#4CAF50', secondary: '#388E3C', name: 'Emerald', unlockScore: 300 },
            { id: 'orange', type: 'image', image: 'skins/orange.png', primary: '#FF9800', secondary: '#F57C00', name: 'Citrus', unlockScore: 400 },
            { id: 'pink', type: 'image', image: 'skins/pink.png', primary: '#E91E63', secondary: '#C2185B', name: 'Blossom', unlockScore: 500 },
            { id: 'yellow', type: 'image', image: 'skins/yellow.png', primary: '#FFEB3B', secondary: '#FBC02D', name: 'Sunshine', unlockScore: 600 },
            { id: 'dog', type: 'image', image: 'skins/dog.png', primary: '#8D6E63', secondary: '#6D4C41', name: 'Puppy', unlockScore: 800 },
            { id: 'hotdog', type: 'image', image: 'skins/hotdog.png', primary: '#D2691E', secondary: '#A0522D', name: 'Hot Dog', unlockScore: 1000 },
            { id: 'gamer', type: 'image', image: 'skins/gamer.png', primary: '#9C27B0', secondary: '#7B1FA2', name: 'Gamer', unlockScore: 1500 },
            { id: 'robot', type: 'image', image: 'skins/robot.png', primary: '#607D8B', secondary: '#455A64', name: 'Mecha', unlockScore: 2000 },
            { id: 'ramen', type: 'image', image: 'skins/ramen.png', primary: '#FFA726', secondary: '#FB8C00', name: 'Ramen', unlockScore: 2500 },
            { id: 'toilet', type: 'image', image: 'skins/toilet.png', primary: '#ECEFF1', secondary: '#CFD8DC', name: 'Porcelain', unlockScore: 3000 },
            { id: 'tornado', type: 'image', image: 'skins/tornado.png', primary: '#78909C', secondary: '#546E7A', name: 'Whirlwind', unlockScore: 4000 },
            { id: 'neon', type: 'image', image: 'skins/neon.png', primary: '#FF00FF', secondary: '#00FFFF', name: 'Neon', unlockScore: 5000 },
            { id: 'space', type: 'image', image: 'skins/space.png', primary: '#311B92', secondary: '#1A237E', name: 'Cosmic', unlockScore: 7500 },
            { id: 'green-dragon', type: 'image', image: 'skins/green-dragon.png', primary: '#2E7D32', secondary: '#1B5E20', name: 'Jade Dragon', unlockScore: 10000 },
            { id: 'red-dragon', type: 'image', image: 'skins/red-dragon.png', primary: '#D32F2F', secondary: '#B71C1C', name: 'Crimson Dragon', unlockScore: 15000 },
            { id: 'unicorn-1', type: 'image', image: 'skins/unicorn-1.png', primary: '#F8BBD0', secondary: '#F48FB1', name: 'Unicorn', unlockScore: 20000 },
            { id: 'unicorn-2', type: 'image', image: 'skins/unicorn-2.png', primary: '#E1BEE7', secondary: '#CE93D8', name: 'Rainbow Unicorn', unlockScore: 25000 }
        ];
        
        // Track unlocked skins
        let unlockedSkins = new Set(['emoji1', 'emoji2', 'emoji3', 'emoji4', 'emoji5']);
        let selectedSkinId = 'emoji1';
        
        // Preload skin images
        const skinImages = {};
        SNAKE_SKINS.filter(skin => skin.type === 'image').forEach(skin => {
            const img = new Image();
            img.src = skin.image;
            skinImages[skin.id] = img;
        });
        
        let aiSkinIndex = 0; // For cycling through AI skins
        
        // Discovery tracking
        const discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
        let elementDatabase = { ...BASIC_ELEMENTS };
        
        // Initialize discovered elements in database
        Object.values(COMBINATIONS).forEach(combo => {
            elementDatabase[combo.name.toLowerCase()] = combo;
        });
        
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.segments = [];
                this.elements = []; // Elements in body
                this.length = 10;
                this.score = 0;
                this.discoveries = 0;
                this.isPlayer = isPlayer;
                this.speed = SPEED;
                this.alive = true;
                this.name = isPlayer ? 'You' : `Snake${Math.floor(Math.random() * 1000)}`;
                this.elementCapacity = 5; // Starting capacity
                this.maxCapacity = 5;
                this.combinationsMade = 0;
                
                // Assign skin
                if (isPlayer) {
                    this.skin = SNAKE_SKINS.find(s => s.id === selectedSkinId) || SNAKE_SKINS[0];
                } else {
                    // AI gets random skin from all available
                    const availableSkins = SNAKE_SKINS.filter(s => s.unlockScore <= 5000); // AI can use mid-tier skins
                    this.skin = availableSkins[Math.floor(Math.random() * availableSkins.length)];
                }
                
                // Power-ups
                this.activePower = null;
                this.powerTimer = 0;
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    this.segments.push({
                        x: x - i * SEGMENT_SIZE * Math.cos(this.angle),
                        y: y - i * SEGMENT_SIZE * Math.sin(this.angle)
                    });
                }
                
                // Initialize with random basic elements (up to capacity)
                const startingElements = Math.min(3, this.elementCapacity);
                for (let i = 0; i < startingElements; i++) {
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    const randomElement = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    this.elements.push(randomElement);
                }
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                // Update power-up timer
                if (this.activePower && this.powerTimer > 0) {
                    this.powerTimer -= deltaTime;
                    if (this.powerTimer <= 0) {
                        this.activePower = null;
                        if (this.isPlayer) {
                            document.getElementById('powerUpIndicator').style.opacity = '0';
                        }
                    }
                }
                
                // Calculate speed
                let currentSpeed = this.speed;
                if (this.activePower === 'speed') {
                    currentSpeed *= 1.5;
                }
                
                // Player controls
                if (this.isPlayer) {
                    if (keys.ArrowLeft) {
                        this.angle -= TURN_SPEED;
                    }
                    if (keys.ArrowRight) {
                        this.angle += TURN_SPEED;
                    }
                } else {
                    // Simple AI - target nearest element
                    let nearestElement = null;
                    let minDist = 400; // Increased vision range
                    
                    elements.forEach(element => {
                        const dist = Math.hypot(element.x - this.x, element.y - this.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestElement = element;
                        }
                    });
                    
                    if (nearestElement) {
                        const targetAngle = Math.atan2(nearestElement.y - this.y, nearestElement.x - this.x);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.08; // Slightly faster turning
                    } else {
                        // Wander
                        this.angle += (Math.random() - 0.5) * 0.1;
                    }
                }
                
                // Move head
                this.x += Math.cos(this.angle) * currentSpeed;
                this.y += Math.sin(this.angle) * currentSpeed;
                
                // World wrap with smooth transition
                if (this.x < 0) {
                    this.x += WORLD_SIZE;
                    if (this.isPlayer) {
                        camera.x += WORLD_SIZE;
                    }
                }
                if (this.x > WORLD_SIZE) {
                    this.x -= WORLD_SIZE;
                    if (this.isPlayer) {
                        camera.x -= WORLD_SIZE;
                    }
                }
                if (this.y < 0) {
                    this.y += WORLD_SIZE;
                    if (this.isPlayer) {
                        camera.y += WORLD_SIZE;
                    }
                }
                if (this.y > WORLD_SIZE) {
                    this.y -= WORLD_SIZE;
                    if (this.isPlayer) {
                        camera.y -= WORLD_SIZE;
                    }
                }
                
                // Update segments
                this.segments.unshift({ x: this.x, y: this.y });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
                
                // Survival score
                this.score += 1 * deltaTime / 1000; // Reduced from 10 to 1 for balance
                
                if (this.isPlayer) {
                    document.getElementById('score').textContent = `Score: ${Math.floor(this.score)}`;
                    const totalPossible = Object.keys(ALL_ELEMENTS).length || Object.keys(elementDatabase).length || '?';
                    document.getElementById('discoveries').textContent = 
                        gameMode === 0 ? `Discoveries: ${this.discoveries} / ${totalPossible}` : 
                        `Discoveries: ${this.discoveries} / ${targetDiscoveries}`;
                    
                    // Check for skin unlocks
                    checkSkinUnlocks(this.score);
                }
            }
            
            checkCombinations() {
                if (this.elements.length < 2) return;
                
                const combinationsFound = [];
                
                // Check all possible pairs of elements (regardless of position)
                for (let i = 0; i < this.elements.length; i++) {
                    for (let j = i + 1; j < this.elements.length; j++) {
                        const elem1 = this.elements[i];
                        const elem2 = this.elements[j];
                        
                        // Try both orders
                        const combo1 = `${elem1}+${elem2}`;
                        const combo2 = `${elem2}+${elem1}`;
                        
                        let result = COMBINATIONS[combo1] || COMBINATIONS[combo2];
                        
                        if (result) {
                            combinationsFound.push({
                                indices: [i, j],
                                result: result,
                                elem1: elem1,
                                elem2: elem2
                            });
                            // Only process one combination per check
                            break;
                        }
                    }
                    if (combinationsFound.length > 0) break;
                }
                
                // Process combinations
                for (const combo of combinationsFound) {
                    // Visual animation in element bar for player
                    if (this.isPlayer) {
                        createElementBarCombination(combo.elem1, combo.elem2, combo.result);
                    }
                    
                    // Remove used elements (higher index first to maintain positions)
                    const [idx1, idx2] = combo.indices.sort((a, b) => b - a);
                    this.elements.splice(idx2, 1);
                    this.elements.splice(idx1, 1);
                    
                    // Add new element
                    this.elements.push(combo.result.name.toLowerCase());
                    
                    // Increase capacity for successful combination
                    this.combinationsMade++;
                    if (this.combinationsMade % 3 === 0) { // Every 3 combinations
                        this.elementCapacity++;
                        this.maxCapacity = Math.max(this.maxCapacity, this.elementCapacity);
                        if (this.isPlayer) {
                            showCapacityIncrease();
                        }
                    }
                    
                    // Discovery tracking
                    const elementKey = combo.result.name.toLowerCase();
                    const isNewDiscovery = !discoveredElements.has(elementKey);
                    
                    if (isNewDiscovery) {
                        discoveredElements.add(elementKey);
                        this.discoveries++;
                        
                        // Add to element database for spawning
                        if (!elementDatabase[elementKey]) {
                            elementDatabase[elementKey] = combo.result;
                        }
                        
                        // Scoring
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        const totalPoints = discoveryPoints * 2; // Double points for first discovery
                        this.score += totalPoints;
                        
                        // Visual feedback
                        if (this.isPlayer) {
                            showDiscovery(combo.result);
                            showAchievement(combo.result);
                            createDiscoveryParticles(this.x, this.y);
                            createScorePopup(this.x, this.y, totalPoints);
                            
                            // Discovery cascade - spawn copies
                            for (let j = 0; j < 3 + Math.floor(Math.random() * 3); j++) {
                                spawnElement(combo.result.name.toLowerCase(), 
                                    this.x + (Math.random() - 0.5) * 200,
                                    this.y + (Math.random() - 0.5) * 200);
                            }
                        }
                        
                        // Check for power-up
                        if (ELEMENT_POWERS[elementKey]) {
                            this.activatePower(elementKey);
                        }
                        
                        // Update discovery log
                        updateDiscoveryLog();
                    } else {
                        // Existing combination - still give points
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        this.score += discoveryPoints;
                        
                        if (this.isPlayer) {
                            createScorePopup(this.x, this.y, discoveryPoints);
                        }
                    }
                    
                    // Particles for any combination
                    createCombinationParticles(
                        this.segments[0].x, 
                        this.segments[0].y,
                        combo.result.tier
                    );
                }
                
                // Update element queue display
                if (this.isPlayer) {
                    updateElementQueue();
                }
            }
            
            activatePower(elementName) {
                const power = ELEMENT_POWERS[elementName];
                if (!power) return;
                
                this.activePower = power.type;
                this.powerTimer = power.duration;
                
                if (this.isPlayer) {
                    const indicator = document.getElementById('powerUpIndicator');
                    const powerName = power.type.replace(/_/g, ' ').toUpperCase();
                    const powerEmojis = {
                        'lava_body': 'ðŸŒ‹',
                        'speed': 'âš¡',
                        'armor': 'ðŸ›¡ï¸',
                        'ice_trail': 'â„ï¸',
                        'magnet': 'ðŸ§²'
                    };
                    const emoji = powerEmojis[power.type] || 'ðŸ”¥';
                    indicator.textContent = `${emoji} ${powerName} (${power.duration/1000}s)`;
                    indicator.style.color = power.color;
                    indicator.style.opacity = '1';
                }
            }
            
            consume(element) {
                // Check if we have capacity
                if (this.elements.length >= this.elementCapacity) {
                    // Drop oldest element
                    const droppedElement = this.elements.shift();
                    if (this.isPlayer) {
                        showElementDropped(droppedElement);
                    }
                }
                
                // Add element to body
                this.elements.push(element.type);
                
                // Grow based on tier
                const elementData = elementDatabase[element.type] || { tier: 0 };
                const growthAmount = elementData.tier === 0 ? 1 : 
                                   elementData.tier <= 2 ? 2 : 
                                   elementData.tier <= 4 ? 3 : 4;
                
                this.length += growthAmount;
                
                // Remove element
                const index = elements.indexOf(element);
                if (index > -1) elements.splice(index, 1);
                
                // Update queue
                if (this.isPlayer) updateElementQueue();
            }
            
            die() {
                this.alive = false;
                
                // Drop only some elements (30-50% of total)
                const dropCount = Math.floor(this.elements.length * (0.3 + Math.random() * 0.2));
                const dropIndices = [];
                
                // Randomly select which elements to drop
                for (let i = 0; i < dropCount && i < this.segments.length; i++) {
                    let index;
                    do {
                        index = Math.floor(Math.random() * Math.min(this.elements.length, this.segments.length));
                    } while (dropIndices.includes(index));
                    dropIndices.push(index);
                }
                
                // Drop selected elements
                dropIndices.forEach(i => {
                    const segment = this.segments[i];
                    spawnElement(this.elements[i], 
                        segment.x + (Math.random() - 0.5) * 30,
                        segment.y + (Math.random() - 0.5) * 30);
                });
                
                if (this.isPlayer) {
                    // Respawn
                    setTimeout(() => {
                        playerSnake = new Snake(
                            Math.random() * WORLD_SIZE,
                            Math.random() * WORLD_SIZE,
                            true
                        );
                        // Penalty: lose one capacity slot
                        playerSnake.elementCapacity = Math.max(3, this.maxCapacity - 1);
                        playerSnake.maxCapacity = playerSnake.elementCapacity;
                        
                        snakes.push(playerSnake);
                        
                        // Reset camera to new player position immediately
                        camera.x = playerSnake.x;
                        camera.y = playerSnake.y;
                        
                        showDeathPenalty();
                    }, 3000);
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                // Draw segments
                for (let i = 0; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const screenX = segment.x - camera.x + canvas.width / 2;
                    const screenY = segment.y - camera.y + canvas.height / 2;
                    
                    // Skip if off screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    ctx.save();
                    
                    // Use snake's skin colors
                    ctx.fillStyle = i % 2 === 0 ? this.skin.primary : this.skin.secondary;
                    
                    // Power-up effects
                    if (this.activePower === 'lava_body') {
                        ctx.fillStyle = '#FF4500';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#FF4500';
                    } else if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                    }
                    
                    // Draw segment
                    const radius = SEGMENT_SIZE - i * 0.02;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add border
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Draw element emoji on segment (bigger and clearer)
                    if (i < this.elements.length) {
                        const elementType = this.elements[i];
                        const element = elementDatabase[elementType] || ALL_ELEMENTS[elementType];
                        if (element) {
                            ctx.save();
                            // Add slight background for better visibility
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, radius * 0.8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.font = `${radius * 1.4}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(element.emoji, screenX, screenY);
                            ctx.restore();
                        }
                    }
                }
                
                // Draw head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    const screenX = head.x - camera.x + canvas.width / 2;
                    const screenY = head.y - camera.y + canvas.height / 2;
                    
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                    
                    if (this.skin.type === 'emoji') {
                        // Draw emoji face
                        ctx.font = `${SEGMENT_SIZE * 1.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.skin.emoji, 0, 0);
                    } else if (this.skin.type === 'image' && skinImages[this.skin.id]) {
                        // Draw image head
                        const img = skinImages[this.skin.id];
                        if (img.complete) {
                            const size = SEGMENT_SIZE * 2.2;
                            ctx.drawImage(img, -size/2, -size/2, size, size);
                        }
                    }
                    
                    ctx.restore();
                    
                    // Draw name
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                    ctx.fillText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                }
            }
        }
        
        class Element {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.data = elementDatabase[type] || BASIC_ELEMENTS[type] || { emoji: 'â“', name: type, tier: 0 };
                this.createdTime = Date.now();
                this.pulse = 0;
                
                // Size based on tier
                this.size = ELEMENT_SIZE * (1 + this.data.tier * 0.25);
                
                // Expiration for rare elements
                this.expirationTime = this.data.tier >= 3 ? 8000 : 
                                    this.data.tier >= 5 ? 5000 : null;
            }
            
            update(deltaTime) {
                this.pulse += deltaTime * 0.005;
                
                // Check expiration
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    if (age > this.expirationTime) {
                        return false; // Remove element
                    }
                }
                
                // Magnet effect for nearby players with magnet power
                if (playerSnake && playerSnake.activePower === 'magnet') {
                    const dist = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    if (dist < 200) {
                        const angle = Math.atan2(playerSnake.y - this.y, playerSnake.x - this.x);
                        this.x += Math.cos(angle) * 2;
                        this.y += Math.sin(angle) * 2;
                    }
                }
                
                return true;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off screen
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                // Glow for higher tier elements
                if (this.data.tier > 0) {
                    const glowSize = this.size * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Expiration warning
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    const timeLeft = this.expirationTime - age;
                    if (timeLeft < 3000) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, this.size * scale + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Draw emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.data.emoji, screenX, screenY);
                
                // Draw name label
                ctx.font = `${Math.max(10, this.size * 0.6)}px Arial`;
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.data.name, screenX, screenY + this.size + 10);
                ctx.fillText(this.data.name, screenX, screenY + this.size + 10);
            }
        }
        
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Random spawn logic
                const rand = Math.random();
                if (rand < 0.7) {
                    // Basic element
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                } else if (rand < 0.95) {
                    // Discovered element
                    const discovered = Array.from(discoveredElements);
                    if (discovered.length > 4) {
                        type = discovered[Math.floor(Math.random() * discovered.length)];
                    } else {
                        const basicKeys = Object.keys(BASIC_ELEMENTS);
                        type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    }
                } else {
                    // Rare element
                    const allElements = Object.keys(elementDatabase);
                    if (allElements.length > 4) {
                        type = allElements[Math.floor(Math.random() * allElements.length)];
                    } else {
                        const basicKeys = Object.keys(BASIC_ELEMENTS);
                        type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    }
                }
            }
            
            x = x || Math.random() * WORLD_SIZE;
            y = y || Math.random() * WORLD_SIZE;
            
            elements.push(new Element(type, x, y));
        }
        
        function createCombinationParticles(x, y, tier) {
            const particleCount = 10 + tier * 5;
            const hue = (tier * 60) % 360;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                const particle = {
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: `hsl(${hue}, 70%, 50%)`
                };
                particles.push(particle);
            }
        }
        
        function createDiscoveryParticles(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                const hue = Math.random() * 360;
                const particle = {
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.5,
                    color: `hsl(${hue}, 100%, 50%)`
                };
                particles.push(particle);
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime / 1000;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                const screenX = p.x - camera.x + canvas.width / 2;
                const screenY = p.y - camera.y + canvas.height / 2;
                
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
            });
            ctx.globalAlpha = 1;
        }
        
        function createScorePopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            popup.textContent = `+${points}`;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1500);
        }
        
        function showAchievement(element) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.innerHTML = `
                <h3>NEW DISCOVERY!</h3>
                <div class="element-display">${element.emoji}</div>
                <div class="element-name">${element.name}</div>
                <div class="tier-info">Tier ${element.tier} Element</div>
            `;
            document.body.appendChild(achievement);
            
            setTimeout(() => {
                achievement.remove();
            }, 3000);
        }
        
        function createCombinationFlash(x, y) {
            const flash = document.createElement('div');
            flash.className = 'combination-flash';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            flash.style.left = screenX + 'px';
            flash.style.top = screenY + 'px';
            flash.style.transform = 'translate(-50%, -50%)';
            flash.style.width = '60px';
            flash.style.height = '60px';
            flash.style.borderRadius = '50%';
            flash.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            flash.style.animation = 'flashExpand 0.5s ease-out';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.remove();
            }, 500);
        }
        
        function createCombiningAnimation(x, y, elem1Name, elem2Name, result) {
            const elem1 = elementDatabase[elem1Name] || ALL_ELEMENTS[elem1Name];
            const elem2 = elementDatabase[elem2Name] || ALL_ELEMENTS[elem2Name];
            
            if (!elem1 || !elem2 || !result) return;
            
            const animation = document.createElement('div');
            animation.className = 'combining-animation';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            
            animation.style.left = screenX + 'px';
            animation.style.top = screenY + 'px';
            
            // Show the combination formula
            animation.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 2px solid #FFD700;">
                    <span style="font-size: 30px;">${elem1.emoji}</span>
                    <span style="color: #FFD700; font-size: 20px;">+</span>
                    <span style="font-size: 30px;">${elem2.emoji}</span>
                    <span style="color: #FFD700; font-size: 20px;">=</span>
                    <span style="font-size: 40px;">${result.emoji}</span>
                </div>
                <div style="color: #FFD700; margin-top: 5px; font-size: 16px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">${result.name}</div>
            `;
            
            document.body.appendChild(animation);
            
            setTimeout(() => {
                animation.remove();
            }, 2000);
        }
        
        function showDiscovery(element) {
            const display = document.getElementById('recentDiscovery');
            display.textContent = `NEW DISCOVERY: ${element.emoji} ${element.name}!`;
            display.style.opacity = '1';
            
            setTimeout(() => {
                display.style.opacity = '0';
            }, 4000); // Increased from 3000
        }
        
        function updateElementQueue() {
            if (!playerSnake) return;
            
            const queue = document.getElementById('elementQueue');
            queue.innerHTML = `<span style="color: #888; margin-right: 10px; font-size: 12px;">Elements (${playerSnake.elements.length}/${playerSnake.elementCapacity}):</span>`;
            
            // Show all elements with empty slots
            for (let i = 0; i < playerSnake.elementCapacity; i++) {
                const div = document.createElement('div');
                div.className = 'queueElement';
                
                if (i < playerSnake.elements.length) {
                    const elementType = playerSnake.elements[i];
                    const element = elementDatabase[elementType] || ALL_ELEMENTS[elementType];
                    
                    if (element) {
                        div.textContent = element.emoji;
                        div.title = element.name;
                        
                        // Check if any combination is possible
                        let hasCombo = false;
                        for (let j = 0; j < playerSnake.elements.length; j++) {
                            if (i !== j) {
                                const otherType = playerSnake.elements[j];
                                const combo1 = `${elementType}+${otherType}`;
                                const combo2 = `${otherType}+${elementType}`;
                                if (COMBINATIONS[combo1] || COMBINATIONS[combo2]) {
                                    hasCombo = true;
                                    break;
                                }
                            }
                        }
                        
                        if (hasCombo) {
                            div.classList.add('compatible');
                        }
                    }
                } else {
                    // Empty slot
                    div.style.opacity = '0.3';
                    div.style.border = '1px dashed #666';
                    div.textContent = 'â—‹';
                }
                
                queue.appendChild(div);
            }
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            const discovered = Array.from(discoveredElements).sort();
            discovered.forEach(elementKey => {
                const element = elementDatabase[elementKey] || ALL_ELEMENTS[elementKey];
                if (element && element.tier > 0) {
                    const div = document.createElement('div');
                    div.className = 'discovery-item';
                    div.innerHTML = `${element.emoji} ${element.name} (Tier ${element.tier})`;
                    list.appendChild(div);
                }
            });
        }
        
        function updateLeaderboard() {
            const sortedSnakes = snakes
                .filter(s => s.alive)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = sortedSnakes.map((snake, index) => `
                <div style="${snake.isPlayer ? 'color: #FFD700;' : ''}">
                    ${index + 1}. ${snake.name} - ${Math.floor(snake.score)}
                </div>
            `).join('');
        }
        
        function checkCollisions() {
            snakes.forEach(snake => {
                if (!snake.alive) return;
                
                // Element collisions
                elements.forEach(element => {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + element.size + 5) { // Added 5 pixel buffer
                        snake.consume(element);
                    }
                });
                
                // Snake collisions
                snakes.forEach(otherSnake => {
                    if (snake === otherSnake || !otherSnake.alive) return;
                    
                    // Check head collision with other snake's body
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        
                        if (dist < SEGMENT_SIZE) {
                            // Check for lava body power
                            if (otherSnake.activePower === 'lava_body') {
                                snake.die();
                            } else if (snake.activePower !== 'armor') {
                                snake.die();
                            }
                            return;
                        }
                    }
                });
            });
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function updateCamera() {
            if (playerSnake && playerSnake.alive) {
                // Smooth camera follow to prevent teleporting
                const targetX = playerSnake.x;
                const targetY = playerSnake.y;
                
                // Lerp camera position for smooth movement
                camera.x += (targetX - camera.x) * 0.1;
                camera.y += (targetY - camera.y) * 0.1;
            }
        }
        
        let elementSpawnTimer = 0;
        let lastTime = 0;
        
        function gameLoop(currentTime) {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = Math.min(currentTime - lastTime, 100);
            lastTime = currentTime;
            
            if (!paused) {
                // Element spawning - faster rate
                elementSpawnTimer += deltaTime;
                if (elementSpawnTimer > 1000) { // Spawn every second instead of 2
                    elementSpawnTimer = 0;
                    // Spawn 2-3 elements at once
                    const spawnCount = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < spawnCount; i++) {
                        spawnElement();
                    }
                }
                
                // Maintain minimum elements on board
                if (elements.length < 50) { // Increased from 40 to 50
                    spawnElement();
                }
                
                // Update elements
                for (let i = elements.length - 1; i >= 0; i--) {
                    if (!elements[i].update(deltaTime)) {
                        elements.splice(i, 1);
                    }
                }
                
                // Update snakes
                snakes.forEach(snake => snake.update(deltaTime));
                
                // Update particles
                updateParticles(deltaTime);
                
                // Collisions
                checkCollisions();
                
                // Camera
                updateCamera();
                
                // Remove dead AI snakes
                snakes.forEach((snake, index) => {
                    if (!snake.alive && !snake.isPlayer) {
                        const idx = snakes.indexOf(snake);
                        if (idx > -1) snakes.splice(idx, 1);
                    }
                });
                
                // Spawn AI if needed
                const aliveAI = snakes.filter(s => !s.isPlayer && s.alive).length;
                if (aliveAI < 8) { // Increased from 5 to 8 for more activity
                    const aiSnake = new Snake(
                        Math.random() * WORLD_SIZE,
                        Math.random() * WORLD_SIZE,
                        false
                    );
                    snakes.push(aiSnake);
                }
                
                // Check victory
                if (gameMode > 0 && playerSnake && playerSnake.discoveries >= targetDiscoveries) {
                    alert(`ðŸŽ‰ VICTORY! ðŸŽ‰\n\nYou've mastered the elements and discovered ${targetDiscoveries} combinations!\n\nFinal Score: ${Math.floor(playerSnake.score)}`);
                    location.reload();
                }
            }
            
            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            
            // Draw elements
            elements.forEach(element => element.draw());
            
            // Draw snakes
            snakes.forEach(snake => snake.draw());
            
            // Draw particles
            drawParticles();
            
            // Update UI
            updateLeaderboard();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
                
                if (e.key === 'p' || e.key === 'P') {
                    paused = !paused;
                    if (!paused) {
                        closeSkinMenu();
                    }
                }
            }
            
            // Music controls
            if (e.key === 'm' || e.key === 'M') {
                toggleMusic();
                e.preventDefault();
            }
            
            // Skin menu
            if ((e.key === 's' || e.key === 'S') && paused) {
                toggleSkinMenu();
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        });
        
        // Start game
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        function startGame(mode) {
            gameMode = mode;
            targetDiscoveries = mode;
            gameStarted = true;
            
            document.getElementById('gameModeSelect').style.display = 'none';
            
            // Start music
            initMusic();
            
            // Initialize player
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            playerSnake.angle = -Math.PI / 2; // Face upward
            snakes.push(playerSnake);
            
            // Initialize AI snakes
            for (let i = 0; i < 8; i++) {
                const aiSnake = new Snake(
                    Math.random() * WORLD_SIZE,
                    Math.random() * WORLD_SIZE,
                    false
                );
                snakes.push(aiSnake);
            }
            
            // Initial elements - more for less sparse board
            for (let i = 0; i < 60; i++) {
                spawnElement();
            }
            
            updateDiscoveryLog();
            updateElementQueue();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 40;
            canvas.height = window.innerHeight - 40;
        });
        
        // Load combination data from JSON files
        async function loadCombinationData() {
            const files = [
                'Element Files/Infinite Craft Part 1.json',
                'Element Files/Infinite Craft Part 2.json',
                'Element Files/Infinite Craft Part 3.json',
                'Element Files/Infinite Craft Part 4.json',
                'Element Files/infinite-craft-part5.json',
                'Element Files/infinite-craft-part6.json',
                'Element Files/infinite-craft-part7.json',
                'Element Files/infinite-craft-part8.json',
                'Element Files/infinite-craft-part9.json',
                'Element Files/infinite-craft-part10.json',
                'Element Files/infinite-craft-part11.json'
            ];
            
            try {
                for (const file of files) {
                    try {
                        const response = await fetch(file);
                        if (!response.ok) {
                            console.warn(`Failed to load ${file}:`, response.statusText);
                            continue;
                        }
                        const data = await response.json();
                    
                    // Process combinations from each file
                    if (data.combinations) {
                        // Handle different sections of combinations
                        for (const section of Object.values(data.combinations)) {
                            if (Array.isArray(section)) {
                                // Handle array format
                                for (const combo of section) {
                                    if (combo.element1 && combo.element2 && combo.result) {
                                        // Parse element format "emoji name"
                                        const parseElement = (str) => {
                                            const match = str.match(/^([^\s]+)\s+(.+)$/);
                                            if (match) {
                                                return { emoji: match[1], name: match[2] };
                                            }
                                            return null;
                                        };
                                        
                                        const elem1 = parseElement(combo.element1);
                                        const elem2 = parseElement(combo.element2);
                                        const result = parseElement(combo.result);
                                        
                                        if (elem1 && elem2 && result) {
                                            const key1 = `${elem1.name.toLowerCase()}+${elem2.name.toLowerCase()}`;
                                            const key2 = `${elem2.name.toLowerCase()}+${elem1.name.toLowerCase()}`;
                                            
                                            const tier = determineTier(result.name);
                                            const elementData = { emoji: result.emoji, name: result.name, tier };
                                            
                                            COMBINATIONS[key1] = elementData;
                                            COMBINATIONS[key2] = elementData;
                                            ALL_ELEMENTS[result.name.toLowerCase()] = elementData;
                                            ALL_ELEMENTS[elem1.name.toLowerCase()] = { emoji: elem1.emoji, name: elem1.name, tier: determineTier(elem1.name) };
                                            ALL_ELEMENTS[elem2.name.toLowerCase()] = { emoji: elem2.emoji, name: elem2.name, tier: determineTier(elem2.name) };
                                            totalCombinations++;
                                        }
                                    }
                                }
                            } else if (typeof section === 'object') {
                                // Handle object format
                                for (const [combo, result] of Object.entries(section)) {
                                    const [elem1, elem2] = combo.split(' + ');
                                    if (!elem1 || !elem2) continue;
                                    
                                    const key1 = `${elem1.toLowerCase()}+${elem2.toLowerCase()}`;
                                    const key2 = `${elem2.toLowerCase()}+${elem1.toLowerCase()}`;
                                    
                                    // Parse result format "emoji|name"
                                    let emoji, name;
                                    if (typeof result === 'string') {
                                        [emoji, name] = result.split('|');
                                    } else if (result.emoji && result.name) {
                                        emoji = result.emoji;
                                        name = result.name;
                                    }
                                    
                                    if (emoji && name) {
                                        const tier = determineTier(name);
                                        const elementData = { emoji, name, tier };
                                        
                                        COMBINATIONS[key1] = elementData;
                                        COMBINATIONS[key2] = elementData;
                                        ALL_ELEMENTS[name.toLowerCase()] = elementData;
                                        totalCombinations++;
                                    }
                                }
                            }
                        }
                    }
                    } catch (fileError) {
                        console.warn(`Error processing ${file}:`, fileError);
                    }
                }
                
                // Also add reverse combinations to ensure all are available
                const currentCombos = { ...COMBINATIONS };
                for (const [key, value] of Object.entries(currentCombos)) {
                    const [elem1, elem2] = key.split('+');
                    if (elem1 && elem2) {
                        const reverseKey = `${elem2}+${elem1}`;
                        if (!COMBINATIONS[reverseKey]) {
                            COMBINATIONS[reverseKey] = value;
                        }
                    }
                }
                
                // Update element database
                elementDatabase = { ...BASIC_ELEMENTS, ...ALL_ELEMENTS };
                console.log(`Loaded ${Object.keys(COMBINATIONS).length} total combinations (${totalCombinations} unique results)!`);
                return true;
            } catch (error) {
                console.error('Error loading combinations:', error);
                // Use fallback combinations
                Object.values(FALLBACK_COMBINATIONS).forEach(combo => {
                    ALL_ELEMENTS[combo.name.toLowerCase()] = combo;
                });
                elementDatabase = { ...BASIC_ELEMENTS, ...ALL_ELEMENTS };
                return false;
            }
        }
        
        function determineTier(name) {
            // Tier determination based on complexity
            const lowerName = name.toLowerCase();
            
            // Tier 5 - Legendary/Mythical
            if (lowerName.includes('god') || lowerName.includes('universe') || 
                lowerName.includes('infinity') || lowerName.includes('dragon') ||
                lowerName.includes('phoenix') || lowerName.includes('titan')) {
                return 5;
            }
            // Tier 4 - Magical/Powerful
            if (lowerName.includes('magic') || lowerName.includes('wizard') ||
                lowerName.includes('galaxy') || lowerName.includes('star') ||
                lowerName.includes('demon') || lowerName.includes('angel')) {
                return 4;
            }
            // Tier 3 - Complex/Advanced
            if (lowerName.includes('city') || lowerName.includes('civilization') ||
                lowerName.includes('technology') || lowerName.includes('computer') ||
                lowerName.includes('robot') || lowerName.includes('spaceship')) {
                return 3;
            }
            // Tier 2 - Moderate complexity
            if (lowerName.includes('tool') || lowerName.includes('machine') ||
                lowerName.includes('building') || lowerName.includes('animal') ||
                lowerName.includes('plant') || lowerName.includes('metal')) {
                return 2;
            }
            // Tier 1 - Basic combinations
            return 1;
        }
        
        // Initialize game
        async function initGame() {
            console.log('Initializing game...');
            
            // Load skin progress
            loadSkinProgress();
            
            try {
                await loadCombinationData();
            } catch (error) {
                console.error('Failed to load combinations, using fallback:', error);
            }
            
            // Update total discoveries display
            const totalPossible = Object.keys(ALL_ELEMENTS).length || Object.keys(FALLBACK_COMBINATIONS).length;
            const totalCombos = Object.keys(COMBINATIONS).length;
            if (totalPossible > 0) {
                document.getElementById('discoveries').textContent = `Discoveries: 0 / ${totalPossible}`;
                console.log(`Game ready with ${totalPossible} unique elements and ${totalCombos} combinations`);
            }
            
            console.log('Starting game loop...');
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        function createElementBarCombination(elem1Name, elem2Name, result) {
            const elem1 = elementDatabase[elem1Name] || ALL_ELEMENTS[elem1Name];
            const elem2 = elementDatabase[elem2Name] || ALL_ELEMENTS[elem2Name];
            
            if (!elem1 || !elem2 || !result) return;
            
            const queue = document.getElementById('elementQueue');
            const rect = queue.getBoundingClientRect();
            
            const animation = document.createElement('div');
            animation.className = 'combining-animation';
            animation.style.left = rect.left + rect.width / 2 + 'px';
            animation.style.top = rect.top + 'px';
            animation.style.fontSize = '18px';
            
            animation.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 5px; background: rgba(0,0,0,0.9); padding: 5px 10px; border-radius: 10px; border: 2px solid #FFD700;">
                    <span style="font-size: 20px;">${elem1.emoji}</span>
                    <span style="color: #FFD700;">+</span>
                    <span style="font-size: 20px;">${elem2.emoji}</span>
                    <span style="color: #FFD700;">=</span>
                    <span style="font-size: 25px;">${result.emoji}</span>
                </div>
            `;
            
            document.body.appendChild(animation);
            
            setTimeout(() => {
                animation.remove();
            }, 2000);
        }
        
        function showCapacityIncrease() {
            const message = document.createElement('div');
            message.className = 'score-popup';
            message.style.position = 'fixed';
            message.style.left = '50%';
            message.style.top = '200px';
            message.style.transform = 'translateX(-50%)';
            message.style.fontSize = '20px';
            message.style.color = '#00FF00';
            message.textContent = '+1 Element Slot!';
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.remove();
            }, 1500);
        }
        
        function showElementDropped(elementName) {
            const element = elementDatabase[elementName] || ALL_ELEMENTS[elementName];
            if (!element) return;
            
            const message = document.createElement('div');
            message.className = 'score-popup';
            message.style.position = 'fixed';
            message.style.left = '50%';
            message.style.top = '180px';
            message.style.transform = 'translateX(-50%)';
            message.style.fontSize = '16px';
            message.style.color = '#FF6666';
            message.textContent = `Dropped: ${element.emoji} ${element.name}`;
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.remove();
            }, 1500);
        }
        
        function showDeathPenalty() {
            const message = document.createElement('div');
            message.className = 'score-popup';
            message.style.position = 'fixed';
            message.style.left = '50%';
            message.style.top = '50%';
            message.style.transform = 'translate(-50%, -50%)';
            message.style.fontSize = '24px';
            message.style.color = '#FF0000';
            message.style.background = 'rgba(0,0,0,0.8)';
            message.style.padding = '20px';
            message.style.borderRadius = '10px';
            message.style.border = '2px solid #FF0000';
            message.textContent = '-1 Element Capacity';
            document.body.appendChild(message);
            
            setTimeout(() => {
                message.remove();
            }, 2000);
        }
        
        // Skin system functions
        function checkSkinUnlocks(currentScore) {
            let hasNewUnlock = false;
            
            SNAKE_SKINS.forEach(skin => {
                if (!unlockedSkins.has(skin.id) && currentScore >= skin.unlockScore) {
                    unlockedSkins.add(skin.id);
                    hasNewUnlock = true;
                    showSkinUnlocked(skin);
                }
            });
            
            if (hasNewUnlock) {
                saveSkinProgress();
            }
        }
        
        function showSkinUnlocked(skin) {
            const notification = document.createElement('div');
            notification.className = 'achievement';
            notification.innerHTML = `
                <h3>NEW SKIN UNLOCKED!</h3>
                <div class="element-display">
                    ${skin.type === 'emoji' ? skin.emoji : `<img src="${skin.image}" style="width: 60px; height: 60px;">`}
                </div>
                <div class="element-name">${skin.name}</div>
                <div class="tier-info">Press P then S to equip</div>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 4000);
        }
        
        function toggleSkinMenu() {
            const menu = document.getElementById('skinMenu');
            if (menu.style.display === 'block') {
                closeSkinMenu();
            } else {
                openSkinMenu();
            }
        }
        
        function openSkinMenu() {
            const menu = document.getElementById('skinMenu');
            const grid = document.getElementById('skinGrid');
            
            // Clear and rebuild grid
            grid.innerHTML = '';
            
            SNAKE_SKINS.forEach(skin => {
                const isUnlocked = unlockedSkins.has(skin.id);
                const div = document.createElement('div');
                div.className = 'skinItem';
                if (skin.id === selectedSkinId) div.classList.add('selected');
                if (!isUnlocked) div.classList.add('locked');
                
                const preview = document.createElement('div');
                preview.className = 'skinPreview';
                if (skin.type === 'emoji') {
                    preview.textContent = skin.emoji;
                } else {
                    const img = document.createElement('img');
                    img.src = skin.image;
                    preview.appendChild(img);
                }
                
                const name = document.createElement('div');
                name.className = 'skinName';
                name.textContent = skin.name;
                
                div.appendChild(preview);
                div.appendChild(name);
                
                if (!isUnlocked) {
                    const req = document.createElement('div');
                    req.className = 'skinRequirement';
                    req.textContent = `Score: ${skin.unlockScore}`;
                    div.appendChild(req);
                } else if (skin.unlockScore > 0 && !localStorage.getItem(`skin_${skin.id}_seen`)) {
                    const newTag = document.createElement('div');
                    newTag.className = 'skinNew';
                    newTag.textContent = 'NEW!';
                    div.style.position = 'relative';
                    div.appendChild(newTag);
                }
                
                if (isUnlocked) {
                    div.onclick = () => selectSkin(skin.id);
                }
                
                grid.appendChild(div);
            });
            
            menu.style.display = 'block';
        }
        
        function closeSkinMenu() {
            document.getElementById('skinMenu').style.display = 'none';
        }
        
        function selectSkin(skinId) {
            selectedSkinId = skinId;
            localStorage.setItem('selectedSkin', skinId);
            localStorage.setItem(`skin_${skinId}_seen`, 'true');
            
            // Update player skin immediately
            if (playerSnake) {
                playerSnake.skin = SNAKE_SKINS.find(s => s.id === skinId);
            }
            
            // Update UI
            openSkinMenu(); // Refresh to show selection
        }
        
        function saveSkinProgress() {
            localStorage.setItem('unlockedSkins', JSON.stringify([...unlockedSkins]));
        }
        
        function loadSkinProgress() {
            const saved = localStorage.getItem('unlockedSkins');
            if (saved) {
                unlockedSkins = new Set(JSON.parse(saved));
            }
            
            const savedSelection = localStorage.getItem('selectedSkin');
            if (savedSelection && unlockedSkins.has(savedSelection)) {
                selectedSkinId = savedSelection;
            }
        }
        
        // Music functions
        function initMusic() {
            if (!audioPlayer) {
                audioPlayer = new Audio();
                audioPlayer.volume = musicVolume;
                
                // Play next track when current one ends
                audioPlayer.addEventListener('ended', () => {
                    playNextTrack();
                });
                
                // Handle loading errors
                audioPlayer.addEventListener('error', (e) => {
                    console.warn('Error loading music track:', e);
                    // Try next track after a delay
                    setTimeout(playNextTrack, 1000);
                });
            }
            
            playNextTrack();
        }
        
        function playNextTrack() {
            if (!musicEnabled || musicTracks.length === 0) return;
            
            // Select random track, but not the same one that just played
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * musicTracks.length);
            } while (newIndex === currentTrackIndex && musicTracks.length > 1);
            
            currentTrackIndex = newIndex;
            audioPlayer.src = musicTracks[currentTrackIndex];
            
            // Attempt to play
            audioPlayer.play().catch(e => {
                console.log('Music autoplay blocked, will start on user interaction');
                // Set up one-time click listener to start music
                document.addEventListener('click', startMusicOnInteraction, { once: true });
            });
        }
        
        function startMusicOnInteraction() {
            if (audioPlayer && musicEnabled) {
                audioPlayer.play().catch(e => console.log('Could not start music:', e));
            }
        }
        
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            
            if (musicEnabled) {
                if (audioPlayer && audioPlayer.paused) {
                    audioPlayer.play();
                }
            } else {
                if (audioPlayer) {
                    audioPlayer.pause();
                }
            }
            
            // Update UI
            const controls = document.getElementById('musicControls');
            if (controls) {
                controls.style.opacity = musicEnabled ? '1' : '0.5';
            }
        }
        
        function setMusicVolume(volume) {
            musicVolume = volume / 100;
            if (audioPlayer) {
                audioPlayer.volume = musicVolume;
            }
            document.getElementById('volumeLabel').textContent = volume + '%';
        }
        
        // Volume slider listener
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            setMusicVolume(e.target.value);
        });
        
        initGame();
    </script>
</body>
</html>