<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Infinite Snake - Craft the Cosmos | Free Element Crafting Snake Game</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" id="Viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta property="og:description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta name="keywords" content="infinite snake, snake game, element crafting, craft game, single player snake, browser game, free game, online snake, element combinations, discovery game, alchemy game, snake.io, slither.io, google snake, infinite craft snake, crafting game" />
    
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Infinite Snake - Craft the Cosmos" />
    <meta property="og:site_name" content="Infinite Snake" />
    <meta property="og:image" content="https://infinitesnake.io/assets/snake-logo.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="A snake game where you craft elements and rebuild the cosmos" />
    <meta property="og:locale" content="en_US" />
    
    <meta name="twitter:title" content="Infinite Snake - Craft the Cosmos" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="Combine elements, grow your snake, and discover endless combinations in this unique twist on the classic snake game. Free to play in your browser and mobile!">
    <meta name="twitter:image" content="https://infinitesnake.io/assets/snake-logo.png">
    
    <meta name='robots' content='index,follow' />
    <meta name="twitter:url" content="https://infinitesnake.io" />
    <meta property="og:url" content="https://infinitesnake.io" />
    <meta name="url" content="https://infinitesnake.io" />
    <link rel="canonical" href="https://infinitesnake.io">
    
    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org/",
        "@type": "Game",
        "image": "https://infinitesnake.io/assets/snake-logo.png",
        "name": "Infinite Snake",
        "url": "https://infinitesnake.io",
        "description": "A unique snake game featuring element crafting mechanics. Combine fire, water, earth, and air to discover endless elements while growing your snake and rebuilding the cosmos.",
        "genre": "Arcade, Puzzle, Strategy, Casual",
        "gamePlatform": ["Web Browser", "Mobile Web"],
        "operatingSystem": "Any",
        "applicationCategory": "Game",
        "inLanguage": "en",
        "author": {
            "@type": "Person",
            "name": "Jason Bartz"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.6",
            "bestRating": "5",
            "ratingCount": "2847"
        }
    }
    </script>
    
    <!-- FAQ Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [{
                "@type": "Question",
                "name": "What is Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake is a free browser game that combines classic snake gameplay with element crafting mechanics. Collect elements, combine them to discover new ones, and grow your snake while rebuilding the cosmos."
                }
            },
            {
                "@type": "Question",
                "name": "How do I play Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use your mouse, arrow keys, or WASD to control your snake on desktop, or touch controls on mobile. Collect elemental orbs and combine them in your snake's body to discover new elements. Avoid collisions with other snakes and borders while growing larger."
                }
            },
            {
                "@type": "Question",
                "name": "Is Infinite Snake free to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is completely free to play in your web browser on both desktop and mobile. No download or installation required - just visit infinitesnake.io and start playing instantly."
                }
            },
            {
                "@type": "Question",
                "name": "How many elements can I discover in Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "There are hundreds of unique elements to discover through combinations, ranging from basic elements like fire and water to complex creations like dragons, technology, and cosmic entities. New combinations are added regularly!"
                }
            },
            {
                "@type": "Question",
                "name": "Can I play Infinite Snake on mobile?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is fully optimized for mobile devices with intuitive touch controls. Simply visit infinitesnake.io on your mobile browser to play."
                }
            },
            {
                "@type": "Question",
                "name": "What makes Infinite Snake different from other snake games?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake uniquely combines snake gameplay with element crafting mechanics inspired by games like Little Alchemy and Infinite Craft. As you consume elements, they combine in your snake's body to create new discoveries, adding a strategic puzzle element to the classic snake formula."
                }
            },
            {
                "@type": "Question",
                "name": "Do I need to create an account to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "No account required! Your discoveries and progress are saved locally in your browser, allowing you to jump in and play immediately without any registration."
                }
            },
            {
                "@type": "Question",
                "name": "What are the controls for Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "On desktop, use your mouse to guide your snake - it will follow your cursor. Click and hold to boost. On mobile devices, use the virtual joystick to direct your snake and the boost button to speed up. Press P to pause the game at any time on desktop."
                }
            }
        ]
    }
    </script>
    
    <!-- Additional SEO -->
    <meta name="author" content="Jason Bartz">
    <meta name="theme-color" content="#4ecdc4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Mobile optimization tags -->
    <meta name="HandheldFriendly" content="true">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Alternate language versions -->
    <link rel="alternate" hreflang="en" href="https://infinitesnake.io" />
    <link rel="alternate" hreflang="x-default" href="https://infinitesnake.io" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.8s ease-in;
        }
        
        /* Splash Screen */
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        #splashStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #splashContent {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #splashScreen img {
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        #startButton:hover {
            transform: scale(1.1);
        }
        
        #splashTitle {
            font-size: 60px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: none;
        }
        
        /* Game Mode Selection */
        #gameModeSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            display: none;
            z-index: 50;
        }
        
        #gameModeStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #gameModeContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #444;
            max-width: 800px;
            width: 90%;
            z-index: 1;
        }
        
        #gameModeSelect h3 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        .modeSection {
            margin-bottom: 30px;
        }
        
        .modeSection h4 {
            color: #AAA;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #gameModeSelect button {
            margin: 5px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 180px;
        }
        
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        
        /* Victory Mode Layout */
        #victoryButtons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .victory-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .victory-column h5 {
            color: #FFD700;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .victory-infinite {
            grid-column: span 2;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        /* Discovery Mode Buttons */
        .btn-discovery {
            background: linear-gradient(135deg, #2E7D32, #1B5E20) !important;
            border: 1px solid #4CAF50 !important;
        }
        
        .btn-discovery:hover {
            background: linear-gradient(135deg, #388E3C, #2E7D32) !important;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Points Mode Buttons */
        .btn-points {
            background: linear-gradient(135deg, #D32F2F, #B71C1C) !important;
            border: 1px solid #F44336 !important;
        }
        
        .btn-points:hover {
            background: linear-gradient(135deg, #E53935, #D32F2F) !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
        }
        
        /* Infinite Mode Button */
        .btn-infinite {
            background: linear-gradient(135deg, #7B1FA2, #4A148C) !important;
            border: 1px solid #9C27B0 !important;
            min-width: 250px !important;
            font-size: 18px !important;
            padding: 15px 30px !important;
        }
        
        .btn-infinite:hover {
            background: linear-gradient(135deg, #8E24AA, #6A1B9A) !important;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.6);
        }
        
        #loadingIndicator {
            display: none;
            margin: 10px 0;
            color: #FFD700;
            font-size: 14px;
        }
        
        /* Canvas */
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Discovery Sidebar - Hidden (using discovery feed instead) */
        #discoveryLog {
            display: none;
        }
        
        #discoveryLog h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #FFD700;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .discovery-item {
            margin: 8px 0;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .discovery-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        
        .discovery-item .emoji {
            font-size: 24px;
        }
        
        .discovery-item .info {
            flex: 1;
        }
        
        .discovery-item .name {
            font-weight: bold;
            color: white;
        }
        
        .discovery-item .tier {
            font-size: 11px;
            color: #AAA;
        }
        
        .discovery-item.new {
            animation: newItemGlow 2s ease-out;
            background: rgba(255, 215, 0, 0.2);
        }
        
        @keyframes newItemGlow {
            0% {
                background: rgba(255, 215, 0, 0.5);
                transform: translateX(10px);
            }
            100% {
                background: rgba(255, 215, 0, 0.2);
                transform: translateX(0);
            }
        }
        
        /* Main UI overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #score {
            display: none; /* Hidden - score shown in leaderboard */
        }
        
        #discoveries {
            display: none; /* Hidden - discoveries shown elsewhere */
        }
        
        /* Bottom UI Bar (MMO-style) */
        .bottom-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: auto;
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.7) 10%,
                rgba(10, 10, 26, 0.95) 30%,
                rgba(10, 10, 26, 0.98) 100%
            );
            padding-top: 20px;
            border-top: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 -10px 30px rgba(138, 43, 226, 0.2);
        }
        
        /* Element Collection Bar (Skill Bar Style) */
        .element-collection-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
            margin-bottom: 10px;
            gap: 4px;
        }
        
        .element-slot {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.9) 0%,
                rgba(30, 30, 50, 0.8) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .element-slot.empty {
            background: linear-gradient(135deg, 
                rgba(10, 10, 20, 0.6) 0%,
                rgba(20, 20, 30, 0.5) 100%
            );
            border-color: rgba(100, 100, 120, 0.3);
            border-style: dashed;
        }
        
        .element-slot.filled {
            background: linear-gradient(135deg, 
                rgba(40, 40, 60, 0.9) 0%,
                rgba(50, 50, 70, 0.8) 100%
            );
            border-color: rgba(138, 43, 226, 0.6);
        }
        
        .element-slot.tail-element {
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                       inset 0 0 10px rgba(255, 215, 0, 0.2);
            animation: tailPulse 2s ease-in-out infinite;
        }
        
        @keyframes tailPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Combination animation styles */
        @keyframes combinationGlow {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                           inset 0 0 10px rgba(255, 215, 0, 0.2);
            }
            25% {
                transform: scale(1.1);
                box-shadow: 0 0 30px rgba(255, 100, 255, 0.8),
                           inset 0 0 20px rgba(255, 100, 255, 0.4);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 40px rgba(100, 200, 255, 1),
                           inset 0 0 30px rgba(100, 200, 255, 0.6);
            }
            75% {
                transform: scale(1.1);
                box-shadow: 0 0 30px rgba(255, 100, 255, 0.8),
                           inset 0 0 20px rgba(255, 100, 255, 0.4);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                           inset 0 0 10px rgba(255, 215, 0, 0.2);
            }
        }
        
        .element-slot.combining {
            animation: combinationGlow 0.6s ease-in-out;
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 100, 255, 0.3) 0%,
                rgba(100, 200, 255, 0.2) 100%
            );
        }
        
        @keyframes elementMerge {
            0% {
                opacity: 1;
                transform: scale(1) translateX(0);
            }
            50% {
                opacity: 0.8;
                transform: scale(0.8) translateX(-10px);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translateX(-20px);
            }
        }
        
        .element-slot.merging {
            animation: elementMerge 0.5s ease-out forwards;
        }
        
        @keyframes newElementAppear {
            0% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(360deg);
            }
        }
        
        .element-slot.new-element {
            animation: newElementAppear 0.6s ease-out;
        }
        
        /* Particle effect container */
        .combination-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Screen flash effect for combinations */
        @keyframes combinationFlash {
            0% {
                opacity: 0;
            }
            20% {
                opacity: 0.3;
            }
            100% {
                opacity: 0;
            }
        }
        
        .combination-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.2), rgba(100, 200, 255, 0.1));
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            animation: combinationFlash 0.5s ease-out;
        }
        
        @keyframes particleFly {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(calc(-50% + var(--tx) * 2), calc(-50% + var(--ty) * 2)) scale(0.5);
            }
        }
        
        .combination-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(255, 215, 0, 1) 0%, rgba(255, 100, 255, 0) 70%);
            border-radius: 50%;
            animation: particleFly 0.6s ease-out forwards;
        }
        
        .element-slot.highlighted-element {
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                       inset 0 0 10px rgba(255, 215, 0, 0.2);
            animation: tailPulse 2s ease-in-out infinite;
        }
        
        .element-slot:hover:not(.empty) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4),
                       inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .element-slot .emoji {
            font-size: 28px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }
        
        .element-slot .element-name {
            font-size: 9px;
            color: #AAA;
            text-align: center;
            margin-top: 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Boost Bar (Mana Bar Style) */
        .boost-bar-container {
            width: 60%;
            max-width: 800px;
            margin: 0 auto 15px;
            padding: 0 20px;
        }
        
        .boost-bar-frame {
            height: 24px;
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8) 0%,
                rgba(10, 10, 20, 0.9) 100%
            );
            border: 2px solid rgba(100, 100, 120, 0.5);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.8);
        }
        
        .boost-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, 
                #00a8ff 0%,
                #00d4ff 50%,
                #00a8ff 100%
            );
            background-size: 200% 100%;
            position: relative;
            animation: boostShimmer 3s linear infinite;
        }
        
        @keyframes boostShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .boost-bar-fill.low {
            background: linear-gradient(90deg, #ff4444, #ff6666);
            animation: none;
        }
        
        .boost-bar-fill.boosting {
            background: linear-gradient(90deg, #44ff44, #66ff66);
            animation: boostShimmer 1s linear infinite;
        }
        
        .boost-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            color: white;
        }
        
        #elementQueue {
            display: none; /* Hidden - replaced by bottom element bar */
        }
        
        .element-square {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            padding: 2px;
        }
        
        .element-square .element-name {
            font-size: 7px;
            color: #AAA;
            text-align: center;
            margin-top: 2px;
            line-height: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 46px;
        }
        
        .element-square.empty {
            background: rgba(255,255,255,0.05);
            border: 1px dashed rgba(255,255,255,0.1);
        }
        
        .element-square.filled {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .element-square.tail-element {
            border: 2px solid #FFD700;
            background: rgba(255,215,0,0.1);
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
            animation: tailGlow 2s ease-in-out infinite;
        }
        
        @keyframes tailGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255,215,0,0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(255,215,0,0.8);
            }
        }
        
        .element-square:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        /* Message Popups (Over Element Bar) */
        #recentDiscovery {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.95) 0%,
                rgba(255, 140, 0, 0.95) 100%
            );
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 3px solid #FFD700;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 
                       inset 0 0 20px rgba(255, 255, 255, 0.2);
            opacity: 0;
            transition: all 0.5s;
            animation: none;
            z-index: 25;
        }
        
        #recentDiscovery.show {
            animation: popupBounce 0.5s ease-out;
        }
        
        /* Mobile popup adjustments */
        body.mobile #recentDiscovery {
            bottom: 120px;
            font-size: 14px;
            padding: 10px 20px;
            max-width: 80%;
        }
        
        @keyframes popupBounce {
            0% {
                transform: translateX(-50%) scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) scale(1.1) rotate(5deg);
            }
            100% {
                transform: translateX(-50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        #recentDiscovery.combo {
            background: linear-gradient(135deg, 
                rgba(78, 205, 196, 0.95) 0%,
                rgba(69, 183, 170, 0.95) 100%
            );
            border-color: #4ecdc4;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.8), 
                       inset 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        #recentDiscovery small {
            display: block;
            margin-top: 5px;
            font-size: 14px;
            font-weight: normal;
            font-style: italic;
            opacity: 0.9;
        }
        
        /* Player Info Box (Bottom Left) */
        .player-info-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 280px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 30, 50, 0.9) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 10px;
            padding: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .player-info-header {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .player-portrait {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, 
                rgba(40, 40, 60, 0.9) 0%,
                rgba(50, 50, 70, 0.8) 100%
            );
            border: 2px solid #FFD700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .player-portrait img {
            width: 56px;
            height: 56px;
            image-rendering: pixelated;
        }
        
        .player-stats {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
        }
        
        .stat-line {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        
        .stat-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }
        
        /* Leaderboard (Bottom Right) */
        .leaderboard-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 30, 50, 0.9) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 10px;
            padding: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .leaderboard-header {
            font-size: 16px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .leaderboard-entry:hover {
            background: rgba(138, 43, 226, 0.2);
            transform: translateX(4px);
        }
        
        .leaderboard-entry.leader {
            background: linear-gradient(90deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            border-left: 3px solid #FFD700;
        }
        
        .leaderboard-entry.player {
            background: linear-gradient(90deg, 
                rgba(78, 205, 196, 0.2) 0%,
                rgba(78, 205, 196, 0.1) 100%
            );
            border-left: 3px solid #4ecdc4;
        }
        
        .leaderboard-name {
            flex: 1;
            font-weight: bold;
        }
        
        .leaderboard-stats {
            text-align: right;
            font-size: 11px;
            color: #AAA;
        }
        
        /* Discovery Feed (Left Side Chat-style) */
        .discovery-feed {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 300px;
            max-height: 30vh;
            pointer-events: none;
            display: flex !important;
            flex-direction: column;
            justify-content: flex-end;
            overflow: hidden;
            z-index: 50;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* Force discovery feed to be visible */
        #gameContainer .discovery-feed {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        .discovery-feed-inner {
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(138, 43, 226, 0.3) transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar {
            width: 4px;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.3);
            border-radius: 2px;
        }
        
        .discovery-message {
            background: linear-gradient(90deg, 
                rgba(20, 20, 40, 0.8) 0%,
                rgba(20, 20, 40, 0.4) 80%,
                transparent 100%
            );
            border-left: 3px solid #FFD700;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 0 8px 8px 0;
            font-size: 14px;
            animation: slideInLeft 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .discovery-message .emoji {
            font-size: 20px;
        }
        
        .discovery-message .discovery-text {
            flex: 1;
        }
        
        .discovery-message .discovery-name {
            color: #FFD700;
            font-weight: bold;
        }
        
        .discovery-message .discovery-combo {
            font-size: 12px;
            color: #AAA;
            margin-top: 2px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 50;
        }
        
        body.mobile .mobile-controls {
            display: block;
        }
        
        .virtual-joystick {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            transition: none;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
        }
        
        .boost-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(78, 205, 196, 0.3);
            border: 3px solid #4ecdc4;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .boost-button.active {
            background: rgba(78, 205, 196, 0.6);
            transform: scale(0.95);
        }
        
        .pause-button-mobile {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .mute-button-mobile {
            position: absolute;
            top: 20px;
            right: 80px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Alchemy Vision Timer */
        .alchemy-vision-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.2) 100%);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            z-index: 100;
        }
        
        /* Mobile UI Inversions */
        body.mobile .bottom-ui {
            top: 0;
            bottom: auto;
            padding-bottom: 20px;
            padding-top: 20px;
            border-top: none;
            border-bottom: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.2);
            background: linear-gradient(to top, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.7) 10%,
                rgba(10, 10, 26, 0.95) 30%,
                rgba(10, 10, 26, 0.98) 100%
            );
        }
        
        body.mobile .player-info-box {
            display: none; /* Hide entirely on mobile */
        }
        
        /* Alchemy Vision Timer on Mobile - Bottom Center */
        body.mobile .alchemy-vision-timer {
            top: auto;
            bottom: 80px; /* Above boost bar */
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            font-size: 16px;
            padding: 8px;
        }
        
        body.mobile .leaderboard-box {
            top: 100px;
            bottom: auto;
            right: 10px;
            width: 180px;
            background: rgba(20, 20, 40, 0.6);
            padding: 8px;
            font-size: 11px;
        }
        
        body.mobile .leaderboard-header {
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        body.mobile .leaderboard-entry {
            padding: 4px 6px;
            margin: 2px 0;
            font-size: 11px;
        }
        
        body.mobile .leaderboard-stats {
            font-size: 9px;
        }
        
        body.mobile .discovery-feed {
            top: 50%;
            transform: translateY(-50%);
        }
        
        body.mobile .message-popup {
            top: auto;
            bottom: 220px;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            border-width: 2px;
        }
        
        body.mobile #pauseText,
        body.mobile #fpsCounter {
            top: 170px;
        }
        
        /* Touch-specific optimizations */
        body.mobile {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body.mobile .desktop-only {
            display: none;
        }
        
        /* Mobile splash screen adjustments */
        @media (max-width: 800px) and (orientation: landscape) {
            #splashContent {
                padding: 10px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            #splashLogo {
                width: 150px !important;
                max-width: 150px !important;
                margin-bottom: 5px !important;
            }
            
            #splashScreen p {
                font-size: 11px;
                margin: 5px;
                line-height: 1.3;
                max-height: 80px;
                overflow-y: auto;
            }
            
            #startButton {
                margin-top: 5px;
                margin-bottom: 5px;
                padding: 6px 20px;
                font-size: 14px;
            }
            
            #splashTitle {
                font-size: 24px;
                margin-bottom: 5px;
            }
        }
        
        /* Portrait mobile adjustments */
        @media (max-width: 600px) and (orientation: portrait) {
            #splashScreen img {
                width: 300px !important;
            }
            
            #splashScreen p {
                font-size: 16px;
            }
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .player-info-box,
            .leaderboard-box {
                width: 240px;
                font-size: 12px;
            }
            
            .element-slot {
                width: 48px;
                height: 48px;
            }
            
            .element-slot .emoji {
                font-size: 24px;
            }
            
            .discovery-feed {
                width: 250px;
            }
        }
        
        @media (max-width: 800px) {
            .player-info-box,
            .leaderboard-box {
                bottom: 100px;
                width: 200px;
            }
            
            body.mobile .player-info-box,
            body.mobile .leaderboard-box {
                top: 100px;
            }
            
            .discovery-feed {
                display: none; /* Hide on mobile */
            }
            
            #discoveryLog {
                width: 200px;
                font-size: 12px;
                padding: 15px;
            }
            
            #discoveryLog h3 {
                font-size: 16px;
            }
            
            .element-slot {
                width: 42px;
                height: 42px;
            }
            
            .boost-bar-container {
                width: 80%;
            }
            
            .virtual-joystick {
                width: 100px;
                height: 100px;
                left: 20px;
                bottom: 20px;
            }
            
            .boost-button {
                width: 70px;
                height: 70px;
                right: 20px;
                bottom: 20px;
                font-size: 14px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        /* Victory Overlay */
        #victoryOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #victoryPopup {
            position: relative;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.98) 0%,
                rgba(40, 20, 60, 0.98) 100%
            );
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            border: 3px solid #FFD700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5),
                       inset 0 0 30px rgba(255, 215, 0, 0.1);
            animation: victoryPulse 2s ease-in-out infinite;
        }
        
        @keyframes victoryPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 50px rgba(255, 215, 0, 0.5),
                           inset 0 0 30px rgba(255, 215, 0, 0.1);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 80px rgba(255, 215, 0, 0.7),
                           inset 0 0 40px rgba(255, 215, 0, 0.2);
            }
        }
        
        .victory-glow {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, 
                rgba(255, 215, 0, 0.2) 0%,
                transparent 70%
            );
            animation: rotate 20s linear infinite;
            pointer-events: none;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .victory-title {
            font-size: 48px;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: victoryShine 2s ease-in-out infinite;
        }
        
        @keyframes victoryShine {
            0%, 100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { text-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }
        
        .victory-lore {
            font-size: 20px;
            color: #DDD;
            margin: 20px 0 30px;
            line-height: 1.6;
            font-style: italic;
        }
        
        .victory-stats {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 30px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #AAA;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .victory-button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
        }
        
        .victory-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(255, 215, 0, 0.5);
        }
        
        /* Mobile adjustments for victory popup */
        @media (max-width: 600px) {
            #victoryPopup {
                padding: 30px;
            }
            
            .victory-title {
                font-size: 36px;
            }
            
            .victory-lore {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 14px;
            }
            
            .stat-value {
                font-size: 20px;
            }
        }
        
        /* Pause Menu */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #pauseMenu {
            background: rgba(20,20,40,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: 900px;
            height: 700px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid rgba(138, 43, 226, 0.3);
            padding-bottom: 10px;
        }
        
        .tab-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 10px 10px 0 0;
            color: #AAA;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .tab-button:hover {
            background: rgba(138, 43, 226, 0.2);
            color: white;
        }
        
        .tab-button.active {
            background: rgba(138, 43, 226, 0.4);
            color: #FFD700;
            border-bottom: 2px solid #FFD700;
            transform: translateY(2px);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Discovery Journal */
        #discoveryJournal {
            padding: 20px;
            padding-right: 15px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            flex: 1;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        
        .discovery-grid {
            display: grid;
            grid-template-columns: repeat(8, minmax(90px, 1fr));
            gap: 10px;
            margin-top: 20px;
            flex: 1;
            padding-right: 15px;
            box-sizing: border-box;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
            max-width: 100%;
            min-height: 0;
        }
        
        /* Custom scrollbar for discovery grid */
        .discovery-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .discovery-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .discovery-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 4px;
        }
        
        .discovery-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.7);
        }
        
        .discovery-item {
            background: rgba(40, 40, 60, 0.6);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 5px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .discovery-item:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }
        
        
        .discovery-item .element-symbol {
            font-size: 20px;
            margin-bottom: 3px;
        }
        
        .discovery-item .element-name {
            font-size: 10px;
            color: #FFD700;
            word-break: break-word;
            line-height: 1.2;
        }
        
        
        /* How to Play Section */
        .howToPlay {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            color: #CCC;
            line-height: 1.6;
        }
        
        .howToPlay h5 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .howToPlay ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .howToPlay li {
            margin-bottom: 5px;
        }
        
        .howToPlay strong {
            color: #FFD700;
        }
        
        /* Skin Selection */
        #skinSelection {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        #skinSelection h4 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #availableUnlocks {
            text-align: center;
            color: #4ecdc4;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        #skinGrid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex: 1;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 10px;
        }
        
        .skin-item {
            position: relative;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .skin-item:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .skin-item.current {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .skin-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .skin-item.locked:hover {
            transform: none;
        }
        
        .skin-item.unlockable {
            border-color: #4ecdc4;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #4ecdc4; }
            50% { box-shadow: 0 0 20px #4ecdc4, 0 0 30px #4ecdc4; }
        }
        
        .skin-image {
            width: 100%;
            height: 100%;
            max-width: 60px;
            max-height: 60px;
            margin: 0 auto 3px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            object-fit: contain;
        }
        
        .skin-name {
            font-size: 10px;
            color: #CCC;
            margin-top: 3px;
            line-height: 1.2;
        }
        
        .skin-unlock-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }
    </style>
    <!-- New Element System Scripts -->
    <script src="elements/game-loader.js"></script>
    <script src="elements/element-loader.js"></script>
    <script src="elements/compatibility-layer.js"></script>
    <script src="elements/dynamic-prefix-system.js"></script>
    <script src="elements/integrate.js"></script>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen">
        <canvas id="splashStarsCanvas"></canvas>
        <div id="splashContent">
            <img src="assets/word-logo.webp" alt="Infinite Snake" id="splashLogo" style="width: 400px; max-width: 80%; margin-bottom: 30px;" onerror="this.style.display='none'; document.getElementById('splashTitle').style.display='block';">
            <h1 id="splashTitle">Infinite Snake</h1>
            <p>Reality has shattered. The elements of creation are scattered across the void.<br><br>
            You are the Infinite Snake - an ancient being born from chaos. Consume these fragments. Combine them within your endless serpentine coils. Forge new existence.<br><br>
            From fire and water to stars and civilizations, rebuild the Cosmos itself. The universe awaits.</p>
            <button id="startButton">Begin Your Journey</button>
        </div>
    </div>
    
    <!-- Game Mode Selection -->
    <div id="gameModeSelect">
        <canvas id="gameModeStarsCanvas"></canvas>
        <div id="gameModeContent">
            <h3>Game Setup</h3>
        
        <div class="modeSection">
            <h4>Victory Condition</h4>
            <div id="victoryButtons">
                <div class="victory-column">
                    <h5>🧪 Discovery Race</h5>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 100)">Discover 100 Elements</button>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 500)">Discover 500 Elements</button>
                </div>
                <div class="victory-column">
                    <h5>⭐ Points Race</h5>
                    <button class="btn-points" onclick="selectVictoryMode('points', 50000)">Score 50,000 Points</button>
                    <button class="btn-points" onclick="selectVictoryMode('points', 250000)">Score 250,000 Points</button>
                </div>
                <div class="victory-infinite">
                    <button class="btn-infinite" onclick="selectVictoryMode('infinite', 0)">∞ Infinite Mode</button>
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <!-- Discovery Sidebar -->
    <div id="discoveryLog">
        <h3>Discoveries (0)</h3>
        <div id="discoveryList"></div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div id="recentDiscovery"></div>
        <div id="score">Score: 0</div>
        <div id="discoveries">Discoveries: 0</div>
        <div id="elementQueue"></div>
        
        <!-- Discovery Feed (Left Side) -->
        <div class="discovery-feed">
            <div class="discovery-feed-inner" id="discoveryFeed"></div>
        </div>
        
        <!-- Bottom UI Container -->
        <div class="bottom-ui">
            <!-- Element Collection Bar -->
            <div class="element-collection-bar" id="elementBar"></div>
            
            <!-- Boost Bar -->
            <div class="boost-bar-container">
                <div class="boost-bar-frame">
                    <div class="boost-bar-fill" id="boostBarFill" style="width: 100%"></div>
                    <div class="boost-bar-text">BOOST</div>
                </div>
            </div>
        </div>
        
        <!-- Alchemy Vision Timer -->
        <div id="alchemyVisionTimer" class="alchemy-vision-timer" style="display: none;">
            🔮 Alchemy Vision: <span id="alchemyTime">60</span>s
        </div>
        
        <!-- Player Info Box -->
        <div class="player-info-box">
            <div class="player-info-header">
                <div class="player-portrait">
                    <img id="playerPortrait" src="skins/snake-default-green.png" alt="Player">
                </div>
                <div class="player-stats">
                    <div class="stat-line">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="playerScore">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Discoveries</span>
                        <span class="stat-value" id="playerDiscoveries">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Best Rank</span>
                        <span class="stat-value" id="playerBestRank">-</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Kills</span>
                        <span class="stat-value" id="playerKills">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Time</span>
                        <span class="stat-value" id="playerTime">0:00</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Leaderboard Box -->
        <div class="leaderboard-box">
            <div class="leaderboard-header">Leaderboard</div>
            <div id="leaderboardList"></div>
        </div>
        
        <!-- UI Info (Top Right) -->
        <div id="pauseText" style="position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; color: rgba(255, 255, 255, 0.4); pointer-events: none;">
            <div style="margin-bottom: 5px;" class="desktop-only">Press P for Pause Menu</div>
            <div style="margin-bottom: 5px;" class="desktop-only" id="muteText">M to Mute</div>
            <div id="fpsCounter">FPS: --</div>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="virtual-joystick" id="virtualJoystick">
            <div class="joystick-base">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
        <div class="boost-button" id="boostButton">BOOST</div>
        <div class="pause-button-mobile" id="pauseButtonMobile" onclick="togglePause()">⏸</div>
        <div class="mute-button-mobile" id="muteButtonMobile" onclick="toggleMusic()">🔇</div>
    </div>
    
    <!-- Victory Overlay -->
    <div id="victoryOverlay" style="display: none;">
        <div id="victoryPopup">
            <div class="victory-glow"></div>
            <h1 class="victory-title">🏆 Victory! 🏆</h1>
            <div class="victory-lore" id="victoryLore"></div>
            <div class="victory-stats">
                <div class="stat-item">
                    <span class="stat-label">Final Score</span>
                    <span class="stat-value" id="victoryScore">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Elements Discovered</span>
                    <span class="stat-value" id="victoryDiscoveries">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time to Complete</span>
                    <span class="stat-value" id="victoryTime">0:00</span>
                </div>
            </div>
            <button class="victory-button" onclick="location.reload()">Play Again</button>
        </div>
    </div>
    
    <!-- Respawn Overlay -->
    <div id="respawnOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 60; pointer-events: none;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
            <div style="background: linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(30, 30, 50, 0.9) 100%); 
                        border: 2px solid rgba(255, 68, 68, 0.5); 
                        border-radius: 15px; 
                        padding: 30px 40px;
                        box-shadow: 0 0 30px rgba(255, 68, 68, 0.3);">
                <h2 style="color: #ff4444; margin: 0 0 20px 0; font-size: 32px; text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);">Your Form Dissolves Into The Void!</h2>
                
                <!-- Stats Summary -->
                <div style="margin-bottom: 25px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px;">
                        <div style="color: #AAA; font-size: 14px;">Score</div>
                        <div id="respawnScore" style="color: #4ecdc4; font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px;">
                        <div style="color: #AAA; font-size: 14px;">Discoveries</div>
                        <div id="respawnDiscoveries" style="color: #FFD700; font-size: 24px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px;">
                        <div style="color: #AAA; font-size: 14px;">Best Rank</div>
                        <div id="respawnRank" style="color: #9c88ff; font-size: 24px; font-weight: bold;">#1</div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 8px;">
                        <div style="color: #AAA; font-size: 14px;">Kills</div>
                        <div id="respawnKills" style="color: #ff6b6b; font-size: 24px; font-weight: bold;">0</div>
                    </div>
                </div>
                
                <!-- Respawn Timer -->
                <div style="font-size: 28px; color: #ff4444; font-weight: bold;">
                    Respawn in <span id="respawnTimer">3</span>s
                </div>
                
                <div style="margin-top: 15px; font-size: 14px; color: #AAA;">
                    You will keep 75% of your score
                </div>
            </div>
        </div>
    </div>
    
    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <p style="color: #AAA; font-size: 14px; margin: 10px 0;">High Score: <span style="color: #FFD700;" id="highScoreDisplay">0</span></p>
            
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('skins')">Skins</button>
                <button class="tab-button" onclick="switchTab('journal')">Discovery Journal</button>
                <button class="tab-button" onclick="switchTab('howto')">How to Play</button>
            </div>
            
            <!-- Skins Tab -->
            <div id="skinsTab" class="tab-content active">
                <div id="skinSelection">
                    <h4>Snake Skins</h4>
                    <div id="availableUnlocks">Available Unlocks: 0</div>
                    <div id="skinGrid"></div>
                </div>
            </div>
            
            <!-- Discovery Journal Tab -->
            <div id="journalTab" class="tab-content">
                <div id="discoveryJournal">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">Discovery Journal</h4>
                    <div class="discovery-grid" id="discoveryGrid">
                        <!-- Discoveries will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- How to Play Tab -->
            <div id="howtoTab" class="tab-content">
                <div style="padding: 20px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #FFD700; margin-bottom: 15px; text-align: center;">How to Play Infinite Snake</h4>
                    
                    <div style="color: #ddd; font-size: 14px; line-height: 1.6;">
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🎮 Controls</h5>
                            <p><strong>Desktop:</strong> Mouse to steer OR Arrow keys/WASD</p>
                            <p><strong>Arrow Keys:</strong> Left/Right to turn, Up to boost</p>
                            <p><strong>WASD:</strong> A/D to turn, W to boost</p>
                            <p><strong>Mobile:</strong> Virtual joystick to steer</p>
                            <p><strong>Boost:</strong> Click/W/Up Arrow (Desktop) or Boost button (Mobile)</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🎯 Goal</h5>
                            <p>Grow your snake by collecting elements and discovering new combinations! Compete with other snakes for the highest score and unlock new skins.</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🔬 Element System</h5>
                            <p>• Collect basic elements: Fire 🔥, Water 💧, Earth 🏔️, Air 💨</p>
                            <p>• Your snake can hold up to 6 elements</p>
                            <p>• Elements automatically combine when compatible!</p>
                            <p>• Example: Fire + Water = Steam ☁️</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">✨ Power-ups</h5>
                            <p><strong>🔮 Alchemy Vision:</strong> See all possible combinations for 30 seconds</p>
                            <p><strong>🌀 Void Orb:</strong> Clear your element inventory and convert to points</p>
                            <p><strong>💎 Catalyst Gem:</strong> Summons up to 4 possible compatible elements for combining</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">⚔️ Combat</h5>
                            <p>• Collide head-on with smaller snakes to eliminate them</p>
                            <p>• Collect their dropped elements for points</p>
                            <p>• Avoid head-on collisions with larger snakes!</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🏆 Tips</h5>
                            <p>• Use boost strategically - it drains stamina!</p>
                            <p>• Experiment with different element combinations</p>
                            <p>• Stay away from the map borders!</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(138, 43, 226, 0.3);">
                <button onclick="resumeGame()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #4ecdc4; color: white; border: none; border-radius: 10px; cursor: pointer;">Resume</button>
                <button onclick="location.reload()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer;">New Game</button>
            </div>
        </div>
    </div>
    
    <script>
        // Mobile detection (needs to be before canvas setup)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                        || ('ontouchstart' in window && navigator.maxTouchPoints > 0);
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Emoji cache for performance
        const emojiCache = new Map();
        const MAX_CACHE_SIZE = 200; // Limit cache size
        
        function getCachedEmoji(emoji, size) {
            // Ensure size is valid
            const validSize = Math.max(1, Math.round(size) || 20);
            const key = `${emoji}_${validSize}`;
            
            if (emojiCache.has(key)) {
                return emojiCache.get(key);
            }
            
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const padding = 4; // Small padding for emoji rendering
            offscreenCanvas.width = validSize + padding * 2;
            offscreenCanvas.height = validSize + padding * 2;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            
            // Draw emoji to offscreen canvas
            offscreenCtx.font = `${validSize}px Arial`;
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.fillStyle = 'black';
            offscreenCtx.fillText(emoji, offscreenCanvas.width / 2, offscreenCanvas.height / 2);
            
            // Store in cache
            emojiCache.set(key, offscreenCanvas);
            
            // Clean up old entries if cache is too large
            if (emojiCache.size > MAX_CACHE_SIZE) {
                const firstKey = emojiCache.keys().next().value;
                emojiCache.delete(firstKey);
            }
            
            return offscreenCanvas;
        }
        
        // Make canvas fit full window
        function resizeCanvas() {
            // Use lower resolution on mobile for better performance
            const scale = isMobile ? 0.8 : 1;
            canvas.width = window.innerWidth * scale;
            canvas.height = window.innerHeight * scale;
            
            if (isMobile) {
                // Scale canvas to full size with CSS
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }
            
            // Clear emoji cache on resize as sizes might change
            emojiCache.clear();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game constants
        const WORLD_SIZE = 4000;
        const SEGMENT_SIZE = 15;
        const SNAKE_SPEED = 4.14; // Increased by 35% from original 3.0 (additional 15% boost)
        const TURN_SPEED = 0.08;
        const ELEMENT_SIZE = 20;
        
        // Viewport culling helper
        function isInViewport(x, y, margin = 100) {
            const screenX = x - camera.x + canvas.width / 2;
            const screenY = y - camera.y + canvas.height / 2;
            
            return screenX >= -margin && 
                   screenX <= canvas.width + margin && 
                   screenY >= -margin && 
                   screenY <= canvas.height + margin;
        }
        
        // Game state
        let gameStarted = false;
        let paused = false;
        let controlScheme = 'arrows';
        let gameMode = 'infinite'; // 'discovery', 'points', or 'infinite'
        let gameWon = false; // Track if victory has been achieved
        let gameTarget = 0; // Target value for victory
        let camera = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
        
        // Game loop timing variables
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 0;
        let accumulator = 0;
        let playerSnake = null;
        let snakes = [];
        let lastDiscoveredElement = null;
        let highScore = parseInt(localStorage.getItem('highScore') || '0');
        let gameStartTime = Date.now();
        let bestRank = 0;
        let playerRespawnTimer = 0; // Player respawn countdown
        let comboStreak = 0; // Track consecutive combinations
        let animationFrameId = null; // Track the animation frame to prevent multiple loops
        
        // Alchemy Vision power-up
        let alchemyVisionPowerUps = [];
        let alchemyVisionActive = false;
        let alchemyVisionTimer = 0;
        let lastAlchemyVisionSpawn = 0;
        const ALCHEMY_VISION_DURATION = 30000; // 30 seconds
        const ALCHEMY_VISION_SPAWN_INTERVAL = 120000; // 2 minutes
        const ALCHEMY_VISION_SPAWN_COUNT = 3; // Number of power-ups to spawn at once
        
        // Void Orb mechanic
        let voidOrbs = [];
        let lastVoidOrbSpawn = 0;
        const VOID_ORB_SPAWN_INTERVAL = 75000; // 75 seconds (25% less common)
        const VOID_ORB_SPAWN_COUNT = 4; // Number of void orbs to maintain on map
        
        // Catalyst Gem mechanic
        let catalystGems = [];
        let lastCatalystGemSpawn = 0;
        const CATALYST_GEM_SPAWN_INTERVAL = 45000; // 45 seconds (doubled spawn rate)
        const CATALYST_GEM_SPAWN_COUNT = 3; // Number of catalyst gems to maintain on map
        let catalystSpawnedElements = []; // Track elements spawned by catalyst for visual effect
        
        // AI Personality Types
        const AI_PERSONALITIES = {
            AGGRESSIVE: {
                name: 'Aggressive',
                huntingPriority: 0.95,      // Almost always hunts
                comboPriority: 0.05,        // Rarely cares about combos
                riskTolerance: 0.95,        // Very high risk tolerance
                boostThreshold: 0.2,        // Boosts frequently
                chaseDistance: 500,         // Long chase range
                fleeThreshold: 2.0,         // Only flee if enemy is 2x larger
                collisionAvoidanceRadius: 60, // Small avoidance radius
                aggressionMultiplier: 2.0,  // How much to prioritize hunting
                elementIgnoreChance: 0.7    // 70% chance to ignore elements when hunting
            },
            COMBO_FOCUSED: {
                name: 'Combo Master',
                huntingPriority: 0.05,      // Almost never hunts
                comboPriority: 0.95,        // Always seeks combos
                riskTolerance: 0.2,         // Low risk tolerance
                boostThreshold: 0.7,        // Rarely boosts
                chaseDistance: 50,          // Very short chase range
                fleeThreshold: 0.9,         // Flee from 90% size snakes
                collisionAvoidanceRadius: 150, // Large avoidance radius
                aggressionMultiplier: 0.2,
                elementIgnoreChance: 0.0    // Never ignores elements
            },
            BALANCED: {
                name: 'Balanced',
                huntingPriority: 0.5,
                comboPriority: 0.5,
                riskTolerance: 0.5,
                boostThreshold: 0.5,
                chaseDistance: 250,
                fleeThreshold: 1.3,
                collisionAvoidanceRadius: 100,
                aggressionMultiplier: 1.0,
                elementIgnoreChance: 0.3
            },
            CAUTIOUS: {
                name: 'Cautious',
                huntingPriority: 0.1,       // Rarely hunts
                comboPriority: 0.9,         // Focuses on elements
                riskTolerance: 0.1,         // Very low risk
                boostThreshold: 0.85,       // Almost never boosts
                chaseDistance: 30,          // Tiny chase range
                fleeThreshold: 0.8,         // Flee from 80% size snakes
                collisionAvoidanceRadius: 200, // Huge avoidance radius
                aggressionMultiplier: 0.1,
                elementIgnoreChance: 0.0
            },
            OPPORTUNIST: {
                name: 'Opportunist',
                huntingPriority: 0.8,       // High hunting when safe
                comboPriority: 0.2,
                riskTolerance: 0.6,
                boostThreshold: 0.3,
                chaseDistance: 350,
                fleeThreshold: 1.1,         // Careful about size matchups
                collisionAvoidanceRadius: 80,
                aggressionMultiplier: 1.5,
                elementIgnoreChance: 0.5,
                preferWeakTargets: true     // Specifically targets smaller/wounded snakes
            }
        };
        
        // AI respawn cooldown tracking
        let aiRespawnQueue = [];
        const AI_RESPAWN_COOLDOWN = 5000; // 5 seconds
        const MAX_AI_SNAKES = 6; // Increased from 5 to 6
        
        // Track used AI skins to prevent duplicates
        let usedAISkins = new Set();
        
        // Personality colors for name display
        const PERSONALITY_COLORS = {
            'Aggressive': '#ff4444',      // Red
            'Combo Master': '#44ff44',    // Green
            'Cautious': '#ffff44',        // Yellow
            'Balanced': '#4444ff',        // Blue
            'Opportunist': '#ff8844'      // Orange
        };
        
        // Space effects
        let staticStars = [];
        let shootingStars = [];
        let lastShootingStarTime = 0;
        
        // Nebula border effect variables
        let borderParticles = [];
        let animationTime = 0;
        const MAX_BORDER_PARTICLES = isMobile ? 50 : 150; // Reduced for mobile
        
        // Element database
        let elementDatabase = {};
        let combinations = {};
        let discoveredElements = new Set(); // Start with no discoveries
        
        // All-time discoveries (persistent across sessions)
        let allTimeDiscoveries = new Map(); // Map of element -> recipe
        
        // Snake names data
        let snakeNameData = null;
        
        // Skin system
        const skinMetadata = {
            'snake-default-green': { name: 'Basic Boy', unlocked: true, colors: ['#75d18e', '#6abf81'] },
            'neko': { name: 'Lil Beans (Beta Perk)', unlocked: true, colors: ['#c6c6cb', '#c3c3e7'] },
            '35mm': { name: 'Ansel 35', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'Frank': { name: 'Franklin', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'af-one': { name: "Scuffy", unlocked: false, colors: ['#e74c3c', '#e23b28'] },
            'barbi': { name: 'Margot', unlocked: false, colors: ['#ff69b4', '#ff1493'] },
            'boat-mcboatface': { name: 'Boaty McBoatface', unlocked: false, colors: ['#3498db', '#2980b9'] },
            'camera-guy': { name: 'The Resistance', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'coffee': { name: 'Caffeine Fiend', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'controller': { name: 'Little Bro', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'diet-cola': { name: 'Cola Crusader', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'dog': { name: 'Good Boy', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'donut': { name: 'Sprinkles', unlocked: false, colors: ['#daa520', '#ff69b4'] },
            'flame': { name: 'Hot Head', unlocked: false, colors: ['#ff8c00', '#ffd700'] },
            'football': { name: 'MVP', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'fries': { name: 'Sir Dips-a-lot', unlocked: false, colors: ['#e74c3c', '#ffd700'] },
            'green-dragon': { name: 'World Muncher', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'handheld-game': { name: 'The Pocketeer', unlocked: false, colors: ['#393b32', '#6a7473'] },
            'hotdog': { name: 'Big Dawg', unlocked: false, colors: ['#f8c83f', '#f8c83f'] },
            'infinity-glove': { name: 'Snappy', unlocked: false, colors: ['#6c7dcd', '#6c7dcd'] },
            'kid-car': { name: 'Speed Demon Jr.', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'lovecraft': { name: 'Eldritch Horror', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'nyan': { name: 'Pastry Cat', unlocked: false, colors: ['#e74c3c', '#ff8c00', '#ffd700', '#2ecc71', '#3498db', '#9b59b6'] },
            'pizza': { name: 'Tony Pep', unlocked: false, colors: ['#f5bf48', '#f39c12'] },
            'potato': { name: 'Spud Bud', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'racer': { name: 'Speed Demon', unlocked: false, colors: ['#1f2d35', '#e1e7ea'] },
            'ramen': { name: 'Noodle Master', unlocked: false, colors: ['#f3c33e', '#f3c33e'] },
            'red-dragon': { name: 'Ralph', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'robot': { name: 'Metal Boi', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'santa': { name: 'Ho Ho Hose', unlocked: false, colors: ['#e34c4a', '#f2ede1'] },
            'saturn': { name: 'Ring Leader', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'skibidi': { name: 'Mr. Swirley', unlocked: false, colors: ['#ecf0f1', '#bdc3c7'] },
            'snake-2': { name: 'Snek II', unlocked: false, colors: ['#78a060', '#5f804c'] },
            'space-cadet': { name: 'Cosmic Ray', unlocked: false, colors: ['#34495e', '#2c3e50'] },
            'tornado': { name: 'Whirlwind', unlocked: false, colors: ['#1790ff', '#3b9cf6'] },
            'tv': { name: 'CRT Surfer', unlocked: false, colors: ['#89b6c7', '#bedeeb'] },
            'unicorn': { name: 'Tres Commas', unlocked: false, colors: ['#ff69b4', '#ffd700'] },
            'brick-man': { name: 'The Special', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'buffalo': { name: "Billy Blue", unlocked: false, colors: ['#3498db', '#2980b9'] },
            'clock': { name: 'Time-Out', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'floral': { name: 'Bo Kay', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'gnome': { name: 'World Traveler', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'mac': { name: 'Woz', unlocked: false, colors: ['#f5deb3', '#e6d7c3'] },
            'murica': { name: "'Murica", unlocked: false, colors: ['#ecf0f1', '#f2eeed'] },
            'pod-player': { name: 'Poddington', unlocked: false, colors: ['#87ceeb', '#5f9ea0'] },
            'whale': { name: 'Spout', unlocked: false, colors: ['#3498db', '#2980b9'] }
        };
        
        const aiSkins = Object.keys(skinMetadata); // All skins available for AI
        let currentPlayerSkin = 'snake-default-green';
        let unlockedSkins = new Set(['snake-default-green']);
        let availableUnlocks = 0;
        let skinImages = {}; // Cache for loaded skin images
        
        // Load skin system from localStorage
        function loadSkinData() {
            const saved = localStorage.getItem('unlockedSkins');
            if (saved) {
                unlockedSkins = new Set(JSON.parse(saved));
            }
            
            const savedCurrent = localStorage.getItem('currentSkin');
            if (savedCurrent && unlockedSkins.has(savedCurrent)) {
                currentPlayerSkin = savedCurrent;
                // Update player portrait on load
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${currentPlayerSkin}.png`;
                }
            }
            
            // Update metadata
            for (const skin of unlockedSkins) {
                if (skinMetadata[skin]) {
                    skinMetadata[skin].unlocked = true;
                }
            }
        }
        
        // Save skin data
        function saveSkinData() {
            localStorage.setItem('unlockedSkins', JSON.stringify(Array.from(unlockedSkins)));
            localStorage.setItem('currentSkin', currentPlayerSkin);
        }
        
        // Preload skin images
        function preloadSkins() {
            const allSkins = Object.keys(skinMetadata).concat(aiSkins);
            allSkins.forEach(skin => {
                const img = new Image();
                img.onerror = function() {
                    console.warn(`Failed to load skin: ${skin}.png`);
                    this.error = true;
                };
                img.src = `skins/${skin}.png`;
                skinImages[skin] = img;
            });
        }
        
        // Calculate available unlocks based on high score
        function calculateAvailableUnlocks() {
            let unlocks = 0;
            if (highScore >= 50000) unlocks++;
            if (highScore >= 100000) unlocks++;
            if (highScore >= 150000) unlocks++;
            if (highScore > 150000) {
                unlocks += Math.floor((highScore - 150000) / 250000);
            }
            
            // Subtract already unlocked skins (minus the default)
            const alreadyUnlocked = unlockedSkins.size - 1;
            availableUnlocks = Math.max(0, unlocks - alreadyUnlocked);
            return availableUnlocks;
        }
        
        // Load all-time discoveries from localStorage
        function loadAllTimeDiscoveries() {
            const saved = localStorage.getItem('allTimeDiscoveries');
            if (saved) {
                const data = JSON.parse(saved);
                allTimeDiscoveries = new Map(data);
            } else {
                // Initialize with base elements
                allTimeDiscoveries.set('fire', 'Base Element');
                allTimeDiscoveries.set('water', 'Base Element');
                allTimeDiscoveries.set('earth', 'Base Element');
                allTimeDiscoveries.set('air', 'Base Element');
                saveAllTimeDiscoveries();
            }
        }
        
        // Save all-time discoveries to localStorage
        function saveAllTimeDiscoveries() {
            const data = Array.from(allTimeDiscoveries.entries());
            localStorage.setItem('allTimeDiscoveries', JSON.stringify(data));
        }
        
        // Music system
        // Background music tracks - see CREDITS.md for full attribution
        // All tracks produced by ZapSplat under Standard License
        let currentTrack = null;
        let musicVolume = 0.3;
        let musicMuted = false;
        const musicTracks = [
            'bright-white-lights.mp3',
            'last-ones-standing.mp3', 
            'good-times.mp3',
            'summer-haze.mp3',
            'on-the-up.mp3',
            'headliner.mp3'
        ];
        let availableTracks = [];
        
        
        // Input handling
        const keys = {};
        let mouseAngle = 0;
        let mouseDown = false;
        let mouseMovedRecently = false;
        let mouseMovedTimer = null;
        
        // Combination animation state
        let combinationAnimationState = {
            isAnimating: false,
            combiningIndices: [],
            animationStartTime: 0,
            newElementIndex: -1
        };
        
        // Mobile detection removed - using global definition
        
        // Mobile controls state
        let joystickActive = false;
        let joystickBase = { x: 0, y: 0 };
        let joystickKnob = { x: 0, y: 0 };
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleMusic();
            }
            
            // Resume pending music on first interaction
            if (window.pendingMusicTrack && !musicMuted) {
                window.pendingMusicTrack.play().then(() => {
                    console.log('Music resumed after user interaction');
                }).catch(err => {
                    console.error('Failed to resume music:', err);
                });
                window.pendingMusicTrack = null;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        window.addEventListener('mousemove', (e) => {
            if (controlScheme === 'mouse' && playerSnake) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
                
                // Track that mouse has moved recently
                mouseMovedRecently = true;
                
                // Clear existing timer
                if (mouseMovedTimer) {
                    clearTimeout(mouseMovedTimer);
                }
                
                // Set timer to reset mouseMovedRecently after inactivity
                mouseMovedTimer = setTimeout(() => {
                    mouseMovedRecently = false;
                }, 1000); // Reset after 1 second of no mouse movement
            }
        });
        
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = true;
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = false;
            }
        });
        
        // Splash screen
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        // Game mode selection
        function selectVictoryMode(mode, target) {
            gameMode = mode;
            gameTarget = target;
            
            // Set default control scheme to mouse
            controlScheme = 'mouse';
            
            // Start the game immediately
            startGameTransition();
        }
        
        function startGameTransition() {
            // Create fade transition
            const gameModeSelect = document.getElementById('gameModeSelect');
            const discoveryLog = document.getElementById('discoveryLog');
            const gameCanvas = document.getElementById('gameCanvas');
            const gameModeStarsCanvas = document.getElementById('gameModeStarsCanvas');
            
            // Add transition styles
            gameModeSelect.style.transition = 'opacity 0.8s ease-out';
            gameCanvas.style.transition = 'opacity 0.8s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Create a temporary background during transition
            const transitionBg = document.createElement('div');
            transitionBg.style.position = 'fixed';
            transitionBg.style.top = '0';
            transitionBg.style.left = '0';
            transitionBg.style.width = '100%';
            transitionBg.style.height = '100%';
            transitionBg.style.background = '#000';
            transitionBg.style.zIndex = '40';
            transitionBg.appendChild(gameModeStarsCanvas.cloneNode(true));
            transitionBg.style.transition = 'opacity 1s ease-out';
            document.body.appendChild(transitionBg);
            
            // Fade out menu content but keep stars visible
            const menuContent = gameModeSelect.querySelector('#gameModeContent');
            menuContent.style.transition = 'opacity 0.5s ease-out';
            menuContent.style.opacity = '0';
            
            setTimeout(() => {
                gameModeSelect.style.opacity = '0';
                // Discovery feed is always visible during gameplay
                gameCanvas.style.opacity = '1';
                
                setTimeout(() => {
                    gameModeSelect.style.display = 'none';
                    transitionBg.style.opacity = '0';
                    
                    setTimeout(() => {
                        transitionBg.remove();
                        stopGame(); // Ensure clean state before starting
                        startGame();
                    }, 1000);
                }, 100);
            }, 500);
        }
        
        function selectControls(scheme) {
            controlScheme = scheme;
            
            // Create fade transition
            const gameModeSelect = document.getElementById('gameModeSelect');
            const discoveryLog = document.getElementById('discoveryLog');
            const gameCanvas = document.getElementById('gameCanvas');
            const gameModeStarsCanvas = document.getElementById('gameModeStarsCanvas');
            
            // Add transition styles
            gameModeSelect.style.transition = 'opacity 0.8s ease-out';
            gameCanvas.style.transition = 'opacity 0.8s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Create a temporary background during transition
            const transitionBg = document.createElement('div');
            transitionBg.style.position = 'fixed';
            transitionBg.style.top = '0';
            transitionBg.style.left = '0';
            transitionBg.style.width = '100%';
            transitionBg.style.height = '100%';
            transitionBg.style.background = '#000';
            transitionBg.style.zIndex = '40';
            transitionBg.appendChild(gameModeStarsCanvas.cloneNode(true));
            transitionBg.style.transition = 'opacity 1s ease-out';
            document.body.appendChild(transitionBg);
            
            // Fade out menu content but keep stars visible
            const menuContent = gameModeSelect.querySelector('#gameModeContent');
            if (menuContent) {
                menuContent.style.transition = 'opacity 0.4s ease-out';
                menuContent.style.opacity = '0';
            }
            
            // After content fades, start the game
            setTimeout(() => {
                gameModeSelect.style.display = 'none';
                // Discovery feed is always visible during gameplay
                startGame();
                
                // Fade in game canvas and fade out transition background
                setTimeout(() => {
                    gameCanvas.style.opacity = '1';
                    transitionBg.style.opacity = '0';
                    
                    // Remove transition background after fade
                    setTimeout(() => {
                        transitionBg.remove();
                    }, 1000);
                }, 100);
            }, 400);
        }
        
        // Load snake names
        async function loadSnakeNames() {
            try {
                const response = await fetch('snake-names.json');
                const data = await response.json();
                snakeNameData = data;
                console.log('Loaded snake names data');
            } catch (error) {
                console.error('Failed to load snake names:', error);
                // Fallback data
                snakeNameData = {
                    firstParts: ['Sir', 'Lord', 'Captain', 'Master', 'Swift', 'Mighty', 'Sneaky'],
                    secondParts: ['Slithers', 'McSlitherface', 'the Magnificent', 'Noodle', 'Supreme']
                };
            }
        }
        
        // Generate random snake name
        function generateSnakeName() {
            if (!snakeNameData) {
                return `Snake${Math.floor(Math.random() * 1000)}`;
            }
            const first = snakeNameData.firstParts[Math.floor(Math.random() * snakeNameData.firstParts.length)];
            const second = snakeNameData.secondParts[Math.floor(Math.random() * snakeNameData.secondParts.length)];
            return `${first} ${second}`;
        }
        
        // Load element database
        async function loadElements() {
            try {
                // Wait for the new element system to load
                if (!window.elementLoader || !window.elementCompatibility) {
                    // Wait for elementsLoaded event
                    await new Promise((resolve) => {
                        window.addEventListener('elementsLoaded', resolve, { once: true });
                    });
                }
                
                // Use the compatibility layer to get legacy format
                const legacyData = window.elementCompatibility.legacyCache;
                
                // Update local references
                elementDatabase = legacyData.elements;
                combinations = legacyData.combinations;
                
                console.log(`Loaded ${Object.keys(elementDatabase).length} elements and ${Object.keys(combinations).length} combinations`);
            } catch (error) {
                console.error('Failed to load elements:', error);
                // Fallback to basic elements
                elementDatabase = {
                    fire: { emoji: '🔥', name: 'Fire', tier: 0, base: true },
                    water: { emoji: '💧', name: 'Water', tier: 0, base: true },
                    earth: { emoji: '🌍', name: 'Earth', tier: 0, base: true },
                    air: { emoji: '💨', name: 'Air', tier: 0, base: true }
                };
            }
        }
        
        // Sound effects
        const eatSounds = [];
        const explosionSounds = [];
        let soundIndex = 0;
        
        function initSoundEffects() {
            // Create multiple audio instances for overlapping sounds
            for (let i = 0; i < 5; i++) {
                const eatSound = new Audio('sounds/blip.mp3');
                eatSound.volume = 0.3125; // 31.25% volume (increased by 25%)
                eatSounds.push(eatSound);
                
                const explosionSound = new Audio('sounds/fire-impact.mp3');
                explosionSound.volume = 0.75; // 75% volume
                explosionSounds.push(explosionSound);
            }
        }
        
        function playEatSound() {
            if (!musicMuted && eatSounds.length > 0) {
                // Use round-robin to cycle through sound instances
                const sound = eatSounds[soundIndex % eatSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                sound.volume = 0.25; // Reduced by 50% from 0.5
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Eat sound error:', e.message));
                }
            }
        }
        
        function playExplosionSound(isPlayerInvolved = true) {
            if (!musicMuted && explosionSounds.length > 0) {
                // Use round-robin to cycle through sound instances
                const sound = explosionSounds[soundIndex % explosionSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.75 : 0.1; // 75% for player, 10% for AI only
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Explosion sound error:', e.message));
                }
            }
        }
        
        // Power-up sound pools
        const voidOrbSounds = [];
        const alchemyVisionSounds = [];
        const catalystGemSounds = [];
        const boostSounds = [];
        
        function initPowerUpSounds() {
            // Create multiple instances for overlapping sounds
            for (let i = 0; i < 3; i++) {
                // Void Orb sound
                const voidSound = new Audio('sounds/magic-energy-whoosh.mp3');
                voidSound.volume = 0.6;
                voidOrbSounds.push(voidSound);
                
                // Alchemy Vision sound
                const alchemySound = new Audio('sounds/magma-roar.mp3');
                alchemySound.volume = 0.7;
                alchemyVisionSounds.push(alchemySound);
                
                // Catalyst Gem sound
                const catalystSound = new Audio('sounds/power-surge.mp3');
                catalystSound.volume = 0.6;
                catalystGemSounds.push(catalystSound);
                
                // Boost sound
                const boostSound = new Audio('sounds/whoosh-burst.mp3');
                boostSound.volume = 0.5;
                boostSounds.push(boostSound);
            }
        }
        
        function playVoidOrbSound(isPlayerInvolved = true) {
            if (!musicMuted && voidOrbSounds.length > 0) {
                const sound = voidOrbSounds[soundIndex % voidOrbSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.6 : 0.15; // 60% for player, 15% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Void Orb sound error:', e.message));
                }
            }
        }
        
        function playAlchemyVisionSound(isPlayerInvolved = true) {
            if (!musicMuted && alchemyVisionSounds.length > 0) {
                const sound = alchemyVisionSounds[soundIndex % alchemyVisionSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.7 : 0.2; // 70% for player, 20% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Alchemy Vision sound error:', e.message));
                }
            }
        }
        
        function playCatalystGemSound(isPlayerInvolved = true) {
            if (!musicMuted && catalystGemSounds.length > 0) {
                const sound = catalystGemSounds[soundIndex % catalystGemSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.6 : 0.15; // 60% for player, 15% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Catalyst Gem sound error:', e.message));
                }
            }
        }
        
        function playBoostSound(isPlayerInvolved = true) {
            // Only play sound for player, not AI
            if (!musicMuted && boostSounds.length > 0 && isPlayerInvolved) {
                const sound = boostSounds[soundIndex % boostSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Reduced volume by 25% (from 0.5 to 0.375)
                sound.volume = 0.375;
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Boost sound error:', e.message));
                }
            }
        }
        
        // Combination sound array
        let combinationSounds = [];
        
        function initCombinationSounds() {
            // Use the 8-bit blip sound for combinations
            for (let i = 0; i < 3; i++) {
                const sound = new Audio('sounds/8-bit-blip.mp3');
                sound.volume = 0.5;
                combinationSounds.push(sound);
            }
        }
        
        function playCombinationSound() {
            if (!musicMuted && combinationSounds.length > 0) {
                const sound = combinationSounds[soundIndex % combinationSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                sound.volume = 0.7; // Always play at good volume for player combinations
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Combination sound error:', e.message));
                }
            }
        }
        
        function createCombinationFlash() {
            // Create flash overlay
            const flash = document.createElement('div');
            flash.className = 'combination-flash';
            document.body.appendChild(flash);
            
            // Remove after animation completes
            setTimeout(() => {
                flash.remove();
            }, 500);
        }
        
        // Music functions
        function initMusic() {
            // Check which tracks are available
            checkAvailableTracks().then(() => {
                if (availableTracks.length > 0) {
                    playRandomTrack();
                }
            });
        }
        
        async function checkAvailableTracks() {
            // For now, assume all tracks are available
            availableTracks = [...musicTracks];
            console.log('Available tracks loaded:', availableTracks);
            return true;
        }
        
        let isPlayingNext = false; // Prevent multiple simultaneous calls
        
        function playRandomTrack() {
            // Prevent multiple simultaneous calls
            if (isPlayingNext) {
                console.log('Already playing next track, ignoring call');
                return;
            }
            isPlayingNext = true;
            
            // Refill available tracks if empty
            if (availableTracks.length === 0) {
                console.log('Refilling available tracks...');
                availableTracks = [...musicTracks];
            }
            
            // Stop current track if playing
            if (currentTrack && currentTrack.stopRequested !== true) {
                // Mark that we're stopping this track intentionally
                currentTrack.stopRequested = true;
                // Remove all event listeners to prevent them from firing
                currentTrack.removeEventListener('ended', currentTrack.endedHandler);
                currentTrack.removeEventListener('error', currentTrack.errorHandler);
                currentTrack.pause();
                // Don't clear src as it can trigger ended event
                currentTrack = null; // Clear reference
            }
            
            // Pick random track
            const randomIndex = Math.floor(Math.random() * availableTracks.length);
            const trackName = availableTracks[randomIndex];
            
            // Remove the selected track from available tracks
            availableTracks.splice(randomIndex, 1);
            console.log(`Playing: ${trackName}, remaining tracks: ${availableTracks.length}`);
            
            // Create audio element
            currentTrack = new Audio(`music/${trackName}`);
            currentTrack.volume = musicMuted ? 0 : musicVolume;
            
            // Create event handlers that we can reference later for removal
            currentTrack.endedHandler = function() {
                console.log(`Track "${trackName}" ended, stopRequested: ${this.stopRequested}, currentTime: ${this.currentTime}, duration: ${this.duration}`);
                // Reset the playing flag first
                isPlayingNext = false;
                
                // Only play next if the track wasn't stopped intentionally and actually ended
                if (!this.stopRequested && this.currentTime > 0 && this.duration > 0 && this.currentTime >= this.duration - 0.5) {
                    console.log('Track ended naturally, playing next track...');
                    setTimeout(() => {
                        try {
                            playRandomTrack();
                        } catch (error) {
                            console.error('Error playing next track:', error);
                            // Try again in a few seconds
                            setTimeout(playRandomTrack, 3000);
                        }
                    }, 1000); // Wait 1 second before next track
                } else {
                    console.log('Track was stopped or ended prematurely, not playing next track');
                }
            };
            
            currentTrack.errorHandler = (e) => {
                console.error('Error loading track:', trackName, e);
                // Reset the playing flag
                isPlayingNext = false;
                // Try next track after a short delay
                setTimeout(() => {
                    playRandomTrack();
                }, 1000);
            };
            
            // Add event listeners
            currentTrack.addEventListener('ended', currentTrack.endedHandler);
            currentTrack.addEventListener('error', currentTrack.errorHandler);
            
            // Try to play
            const playPromise = currentTrack.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Music started playing successfully');
                    isPlayingNext = false; // Reset flag on success
                }).catch(e => {
                    console.log('Music autoplay blocked:', e.message);
                    // Store track to retry on user interaction
                    window.pendingMusicTrack = currentTrack;
                    isPlayingNext = false; // Reset flag on error
                });
            } else {
                isPlayingNext = false; // Reset flag if no promise
            }
        }
        
        window.toggleMusic = function() {
            musicMuted = !musicMuted;
            
            // Update desktop mute text
            const muteText = document.getElementById('muteText');
            if (muteText) {
                muteText.textContent = musicMuted ? 'M to Unmute' : 'M to Mute';
            }
            
            // Update mobile mute button
            const mobileMuteButton = document.getElementById('muteButtonMobile');
            if (mobileMuteButton) {
                mobileMuteButton.textContent = musicMuted ? '🔊' : '🔇';
            }
            
            if (musicMuted) {
                if (currentTrack) {
                    currentTrack.pause();
                }
            } else {
                if (currentTrack && gameStarted) {
                    currentTrack.volume = musicVolume;
                    currentTrack.play().catch(() => {});
                }
            }
        };
        
        window.changeVolume = function(value) {
            musicVolume = value / 100;
            document.getElementById('volumeDisplay').textContent = value + '%';
            
            if (currentTrack && !musicMuted) {
                currentTrack.volume = musicVolume;
            }
        };
        
        // Debug function to reset discoveries
        window.resetDiscoveries = function() {
            // Clear from localStorage
            localStorage.removeItem('discoveredElements');
            localStorage.removeItem('allTimeDiscoveries');
            
            // Clear in-game discoveries
            discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
            allTimeDiscoveries = new Map();
            
            // Update UI
            updateDiscoveryLog();
            
            console.log('Discoveries have been reset! Only base elements remain.');
            return 'Discoveries reset successfully';
        };
        
        // Border particle class
        class BorderParticle {
            constructor(x, y, edge) {
                this.x = x;
                this.y = y;
                this.edge = edge; // 'left', 'right', 'top', 'bottom'
                this.baseX = x;
                this.baseY = y;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 0.5 + 0.1;
                this.offset = Math.random() * Math.PI * 2;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = this.getRandomColor();
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(147, 51, 234, ', // purple
                    'rgba(236, 72, 153, ', // pink
                    'rgba(59, 130, 246, ', // blue
                    'rgba(168, 85, 247, ', // purple-pink
                    'rgba(99, 102, 241, '  // indigo
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(deltaTime) {
                const time = animationTime + this.offset;
                
                // Float in circular motion
                const radius = 15;
                const floatX = Math.cos(time * this.speed) * radius;
                const floatY = Math.sin(time * this.speed * 0.7) * radius;
                
                this.x = this.baseX + floatX;
                this.y = this.baseY + floatY;
                
                // Pulse opacity
                this.opacity = 0.3 + Math.sin(time * 2) * 0.2;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color + this.opacity + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color + '0.8)';
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Snake class
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.prevX = x;
                this.prevY = y;
                this.angle = Math.random() * Math.PI * 2;
                this.prevAngle = this.angle;
                this.segments = [];
                
                this.elements = [];
                this.maxVisibleElements = 6; // Fixed max of 6 visible element slots
                this.overflowElements = 0; // Count of elements beyond visible slots (for length calculation)
                this.elementsEaten = 0; // Track total elements eaten
                this.length = 10;
                this.score = 0;
                this.discoveries = 0; // Track discoveries for this snake
                this.kills = 0; // Track kills for this snake
                this.alive = true;
                this.isPlayer = isPlayer;
                this.speed = SNAKE_SPEED;
                this.baseSpeed = SNAKE_SPEED; // Store base speed for boost calculations
                this.name = isPlayer ? 'You' : generateSnakeName();
                this.invincibilityTimer = 0;
                
                // Debug logging for player snake creation
                if (isPlayer) {
                    console.log('[SNAKE CONSTRUCTOR] Creating PLAYER snake at', x, y);
                    console.trace(); // Show stack trace to see where it's being called from
                }
                this.discoveredElements = new Set(); // Each snake tracks its own discoveries - starts empty
                
                // Speed boost properties
                this.stamina = 100; // Max stamina
                this.maxStamina = 100;
                this.isBoosting = false;
                this.wasBoostingLastFrame = false; // Track boost state changes
                this.staminaRegenCooldown = 0; // Prevents regen immediately after boosting
                this.boostParticleTimer = 0;
                
                // Near-miss tracking
                this.nearMissTracking = new Map(); // Track distance to other snakes over time
                this.recentCollisions = new Set(); // Track recent collisions to prevent near-miss after collision
                
                // Assign skin
                if (isPlayer) {
                    this.skin = currentPlayerSkin;
                } else {
                    // Get available AI skins (exclude snake-default-green and already used skins)
                    const allSkins = Object.keys(skinMetadata).filter(skin => 
                        skin !== 'snake-default-green' && !usedAISkins.has(skin)
                    );
                    
                    // If all skins are used, reset the used skins set (but still exclude default green)
                    if (allSkins.length === 0) {
                        usedAISkins.clear();
                        const resetSkins = Object.keys(skinMetadata).filter(skin => skin !== 'snake-default-green');
                        this.skin = resetSkins[Math.floor(Math.random() * resetSkins.length)];
                    } else {
                        this.skin = allSkins[Math.floor(Math.random() * allSkins.length)];
                    }
                    
                    // Mark this skin as used
                    usedAISkins.add(this.skin);
                    
                    // Assign random personality to AI snakes
                    const personalities = Object.keys(AI_PERSONALITIES);
                    const personalityKey = personalities[Math.floor(Math.random() * personalities.length)];
                    this.personality = AI_PERSONALITIES[personalityKey];
                    this.name = this.personality.name + ' ' + this.name;
                    this.personalityColor = PERSONALITY_COLORS[this.personality.name];
                    
                    // AI-specific properties
                    this.targetMemory = null; // Remember targets for a few frames
                    this.targetMemoryTimer = 0;
                    this.lastCollisionCheck = 0; // Optimize collision checking
                    this.panicMode = false; // Emergency evasion state
                    this.panicTimer = 0;
                }
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    const segX = x - i * SEGMENT_SIZE * Math.cos(this.angle);
                    const segY = y - i * SEGMENT_SIZE * Math.sin(this.angle);
                    this.segments.push({
                        x: segX,
                        y: segY,
                        prevX: segX,
                        prevY: segY
                    });
                }
                
                // Start with NO elements - snakes must collect them from the map
                // This ensures players experience the discovery process from scratch
            }
            
            update(deltaTime = 1) {
                if (!this.alive) return;
                
                // Store previous positions for interpolation
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevAngle = this.angle;
                
                // Store previous segment positions
                if (this.segments) {
                    this.segments.forEach(segment => {
                        segment.prevX = segment.x;
                        segment.prevY = segment.y;
                    });
                }
                
                // Debug check
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    console.error('Snake position is NaN!', 'x:', this.x, 'y:', this.y, 'deltaTime:', deltaTime);
                }
                
                // Update invincibility
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= 16; // Fixed timestep
                }
                
                // Handle controls
                if (this.isPlayer) {
                    // Only apply controls if this is the main player snake
                    if (this !== playerSnake) {
                        console.error('[CONTROLS] WARNING: Non-main player snake detected! Skipping controls for snake:', this.name);
                        this.alive = false; // Kill duplicate player snake
                        return;
                    }
                    
                    // Handle turning
                    let turnMultiplier = 1;
                    if (this.isBoosting) {
                        turnMultiplier = 0.85; // Reduced turn speed while boosting
                    }
                    
                    if (isMobile && joystickActive) {
                        // Mobile controls - use joystick
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        const angleChange = angleDiff * 0.12 * turnMultiplier;
                        if (isFinite(angleChange)) {
                            this.angle += angleChange;
                        }
                        this.isBoosting = mouseDown && this.stamina > 0;
                    } else if (controlScheme === 'arrows') {
                        // Arrow keys
                        if (keys['ArrowLeft']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['ArrowRight']) this.angle += TURN_SPEED * turnMultiplier;
                        // WASD keys (always available alongside arrows)
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED * turnMultiplier;
                        // Handle boost (both ArrowUp and W)
                        this.isBoosting = (keys['ArrowUp'] || keys['w'] || keys['W']) && this.stamina > 0;
                    } else if (controlScheme === 'mouse') {
                        // WASD controls - standard tank controls that just turn the snake
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED * turnMultiplier;
                        
                        // Mouse steering only if mouse has moved recently and WASD not being used
                        const usingWASD = keys['a'] || keys['A'] || keys['d'] || keys['D'];
                        if (!usingWASD && mouseMovedRecently) {
                            // Smooth angle interpolation toward mouse
                            let angleDiff = mouseAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            const angleChange = angleDiff * 0.1 * turnMultiplier;
                            if (isFinite(angleChange)) {
                                this.angle += angleChange;
                            }
                        }
                        
                        // Handle boost (mouse click OR W key)
                        this.isBoosting = (mouseDown || keys['w'] || keys['W']) && this.stamina > 0;
                    }
                } else {
                    // Enhanced AI with personality system
                    this.updateAI(deltaTime);
                }
                
                // Update stamina and speed based on boost
                if (this.isBoosting && this.stamina > 0) {
                    // Play boost sound when starting to boost
                    if (!this.wasBoostingLastFrame) {
                        playBoostSound(this.isPlayer);
                    }
                    
                    // Deplete stamina (5 seconds of continuous use)
                    this.stamina -= (100 / (5 * 60)) * deltaTime; // 100 stamina over 5 seconds
                    this.stamina = Math.max(0, this.stamina);
                    this.staminaRegenCooldown = 30; // Half second cooldown before regen starts
                    
                    // Apply speed boost
                    this.speed = this.baseSpeed * 1.75;
                    
                    // Create boost particles
                    this.boostParticleTimer++;
                    const particleFrequency = isMobile ? 6 : 3; // Less frequent on mobile
                    if (this.boostParticleTimer % particleFrequency === 0) {
                        const particleAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                        const particleSpeed = 2 + Math.random() * 2;
                        const vx = Math.cos(particleAngle) * particleSpeed;
                        const vy = Math.sin(particleAngle) * particleSpeed;
                        const color = this.isPlayer ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                        particlePool.spawn(this.x, this.y, vx, vy, color);
                    }
                } else {
                    // Not boosting
                    this.isBoosting = false;
                    this.speed = this.baseSpeed;
                    
                    // Regenerate stamina
                    if (this.staminaRegenCooldown > 0) {
                        this.staminaRegenCooldown -= deltaTime;
                    } else if (this.stamina < this.maxStamina) {
                        // Regenerate stamina (2 seconds to full)
                        this.stamina += (100 / (2 * 60)) * deltaTime; // 100 stamina over 2 seconds
                        this.stamina = Math.min(this.maxStamina, this.stamina);
                    }
                }
                
                // Ensure angle is valid
                if (!isFinite(this.angle)) {
                    console.error('Angle is invalid!', this.angle, 'Resetting to 0');
                    this.angle = 0;
                }
                
                // Move head (apply deltaTime for proper movement)
                const moveX = Math.cos(this.angle) * this.speed * deltaTime;
                const moveY = Math.sin(this.angle) * this.speed * deltaTime;
                
                if (isFinite(moveX) && isFinite(moveY)) {
                    this.x += moveX;
                    this.y += moveY;
                } else {
                    console.error('Invalid movement!', 'angle:', this.angle, 'speed:', this.speed, 'deltaTime:', deltaTime);
                }
                
                // World boundaries
                if (this.x < 0 || this.x > WORLD_SIZE || this.y < 0 || this.y > WORLD_SIZE) {
                    this.die();
                    return;
                }
                
                // Update segments
                if (!this.segments) {
                    console.error('Segments array is undefined!');
                    this.segments = [];
                }
                this.segments.unshift({ 
                    x: this.x, 
                    y: this.y,
                    prevX: this.prevX || this.x,
                    prevY: this.prevY || this.y
                });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
                
                // Update boost state tracking
                this.wasBoostingLastFrame = this.isBoosting;
            }
            
            checkCombinations(depth = 0) {
                if (this.elements.length < 2) return;
                
                // Limit chain reaction depth
                const MAX_CHAIN_DEPTH = 3;
                if (depth >= MAX_CHAIN_DEPTH) {
                    console.log('[DEBUG] Max chain reaction depth reached, stopping');
                    return;
                }
                
                // Find all possible combinations
                let possibleCombos = [];
                
                for (let i = 0; i < this.elements.length; i++) {
                    for (let j = i + 1; j < this.elements.length; j++) {
                        const elem1 = this.elements[i];
                        const elem2 = this.elements[j];
                        
                        // Check if these can combine
                        let result = null;
                        if (window.elementLoader && window.elementCompatibility) {
                            const resultElement = window.elementLoader.getCombinationByKeys(elem1, elem2);
                            result = resultElement ? resultElement.key : null;
                        } else {
                            const combo1 = `${elem1}+${elem2}`;
                            const combo2 = `${elem2}+${elem1}`;
                            result = combinations[combo1] || combinations[combo2];
                        }
                        
                        if (result && elementDatabase[result]) {
                            const isNewDiscovery = !this.discoveredElements.has(result);
                            const resultTier = elementDatabase[result].tier || 0;
                            
                            possibleCombos.push({
                                index1: i,
                                index2: j,
                                elem1,
                                elem2,
                                result,
                                isNewDiscovery,
                                tier: resultTier
                            });
                        }
                    }
                }
                
                if (possibleCombos.length === 0) {
                    if (this.isPlayer && this === playerSnake) {
                        comboStreak = 0;
                    }
                    return;
                }
                
                // Prioritize: new discoveries first, then by highest tier
                possibleCombos.sort((a, b) => {
                    if (a.isNewDiscovery && !b.isNewDiscovery) return -1;
                    if (!a.isNewDiscovery && b.isNewDiscovery) return 1;
                    return b.tier - a.tier;
                });
                
                const chosen = possibleCombos[0];
                
                // Debug logging
                if (depth === 0) {
                    console.log('[DEBUG] Checking combinations:', {
                        elements: [...this.elements],
                        possibleCombos: possibleCombos.length,
                        chosen: chosen
                    });
                }
                
                // Start combination animation for player
                if (this.isPlayer) {
                    this.startCombinationAnimation(chosen.index1, chosen.index2);
                    // Play combination sound - disabled
                    // playCombinationSound();
                    // Create visual flash effect
                    createCombinationFlash();
                    // Update UI immediately to show animation
                    updateUI();
                }
                
                // Remove the two elements (remove higher index first to maintain indices)
                const indices = [chosen.index1, chosen.index2].sort((a, b) => b - a);
                this.elements.splice(indices[0], 1);
                this.elements.splice(indices[1], 1);
                
                // Add the result to a random position in the available slots
                const insertIndex = Math.floor(Math.random() * (this.elements.length + 1));
                this.elements.splice(insertIndex, 0, chosen.result);
                            
                    // Discovery check
                    if (chosen.isNewDiscovery) {
                        this.discoveredElements.add(chosen.result);
                        this.score += 1000; // 1000 points for new discovery
                        this.discoveries++; // Increment discovery count
                        
                        // Additional effects for player
                        if (this.isPlayer && this === playerSnake) {
                            discoveredElements.add(chosen.result); // Update global discoveries
                            
                            // Save to all-time discoveries with recipe
                            const recipe = `${elementDatabase[chosen.elem1]?.emoji || '?'} ${elementDatabase[chosen.elem1]?.name || chosen.elem1} + ${elementDatabase[chosen.elem2]?.emoji || '?'} ${elementDatabase[chosen.elem2]?.name || chosen.elem2}`;
                            allTimeDiscoveries.set(chosen.result, recipe);
                            saveAllTimeDiscoveries();
                            
                            // Update new system if available
                            if (window.elementLoader && window.elementCompatibility) {
                                const element = window.elementLoader.getElementByKey(chosen.result);
                                if (element) {
                                    window.elementLoader.discoverElement(element.id);
                                    // Save discovered elements - pass the global discoveredElements set as an object
                                    const discoveredObj = {};
                                    discoveredElements.forEach(elem => {
                                        discoveredObj[elem] = true;
                                    });
                                    window.elementCompatibility.saveDiscoveredElements(discoveredObj);
                                }
                            }
                            
                            showCombinationMessage(chosen.elem1, chosen.elem2, chosen.result, true); // Show new discovery
                            console.log('[DEBUG] New discovery triggered:', chosen.elem1, '+', chosen.elem2, '=', chosen.result);
                            // Grant invincibility on new discovery
                            this.invincibilityTimer = 3000; // 3 seconds
                            
                            // Check for new high score
                            if (this.score > highScore) {
                                highScore = this.score;
                                localStorage.setItem('highScore', highScore.toString());
                            }
                        }
                    } else {
                        // Existing combination - add combo streak points
                        if (this.isPlayer && this === playerSnake) {
                            comboStreak++;
                            let comboBonus = 100; // Base combo points
                            
                            // Calculate streak bonus
                            if (comboStreak >= 4) {
                                comboBonus = 2500;
                                showMessage(`4x COMBO STREAK! +${comboBonus} points!`, 'combo');
                            } else if (comboStreak >= 3) {
                                comboBonus = 1000;
                                showMessage(`3x Combo Streak! +${comboBonus} points!`, 'combo');
                            } else if (comboStreak >= 2) {
                                comboBonus = 500;
                                showMessage(`2x Combo! +${comboBonus} points!`, 'combo');
                            }
                            
                            this.score += comboBonus;
                            showCombinationMessage(chosen.elem1, chosen.elem2, chosen.result, false); // Show combo
                        }
                    }
                            
                    // Create particle effect at snake head
                    createCombinationParticles(this.segments[0].x, this.segments[0].y);
                    
                    // Log chain reaction info
                    console.log(`[DEBUG] Combination successful (depth ${depth}):`, {
                        combination: `${chosen.elem1} + ${chosen.elem2} = ${chosen.result}`,
                        remainingElements: [...this.elements]
                    });
                    
                    // Check again in case there are more combinations
                    this.checkCombinations(depth + 1);
                }
            
            consume(element) {
                // Play eating sound for player only
                if (this.isPlayer) {
                    playEatSound();
                }
                
                // Check if we have space in visible slots
                if (this.elements.length >= this.maxVisibleElements) {
                    // At visible capacity - remove oldest element (tail)
                    this.elements.pop(); // Remove oldest (tail)
                    this.overflowElements++;
                }
                
                // Add element to a random position
                const insertIndex = Math.floor(Math.random() * (this.elements.length + 1));
                this.elements.splice(insertIndex, 0, element.type);
                
                // Track elements eaten
                this.elementsEaten++;
                
                // Grow snake
                this.length += 2;
                
                // Add score - 100 points per element
                this.score += 100;
                
                // Check for new high score
                if (this.isPlayer && this.score > highScore) {
                    highScore = this.score;
                    localStorage.setItem('highScore', highScore.toString());
                }
                
                // Remove element from world
                elementPool.remove(element);
                
                // Update UI if player
                if (this.isPlayer) {
                    updateUI();
                }
            }
            
            digest() {
                if (!this.isPlayer || this.elements.length === 0) {
                    // Non-player digestion happens instantly
                    const digestedCount = this.elements.length;
                    this.elements = [];
                    
                    // Bonus points for digestion based on how full we were
                    const digestBonus = Math.floor(digestedCount * 50);
                    this.score += digestBonus;
                    
                    // Check for new high score
                    if (this.isPlayer && this.score > highScore) {
                        highScore = this.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                    return;
                }
                
                // Player digestion - show message immediately
                const digestedCount = this.elements.length;
                
                // Clear all elements immediately
                this.elements = [];
                
                // Bonus points for digestion based on how full we were
                const digestBonus = Math.floor(digestedCount * 50);
                this.score += digestBonus;
                
                // Show digestion message for player only
                if (this.isPlayer && this === playerSnake) {
                    showMessage(`Digesting ${digestedCount} elements! +${digestBonus} points`, false);
                    // Update UI immediately
                    updateUI();
                }
            }
            
            startCombinationAnimation(index1, index2) {
                // Store indices for animation
                this.combiningIndices = [index1, index2];
                this.combinationAnimationTime = 0;
                this.isAnimatingCombination = true;
                
                // Update global animation state for UI
                if (this.isPlayer) {
                    combinationAnimationState.isAnimating = true;
                    combinationAnimationState.combiningIndices = [index1, index2];
                    combinationAnimationState.animationStartTime = Date.now();
                    
                    // The new element will be inserted at a random position
                    // We'll track it after the combination completes
                    setTimeout(() => {
                        // Find the newest element (the one that's not in the old positions)
                        const remainingElements = this.elements.length;
                        if (remainingElements > 0) {
                            // Since we insert at random position, we need to find it
                            // For now, we'll animate the first slot as a placeholder
                            combinationAnimationState.newElementIndex = Math.floor(Math.random() * remainingElements);
                            // Update UI to show the new element animation
                            updateUI();
                        }
                    }, 300);
                }
            }
            
            die() {
                console.error('Snake dying!', 'isPlayer:', this.isPlayer, 'position:', this.x, this.y);
                console.trace();
                this.alive = false;
                
                // Drop all elements
                for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    spawnElement(this.elements[i], segment.x, segment.y);
                }
                
                // Create death particles scaled to snake size
                createDeathParticles(this.x, this.y, this.length);
                
                // Respawn if player
                if (this.isPlayer) {
                    // Player respawn is now handled in the main game loop
                    // This prevents duplicate player snakes from being created
                    console.log('[SNAKE DIE] Player died, respawn will be handled by game loop');
                }
            }
            
            explode(killer) {
                // Play explosion sound - louder if player is involved
                const isPlayerInvolved = this.isPlayer || (killer && killer.isPlayer);
                playExplosionSound(isPlayerInvolved);
                
                // Award points and kills to killer
                if (killer && killer.alive) {
                    killer.score += 500; // 500 points for snake explosion
                    killer.kills++; // Increment kill count
                    
                    // Check for new high score if player
                    if (killer.isPlayer && killer.score > highScore) {
                        highScore = killer.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                }
                this.die();
            }
            
            draw(interpolation = 0) {
                if (!this.alive) return;
                
                // Early viewport check for the whole snake
                // TEMPORARILY DISABLED FOR DEBUGGING
                /*
                if (this.segments.length > 0) {
                    // Check if any segment is in viewport
                    let anyInViewport = false;
                    const margin = isMobile ? 150 : 200;
                    for (const segment of this.segments) {
                        if (isInViewport(segment.x, segment.y, margin)) {
                            anyInViewport = true;
                            break;
                        }
                    }
                    if (!anyInViewport) return;
                }
                */
                
                // Draw boost trail effect
                if (this.isBoosting && this.segments && this.segments.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw speed lines
                    for (let i = 0; i < 3; i++) {
                        const segment = this.segments[Math.min(i * 2, this.segments.length - 1)];
                        const nextSegment = this.segments[Math.min(i * 2 + 5, this.segments.length - 1)];
                        
                        const screenX1 = segment.x - camera.x + canvas.width / 2;
                        const screenY1 = segment.y - camera.y + canvas.height / 2;
                        const screenX2 = nextSegment.x - camera.x + canvas.width / 2;
                        const screenY2 = nextSegment.y - camera.y + canvas.height / 2;
                        
                        // Skip if any coordinate is invalid
                        if (!isFinite(screenX1) || !isFinite(screenY1) || !isFinite(screenX2) || !isFinite(screenY2)) {
                            continue;
                        }
                        
                        const gradient = ctx.createLinearGradient(screenX1, screenY1, screenX2, screenY2);
                        gradient.addColorStop(0, this.isPlayer ? 'rgba(100, 200, 255, 0.6)' : 'rgba(255, 100, 100, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = SEGMENT_SIZE * 2 - i * 5;
                        ctx.beginPath();
                        ctx.moveTo(screenX1, screenY1);
                        ctx.lineTo(screenX2, screenY2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
                
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    
                    // Interpolate position if previous position exists
                    let x = segment.x;
                    let y = segment.y;
                    if (segment.prevX !== undefined && segment.prevY !== undefined) {
                        x = segment.prevX + (segment.x - segment.prevX) * interpolation;
                        y = segment.prevY + (segment.y - segment.prevY) * interpolation;
                    }
                    
                    const screenX = x - camera.x + canvas.width / 2;
                    const screenY = y - camera.y + canvas.height / 2;
                    
                    // Skip if off-screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    // Snake body color based on skin
                    const skinData = skinMetadata[this.skin];
                    const colors = skinData ? skinData.colors : ['#4ecdc4', '#45b7aa'];
                    
                    if (this.invincibilityTimer > 0 && this.isPlayer) {
                        // Flash effect during invincibility
                        const flash = Math.sin(this.invincibilityTimer * 0.01) > 0;
                        ctx.fillStyle = flash ? '#FFD700' : colors[i % colors.length];
                    } else {
                        ctx.fillStyle = colors[i % colors.length];
                    }
                    
                    ctx.beginPath();
                    // Ensure segment radius never goes below 1 pixel
                    const segmentRadius = Math.max(1, SEGMENT_SIZE - Math.min(i * 0.05, SEGMENT_SIZE - 1));
                    ctx.arc(screenX, screenY, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    
                    // Interpolate head position
                    let headX = head.x;
                    let headY = head.y;
                    let angle = this.angle;
                    
                    if (head.prevX !== undefined && head.prevY !== undefined) {
                        headX = head.prevX + (head.x - head.prevX) * interpolation;
                        headY = head.prevY + (head.y - head.prevY) * interpolation;
                    }
                    
                    if (this.prevAngle !== undefined) {
                        // Handle angle wrapping for smooth interpolation
                        let angleDiff = this.angle - this.prevAngle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        angle = this.prevAngle + angleDiff * interpolation;
                    }
                    
                    // Offset head position forward along the snake direction
                    const offsetDistance = 10; // pixels to move head forward
                    const offsetX = Math.cos(angle) * offsetDistance;
                    const offsetY = Math.sin(angle) * offsetDistance;
                    
                    const screenX = (headX + offsetX) - camera.x + canvas.width / 2;
                    const screenY = (headY + offsetY) - camera.y + canvas.height / 2;
                    
                    // Draw boost glow around head
                    if (this.isBoosting) {
                        const glowSize = SEGMENT_SIZE * 4;
                        const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                        gradient.addColorStop(0, this.isPlayer ? 'rgba(100, 200, 255, 0.4)' : 'rgba(255, 100, 100, 0.4)');
                        gradient.addColorStop(0.5, this.isPlayer ? 'rgba(100, 200, 255, 0.2)' : 'rgba(255, 100, 100, 0.2)');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                    }
                    
                    // Draw skin image
                    const skinImage = skinImages[this.skin];
                    if (skinImage && skinImage.complete && !skinImage.error) {
                        try {
                            ctx.save();
                            ctx.translate(screenX, screenY);
                            ctx.rotate(angle - Math.PI/2); // Rotate 90 degrees counter-clockwise so top faces body
                            const size = SEGMENT_SIZE * 3.47875; // Increased by another 10% (3.1625 * 1.1)
                            ctx.drawImage(skinImage, -size/2, -size/2, size, size);
                            ctx.restore();
                        } catch (e) {
                            ctx.restore();
                            // Fall through to emoji fallback
                        }
                    } else {
                        // Fallback to emoji if image not loaded
                        const snakeEmojiSize = Math.round(SEGMENT_SIZE * 2);
                        const snakeEmojiCanvas = getCachedEmoji(this.isPlayer ? '😊' : '🐍', snakeEmojiSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.drawImage(snakeEmojiCanvas, screenX - snakeEmojiCanvas.width / 2, screenY - snakeEmojiCanvas.height / 2);
                        ctx.restore();
                    }
                    
                    // Draw name (with colored personality for AI snakes)
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    const nameY = screenY - SEGMENT_SIZE - 10;
                    
                    if (!this.isPlayer && this.personality) {
                        // Split name into personality and actual name parts
                        const personalityName = this.personality.name + ' ';
                        const actualName = this.name.substring(personalityName.length);
                        
                        // Measure text widths
                        ctx.fillStyle = this.personalityColor;
                        const personalityWidth = ctx.measureText(personalityName).width;
                        ctx.fillStyle = 'white';
                        const actualNameWidth = ctx.measureText(actualName).width;
                        const totalWidth = personalityWidth + actualNameWidth;
                        
                        // Draw personality name with color
                        const startX = screenX - totalWidth / 2;
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.strokeText(personalityName, startX + personalityWidth / 2, nameY);
                        ctx.fillStyle = this.personalityColor;
                        ctx.fillText(personalityName, startX + personalityWidth / 2, nameY);
                        
                        // Draw actual name in white
                        ctx.strokeText(actualName, startX + personalityWidth + actualNameWidth / 2, nameY);
                        ctx.fillStyle = 'white';
                        ctx.fillText(actualName, startX + personalityWidth + actualNameWidth / 2, nameY);
                    } else {
                        // Player name or fallback - draw normally
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.fillStyle = 'white';
                        ctx.strokeText(this.name, screenX, nameY);
                        ctx.fillText(this.name, screenX, nameY);
                    }
                    
                    // Draw crown if leader
                    if (this.isLeader) {
                        const crownSize = 24;
                        const crownCanvas = getCachedEmoji('👑', crownSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.drawImage(crownCanvas, screenX - crownCanvas.width / 2, screenY - SEGMENT_SIZE - 30 - crownCanvas.height / 2);
                        ctx.restore();
                    }
                }
            }
            
            // Enhanced AI update logic with personalities
            updateAI(deltaTime) {
                const personality = this.personality;
                const currentTime = Date.now();
                
                // Update panic mode
                if (this.panicMode) {
                    this.panicTimer--;
                    if (this.panicTimer <= 0) {
                        this.panicMode = false;
                    }
                }
                
                // Border avoidance (personality-aware)
                const borderDanger = personality.riskTolerance > 0.7 ? 80 : 120;
                const emergencyDistance = personality.riskTolerance > 0.7 ? 40 : 60;
                
                // Check distances to borders
                const distToLeftBorder = this.x;
                const distToRightBorder = WORLD_SIZE - this.x;
                const distToTopBorder = this.y;
                const distToBottomBorder = WORLD_SIZE - this.y;
                
                const nearBorder = distToLeftBorder < borderDanger || distToRightBorder < borderDanger ||
                                  distToTopBorder < borderDanger || distToBottomBorder < borderDanger;
                
                const emergencyTurn = distToLeftBorder < emergencyDistance || distToRightBorder < emergencyDistance ||
                                     distToTopBorder < emergencyDistance || distToBottomBorder < emergencyDistance;
                
                if (emergencyTurn || this.panicMode) {
                    // Emergency evasion with personality-based urgency
                    let avoidAngle = this.angle;
                    const urgency = personality.riskTolerance < 0.5 ? 0.2 : 0.15;
                    
                    if (distToLeftBorder < emergencyDistance) avoidAngle = 0;
                    else if (distToRightBorder < emergencyDistance) avoidAngle = Math.PI;
                    
                    if (distToTopBorder < emergencyDistance) avoidAngle = Math.PI / 2;
                    else if (distToBottomBorder < emergencyDistance) avoidAngle = -Math.PI / 2;
                    
                    let angleDiff = avoidAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    this.angle += angleDiff * urgency;
                    
                    return; // Skip normal AI when in emergency mode
                }
                
                // Enhanced snake collision detection and avoidance
                let dangerVector = { x: 0, y: 0 };
                let nearestThreat = null;
                let nearestPrey = null;
                let threatDistance = Infinity;
                let preyDistance = Infinity;
                
                // Optimize: Only check collisions every few frames for performance
                if (currentTime - this.lastCollisionCheck > 100) { // Check every 100ms
                    this.lastCollisionCheck = currentTime;
                    
                    for (const otherSnake of snakes) {
                        if (otherSnake === this || !otherSnake.alive) continue;
                        
                        const dx = otherSnake.x - this.x;
                        const dy = otherSnake.y - this.y;
                        const distance = Math.hypot(dx, dy);
                        
                        // Check if this snake is a threat or prey
                        const lengthRatio = otherSnake.length / this.length;
                        
                        // Threat detection
                        if (lengthRatio > personality.fleeThreshold && distance < 300) {
                            if (distance < threatDistance) {
                                threatDistance = distance;
                                nearestThreat = otherSnake;
                            }
                        }
                        
                        // Prey detection - more aggressive for hunting personalities
                        const isValidPrey = lengthRatio < (1 / personality.fleeThreshold);
                        const inChaseRange = distance < personality.chaseDistance;
                        
                        if (isValidPrey && inChaseRange) {
                            // Opportunists prefer wounded or very small targets
                            if (personality.preferWeakTargets) {
                                const isWeak = otherSnake.length < this.length * 0.5 || otherSnake.stamina < 30;
                                if (isWeak && distance < preyDistance) {
                                    preyDistance = distance;
                                    nearestPrey = otherSnake;
                                }
                            } else if (distance < preyDistance) {
                                preyDistance = distance;
                                nearestPrey = otherSnake;
                            }
                        }
                        
                        // Check collision with snake body segments
                        if (distance < personality.collisionAvoidanceRadius) {
                            for (let i = 3; i < otherSnake.segments.length; i++) {
                                const segment = otherSnake.segments[i];
                                const segDx = segment.x - this.x;
                                const segDy = segment.y - this.y;
                                const segDistance = Math.hypot(segDx, segDy);
                                
                                if (segDistance < personality.collisionAvoidanceRadius) {
                                    // Add to danger vector (weighted by proximity)
                                    const weight = 1 - (segDistance / personality.collisionAvoidanceRadius);
                                    dangerVector.x -= (segDx / segDistance) * weight;
                                    dangerVector.y -= (segDy / segDistance) * weight;
                                }
                            }
                        }
                    }
                }
                
                // Decision making based on personality and situation
                let targetAngle = null;
                let shouldBoost = false;
                
                // Priority 1: Avoid immediate collisions
                if (Math.hypot(dangerVector.x, dangerVector.y) > 0.1) {
                    targetAngle = Math.atan2(dangerVector.y, dangerVector.x);
                    shouldBoost = personality.riskTolerance < 0.5;
                    
                    // Enter panic mode if danger is high
                    if (Math.hypot(dangerVector.x, dangerVector.y) > 0.5) {
                        this.panicMode = true;
                        this.panicTimer = 60; // 1 second at 60fps
                    }
                }
                // Priority 2: Flee from threats
                else if (nearestThreat && threatDistance < 200) {
                    const dx = nearestThreat.x - this.x;
                    const dy = nearestThreat.y - this.y;
                    targetAngle = Math.atan2(-dy, -dx); // Opposite direction
                    shouldBoost = personality.riskTolerance < 0.7 && this.stamina > 40;
                }
                // Priority 3: Hunt prey (aggressive personalities)
                else if (nearestPrey) {
                    // For aggressive personalities, ALWAYS prioritize hunting over elements
                    const shouldHunt = personality.huntingPriority > 0.8 || 
                                     (personality.huntingPriority > 0.5 && preyDistance < 150);
                    
                    if (shouldHunt) {
                        // Predict where the prey's head will be to eat them
                        const predictedPos = this.predictHeadPosition(nearestPrey);
                        if (predictedPos) {
                            const dx = predictedPos.x - this.x;
                            const dy = predictedPos.y - this.y;
                            targetAngle = Math.atan2(dy, dx);
                        } else {
                            // Fallback to current head position
                            const dx = nearestPrey.x - this.x;
                            const dy = nearestPrey.y - this.y;
                            targetAngle = Math.atan2(dy, dx);
                        }
                        
                        shouldBoost = this.stamina > 30 && preyDistance < 200;
                        
                        // Override element seeking for aggressive snakes
                        this.targetMemory = null;
                        this.targetMemoryTimer = 0;
                    }
                }
                // Priority 4: Seek game objectives
                else {
                    // Aggressive personalities should still look for prey opportunities
                    if (personality.huntingPriority > 0.7 && Math.random() < personality.elementIgnoreChance) {
                        // Scan for any snakes we might have missed
                        for (const otherSnake of snakes) {
                            if (otherSnake === this || !otherSnake.alive) continue;
                            const dist = Math.hypot(otherSnake.x - this.x, otherSnake.y - this.y);
                            if (dist < personality.chaseDistance * 0.7 && otherSnake.length < this.length) {
                                // Found a target! Predict head position to eat them
                                const predictedPos = this.predictHeadPosition(otherSnake);
                                if (predictedPos) {
                                    const dx = predictedPos.x - this.x;
                                    const dy = predictedPos.y - this.y;
                                    targetAngle = Math.atan2(dy, dx);
                                    shouldBoost = this.stamina > 40 && dist < 200;
                                }
                                break;
                            }
                        }
                    }
                    
                    // If still no target, seek elements
                    if (targetAngle === null) {
                        let target = null;
                        
                        // Use cached target for a few frames to reduce computation
                        if (this.targetMemory && this.targetMemoryTimer > 0) {
                            target = this.targetMemory;
                            this.targetMemoryTimer--;
                        } else {
                        // Find new target based on personality
                        if (this.elements.length >= this.elementCapacity) {
                            // At capacity - prioritize Void Orbs
                            let nearestVoidOrb = null;
                            let minVoidDist = 800;
                            
                            for (const orb of voidOrbs) {
                                const dist = Math.hypot(orb.x - this.x, orb.y - this.y);
                                if (dist < minVoidDist && !this.isPathBlocked(orb.x, orb.y, dist)) {
                                    minVoidDist = dist;
                                    nearestVoidOrb = orb;
                                }
                            }
                            target = nearestVoidOrb;
                        }
                        
                        // Check for Catalyst Gems (combo-focused personalities prioritize these)
                        if (!target && this.elements.length > 0 && personality.comboPriority > Math.random()) {
                            let nearestCatalystGem = null;
                            let minCatalystDist = 600;
                            
                            for (const gem of catalystGems) {
                                const dist = Math.hypot(gem.x - this.x, gem.y - this.y);
                                if (dist < minCatalystDist && !this.isPathBlocked(gem.x, gem.y, dist)) {
                                    minCatalystDist = dist;
                                    nearestCatalystGem = gem;
                                }
                            }
                            target = nearestCatalystGem;
                        }
                        
                        // Find nearest element if no special targets
                        if (!target) {
                            let nearestElement = null;
                            let minDist = 500;
                            
                            for (const element of elementPool.getActiveElements()) {
                                const dist = Math.hypot(element.x - this.x, element.y - this.y);
                                if (dist < minDist && !this.isPathBlocked(element.x, element.y, dist)) {
                                    minDist = dist;
                                    nearestElement = element;
                                }
                            }
                            target = nearestElement;
                        }
                        
                        // Cache the target
                        this.targetMemory = target;
                        this.targetMemoryTimer = 30; // Cache for 30 frames
                    }
                    
                    if (target) {
                        targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                        
                        // Boost decision based on personality and distance
                        const targetDist = Math.hypot(target.x - this.x, target.y - this.y);
                        if (targetDist > 300 && this.stamina > (personality.boostThreshold * 100)) {
                            shouldBoost = true;
                        }
                    }
                    } // Close the if (targetAngle === null) check
                }
                
                // Apply turning with personality-based smoothness
                if (targetAngle !== null) {
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Cautious personalities turn more smoothly
                    const turnSpeed = personality.riskTolerance > 0.7 ? 0.08 : 0.06;
                    this.angle += angleDiff * turnSpeed;
                } else {
                    // Wander with personality-based randomness
                    const wanderAmount = personality.riskTolerance * 0.05;
                    this.angle += (Math.random() - 0.5) * wanderAmount;
                }
                
                // Set boost state
                this.isBoosting = shouldBoost && this.stamina > 20 && !nearBorder;
            }
            
            // Helper method for predicting head position to eat smaller snakes
            predictHeadPosition(targetSnake) {
                if (!targetSnake || !targetSnake.segments || targetSnake.segments.length === 0) {
                    return null;
                }
                
                // Get the head position
                const head = targetSnake.segments[0];
                const targetSpeed = targetSnake.speed || SNAKE_SPEED;
                const distance = Math.hypot(head.x - this.x, head.y - this.y);
                
                // Calculate time to intercept
                const relativeSpeed = this.speed * 1.5; // Assume we'll boost
                const interceptTime = distance / relativeSpeed;
                
                // Predict where the head will be
                const predictedX = head.x + Math.cos(targetSnake.angle) * targetSpeed * interceptTime;
                const predictedY = head.y + Math.sin(targetSnake.angle) * targetSpeed * interceptTime;
                
                return { x: predictedX, y: predictedY };
            }
            
            // Helper method for basic pathfinding
            isPathBlocked(targetX, targetY, distance) {
                // Simple optimization - don't pathfind for distant targets
                if (distance > 200) return false;
                
                const steps = Math.floor(distance / 20); // Check every 20 pixels
                if (steps <= 1) return false;
                
                const stepX = (targetX - this.x) / steps;
                const stepY = (targetY - this.y) / steps;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + stepX * i;
                    const checkY = this.y + stepY * i;
                    
                    // Check if this point is too close to any snake body
                    for (const snake of snakes) {
                        if (snake === this || !snake.alive) continue;
                        
                        for (let j = 3; j < snake.segments.length; j++) {
                            const segment = snake.segments[j];
                            const segDist = Math.hypot(segment.x - checkX, segment.y - checkY);
                            if (segDist < SEGMENT_SIZE * 2) {
                                return true; // Path is blocked
                            }
                        }
                    }
                }
                
                return false; // Path is clear
            }
        }
        
        // Element class
        class Element {
            constructor(type, x, y, isCatalystSpawned = false) {
                this.type = type;
                this.x = x;
                this.y = y;
                
                // Try new element system first
                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                    this.data = window.elementLoader.getElementByKey(type);
                }
                
                // Fallback to old system
                if (!this.data) {
                    this.data = elementDatabase[type];
                }
                
                // Final fallback if element not found
                if (!this.data) {
                    console.warn(`Element type "${type}" not found in any database`);
                    this.data = { emoji: '❓', name: 'Unknown', tier: 0 };
                }
                this.pulse = 0;
                this.isCatalystSpawned = isCatalystSpawned;
                this.catalystSparkleTime = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                if (this.isCatalystSpawned) {
                    this.catalystSparkleTime += 0.1 * deltaTime;
                }
                
                // Magnetism effect - draw elements toward nearby snakes
                const magnetRange = 100; // Range at which magnetism starts
                const magnetStrength = 4.0; // Speed of attraction
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    // Check distance to snake head
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    
                    // Apply magnetism if within range
                    if (distance < magnetRange && distance > ELEMENT_SIZE) {
                        // Calculate normalized direction vector
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        
                        // Stronger pull when closer
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength * deltaTime;
                        
                        // Move element toward snake
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                const scale = 1 + Math.sin(this.pulse || 0) * 0.1;
                
                // Check if this element is compatible with player's tail during AlchemyVision
                let alchemyGlow = null;
                if (alchemyVisionActive && playerSnake && playerSnake.alive && playerSnake.elements.length > 0) {
                    const tailElement = playerSnake.elements[playerSnake.elements.length - 1];
                    const distance = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    
                    // Only show glows within 300 pixel radius
                    if (distance <= 300) {
                        // Check if this element can combine with tail
                        const combo1 = `${this.type}+${tailElement}`;
                        const combo2 = `${tailElement}+${this.type}`;
                        
                        if (combinations[combo1] || combinations[combo2]) {
                            const result = combinations[combo1] || combinations[combo2];
                            // Check if this is a new discovery
                            if (!discoveredElements.has(result)) {
                                alchemyGlow = 'discovery'; // Golden glow
                            } else {
                                alchemyGlow = 'known'; // Green glow
                            }
                        }
                    }
                }
                
                // Draw appropriate glow effect
                if (alchemyGlow === 'discovery') {
                    // Golden glow for new discoveries
                    const glowSize = ELEMENT_SIZE * 3 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                } else if (alchemyGlow === 'known') {
                    // Green glow for known combinations
                    const glowSize = ELEMENT_SIZE * 2.5 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    gradient.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(0, 200, 0, 0.3)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                } else if (this.data && this.data.tier > 0) {
                    // Normal tier-based glow
                    const glowSize = ELEMENT_SIZE * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Draw emoji using cache
                const emojiSize = Math.round(ELEMENT_SIZE * 2 * scale);
                const emojiCanvas = getCachedEmoji(this.data ? this.data.emoji : '❓', emojiSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(emojiCanvas, screenX - emojiCanvas.width / 2, screenY - emojiCanvas.height / 2);
                ctx.restore();
                
                // Draw element name below emoji
                ctx.font = '10px Arial';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                const name = this.data ? this.data.name : 'Unknown';
                ctx.strokeText(name, screenX, screenY + ELEMENT_SIZE + 5);
                ctx.fillText(name, screenX, screenY + ELEMENT_SIZE + 5);
                
                // Draw catalyst sparkles if this element was spawned by catalyst
                if (this.isCatalystSpawned) {
                    ctx.save();
                    for (let i = 0; i < 4; i++) {
                        const angle = (this.catalystSparkleTime + i * Math.PI / 2) % (Math.PI * 2);
                        const dist = ELEMENT_SIZE + 10 + Math.sin(this.catalystSparkleTime * 2) * 5;
                        const px = screenX + Math.cos(angle) * dist;
                        const py = screenY + Math.sin(angle) * dist;
                        
                        ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add a small star
                        const sparkleCanvas = getCachedEmoji('✨', 12);
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.drawImage(sparkleCanvas, px - sparkleCanvas.width / 2, py - sparkleCanvas.height / 2);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
        
        // AlchemyVision power-up class
        class AlchemyVision {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                this.rotation += 0.02 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetStrength = 5.0; // Stronger pull for power-ups
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    
                    if (distance < magnetRange && distance > this.size) {
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength * deltaTime;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Purple/gold glow effect
                const glowSize = this.size * 2 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)'); // Gold
                gradient.addColorStop(0.5, 'rgba(147, 0, 211, 0.4)'); // Purple
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Crystal ball emoji
                const crystalSize = Math.round(this.size * 2 * scale);
                const crystalCanvas = getCachedEmoji('🔮', crystalSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(crystalCanvas, -crystalCanvas.width / 2, -crystalCanvas.height / 2);
                ctx.restore();
                
                // Swirling particles
                for (let i = 0; i < 3; i++) {
                    const angle = (this.rotation * 2) + (i * Math.PI * 2 / 3);
                    const dist = this.size * scale;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(255, 215, 0, 0.8)' : 'rgba(147, 0, 211, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // VoidOrb class
        class VoidOrb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                this.rotation += 0.03 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetStrength = 5.0; // Stronger pull for power-ups
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    
                    if (distance < magnetRange && distance > this.size) {
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Blue glow effect
                const glowSize = this.size * 2 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(0, 150, 255, 0.6)'); // Bright blue
                gradient.addColorStop(0.5, 'rgba(0, 50, 200, 0.4)'); // Dark blue
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Void orb emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('🌀', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Swirling particles
                for (let i = 0; i < 4; i++) {
                    const angle = (this.rotation * 3) + (i * Math.PI / 2);
                    const dist = this.size * scale * 0.8;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // CatalystGem class
        class CatalystGem {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
                this.sparkleTime = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.04 * deltaTime;
                this.rotation += 0.02 * deltaTime;
                this.sparkleTime += 0.1 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetStrength = 5.0; // Stronger pull for power-ups
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    
                    if (distance < magnetRange && distance > this.size) {
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.15;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Orange glow effect
                const glowSize = this.size * 2.5 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Bright orange
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)'); // Dark orange
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Catalyst gem emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('💎', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Sparkle particles
                for (let i = 0; i < 6; i++) {
                    const angle = (this.sparkleTime + i * Math.PI / 3) % (Math.PI * 2);
                    const dist = this.size * scale * (0.8 + Math.sin(this.sparkleTime * 2 + i) * 0.3);
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2 + Math.sin(this.sparkleTime * 3 + i) * 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.reset(x, y, vx, vy, color);
            }
            
            reset(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.active = true;
            }
            
            update(deltaTime = 1) {
                if (!this.active) return false;
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.life -= 0.02 * deltaTime;
                this.vx *= Math.pow(0.98, deltaTime);
                this.vy *= Math.pow(0.98, deltaTime);
                
                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }
                return true;
            }
            
            draw() {
                if (!this.active) return;
                
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // Object pools for performance
        class ParticlePool {
            constructor(size = 200) {
                this.pool = [];
                this.activeParticles = [];
                
                // Pre-allocate particles
                for (let i = 0; i < size; i++) {
                    this.pool.push(new Particle(0, 0, 0, 0, 'white'));
                }
            }
            
            spawn(x, y, vx, vy, color) {
                let particle = this.pool.pop();
                if (!particle) {
                    // Pool is empty, create new particle
                    particle = new Particle(x, y, vx, vy, color);
                } else {
                    particle.reset(x, y, vx, vy, color);
                }
                this.activeParticles.push(particle);
                return particle;
            }
            
            update(deltaTime = 1) {
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    if (!particle.update(deltaTime)) {
                        // Return to pool
                        this.activeParticles.splice(i, 1);
                        this.pool.push(particle);
                    }
                }
            }
            
            draw() {
                this.activeParticles.forEach(particle => {
                    if (isInViewport(particle.x, particle.y, 50)) {
                        particle.draw();
                    }
                });
            }
            
            getActiveCount() {
                return this.activeParticles.length;
            }
        }
        
        // Initialize particle pool
        const particlePool = new ParticlePool(isMobile ? 100 : 200);
        
        // Element pool for performance
        class ElementPool {
            constructor(size = 50) {
                this.pool = [];
                this.activeElements = [];
            }
            
            spawn(type, x, y, isCatalystSpawned = false) {
                let element = this.pool.pop();
                if (!element) {
                    element = new Element(type, x, y, isCatalystSpawned);
                } else {
                    // Reset existing element
                    element.type = type;
                    element.x = x;
                    element.y = y;
                    element.data = elementDatabase[type];
                    if (!element.data) {
                        console.warn(`Element type "${type}" not found in database`);
                        element.data = { emoji: '❓', name: 'Unknown', tier: 0 };
                    }
                    element.pulse = 0;
                    element.isCatalystSpawned = isCatalystSpawned;
                    element.catalystSparkleTime = 0;
                }
                this.activeElements.push(element);
                return element;
            }
            
            remove(element) {
                const index = this.activeElements.indexOf(element);
                if (index > -1) {
                    this.activeElements.splice(index, 1);
                    this.pool.push(element);
                }
            }
            
            update(deltaTime = 1) {
                this.activeElements.forEach(element => element.update(deltaTime));
            }
            
            draw() {
                this.activeElements.forEach(element => {
                    if (isInViewport(element.x, element.y, ELEMENT_SIZE + 50)) {
                        element.draw();
                    }
                });
            }
            
            getActiveElements() {
                return this.activeElements;
            }
            
            getActiveCount() {
                return this.activeElements.length;
            }
        }
        
        // Initialize element pool
        const elementPool = new ElementPool();
        
        // Shooting Star class
        class ShootingStar {
            constructor() {
                // Random starting position on screen edge
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // Top
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = 0;
                        break;
                    case 1: // Right
                        this.x = WORLD_SIZE;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = WORLD_SIZE;
                        break;
                    case 3: // Left
                        this.x = 0;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                }
                
                // Random angle and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = 15 + Math.random() * 10; // Fast movement
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.trail = [];
                this.maxTrailLength = 20;
                this.life = 1.0;
                this.fadeSpeed = 0.01; // Slower fade for 1-2 second visibility
            }
            
            update(deltaTime = 1) {
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y, alpha: this.life });
                
                // Limit trail length
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Fade out
                this.life -= this.fadeSpeed * deltaTime;
                
                // Update trail alpha
                this.trail.forEach((point, index) => {
                    point.alpha = (index / this.trail.length) * this.life;
                });
                
                // Check if out of bounds or faded
                return this.life > 0 && this.x > -100 && this.x < WORLD_SIZE + 100 && 
                       this.y > -100 && this.y < WORLD_SIZE + 100;
            }
            
            draw() {
                // Draw trail
                ctx.save();
                this.trail.forEach((point, index) => {
                    const screenX = point.x - camera.x + canvas.width / 2;
                    const screenY = point.y - camera.y + canvas.height / 2;
                    
                    ctx.globalAlpha = point.alpha * 0.5;
                    ctx.fillStyle = '#ffffff';
                    const size = (index / this.trail.length) * 3;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main star
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Helper functions
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Smart spawning: bias towards elements that can combine with what snakes are carrying
                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                    // Collect all elements currently carried by snakes
                    const carriedElements = new Set();
                    const carriedElementsList = [];
                    
                    snakes.forEach(snake => {
                        if (snake && snake.alive) {
                            snake.elements.forEach(elem => {
                                carriedElements.add(elem);
                                carriedElementsList.push(elem);
                            });
                        }
                    });
                    
                    // Build weighted spawn list
                    const spawnWeights = new Map();
                    const allElements = window.elementLoader.getAllElements();
                    
                    // 30% chance to prioritize spawning for new discoveries
                    const prioritizeDiscovery = Math.random() < 0.3;
                    
                    // Debug logging
                    console.log(`[SPAWN] Discovered elements: ${discoveredElements.size}, Prioritize discovery: ${prioritizeDiscovery}`);
                    
                    allElements.forEach(element => {
                        let weight = 1; // Base weight
                        
                        // Only spawn discovered elements or base elements
                        if (!discoveredElements.has(element.key) && element.tier > 0) {
                            weight = 0; // Don't spawn undiscovered non-base elements
                        } else {
                            // Tier-based base weight
                            if (element.tier === 0) {
                                weight = 10; // Strong preference for base elements
                            } else if (element.tier === 1) {
                                weight = 3;
                            } else if (element.tier === 2) {
                                weight = 1;
                            } else {
                                weight = 0.3; // Rare for high-tier elements
                            }
                            
                            let hasUndiscoveredCombo = false;
                            
                            // Smart spawning bonus: check if this element can combine with carried elements
                            if (carriedElements.size > 0) {
                                carriedElementsList.forEach(carried => {
                                    // Check if these can combine
                                    const combo = window.elementLoader.getCombinationByKeys(element.key, carried);
                                    if (combo) {
                                        // Check if the result is discovered
                                        if (!discoveredElements.has(combo.key)) {
                                            hasUndiscoveredCombo = true;
                                            if (prioritizeDiscovery) {
                                                weight *= 5; // Huge bonus for potential new discoveries
                                            }
                                        } else {
                                            weight *= 2; // Double weight for known combinations
                                        }
                                    }
                                });
                            }
                            
                            // Additional bonus for elements that can lead to many undiscovered combinations
                            if (prioritizeDiscovery && !hasUndiscoveredCombo) {
                                // Check how many undiscovered combinations this element can create
                                let undiscoveredPotential = 0;
                                allElements.forEach(otherElement => {
                                    if (discoveredElements.has(otherElement.key)) {
                                        const combo = window.elementLoader.getCombinationByKeys(element.key, otherElement.key);
                                        if (combo && !discoveredElements.has(combo.key)) {
                                            undiscoveredPotential++;
                                        }
                                    }
                                });
                                
                                if (undiscoveredPotential > 0) {
                                    weight *= (1 + undiscoveredPotential * 0.5); // Bonus based on discovery potential
                                }
                            }
                        }
                        
                        if (weight > 0) {
                            spawnWeights.set(element.key, weight);
                        }
                    });
                    
                    // Weighted random selection
                    let totalWeight = 0;
                    spawnWeights.forEach(w => totalWeight += w);
                    
                    let rand = Math.random() * totalWeight;
                    let selectedElement = null;
                    
                    for (const [elemKey, weight] of spawnWeights) {
                        rand -= weight;
                        if (rand <= 0) {
                            selectedElement = elemKey;
                            break;
                        }
                    }
                    
                    type = selectedElement || 'fire'; // Fallback to fire if something goes wrong
                    
                    // Debug what was selected
                    if (selectedElement && window.elementLoader) {
                        const elem = window.elementLoader.getElementByKey(selectedElement);
                        if (elem) {
                            console.log(`[SPAWN] Selected: ${elem.name} (Tier ${elem.tier})`);
                        }
                    }
                } else {
                    // Fallback to old system
                    const rand = Math.random();
                    if (rand < 0.7) {
                        // Basic element
                        const basics = ['fire', 'water', 'earth', 'air'];
                        type = basics[Math.floor(Math.random() * basics.length)];
                    } else {
                        // Any discovered element
                        const available = Object.keys(elementDatabase);
                        type = available[Math.floor(Math.random() * available.length)];
                    }
                }
            }
            
            // Random position if not specified
            if (!x || !y) {
                // Try to find a position not too close to snakes
                let attempts = 0;
                const maxAttempts = 20;
                const minDistanceFromSnakes = 150; // Minimum distance from any snake
                
                while (attempts < maxAttempts) {
                    x = 100 + Math.random() * (WORLD_SIZE - 200);
                    y = 100 + Math.random() * (WORLD_SIZE - 200);
                    
                    // Check distance from all snakes
                    let tooClose = false;
                    for (const snake of snakes) {
                        if (snake && snake.alive) {
                            // Check distance to snake head
                            const dist = Math.hypot(snake.x - x, snake.y - y);
                            if (dist < minDistanceFromSnakes) {
                                tooClose = true;
                                break;
                            }
                            
                            // Also check first few segments
                            for (let i = 0; i < Math.min(5, snake.segments.length); i++) {
                                const segment = snake.segments[i];
                                const segDist = Math.hypot(segment.x - x, segment.y - y);
                                if (segDist < minDistanceFromSnakes) {
                                    tooClose = true;
                                    break;
                                }
                            }
                            
                            if (tooClose) break;
                        }
                    }
                    
                    if (!tooClose) {
                        break; // Found a good position
                    }
                    
                    attempts++;
                }
                
                // If we couldn't find a good position after max attempts, use the last one
                if (attempts >= maxAttempts) {
                    console.log('Could not find element spawn position far from snakes after', maxAttempts, 'attempts');
                }
            }
            
            elementPool.spawn(type, x, y);
        }
        
        function createCombinationParticles(x, y) {
            const particleCount = isMobile ? 10 : 20; // Reduced for mobile
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particlePool.spawn(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    `hsl(${Math.random() * 360}, 70%, 50%)`
                );
            }
        }
        
        function createDeathParticles(x, y, snakeLength = 5) {
            // Scale particle count and speed based on snake size
            const baseParticles = isMobile ? 10 : 20;
            const particleCount = Math.min(baseParticles + Math.floor(snakeLength / (isMobile ? 4 : 2)), isMobile ? 30 : 100); // Reduced for mobile
            const speedMultiplier = 1 + (snakeLength / 50); // Bigger snakes = faster explosion
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * speedMultiplier;
                particlePool.spawn(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    '#ff0000'
                );
            }
            
            // Add some larger, slower particles for bigger snakes
            if (snakeLength > 20) {
                const largeParticleCount = Math.min(Math.floor(snakeLength / 10), 20);
                for (let i = 0; i < largeParticleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 3 + 1) * speedMultiplier;
                    particlePool.spawn(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#ff6600'
                    );
                }
            }
        }
        
        function showCombinationMessage(elem1, elem2, result, isNew) {
            // Get element data from new system first, fallback to old
            let elem1Data, elem2Data, resultData;
            
            if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                elem1Data = window.elementLoader.getElementByKey(elem1) || elementDatabase[elem1];
                elem2Data = window.elementLoader.getElementByKey(elem2) || elementDatabase[elem2];
                resultData = window.elementLoader.getElementByKey(result) || elementDatabase[result];
                
                // Ensure proper format for new element system
                if (elem1Data && !elem1Data.emoji) elem1Data = elementDatabase[elem1];
                if (elem2Data && !elem2Data.emoji) elem2Data = elementDatabase[elem2];
                if (resultData && !resultData.emoji) resultData = elementDatabase[result];
            } else {
                elem1Data = elementDatabase[elem1];
                elem2Data = elementDatabase[elem2];
                resultData = elementDatabase[result];
            }
            
            let message = `${elem1Data.emoji} + ${elem2Data.emoji} = ${resultData.emoji} ${resultData.name}`;
            if (isNew) {
                message = `New Discovery! ${message}`;
                // Update discovery log for new discoveries
                lastDiscoveredElement = result;
                updateDiscoveryLog();
                // Add to discovery feed
                console.log('[DEBUG] Adding to discovery feed:', resultData.name);
                addDiscoveryToFeed(resultData, `${elem1Data.emoji} ${elem1Data.name} + ${elem2Data.emoji} ${elem2Data.name}`);
            } else {
                message = `Combo! ${message}`;
            }
            
            showMessage(message, isNew);
        }
        
        function showMessage(text, isDiscovery) {
            const popup = document.getElementById('recentDiscovery');
            popup.innerHTML = text;
            popup.className = isDiscovery ? 'show' : 'show combo';
            popup.style.opacity = '1';
            
            // Clear any existing timeout
            if (popup.hideTimeout) {
                clearTimeout(popup.hideTimeout);
            }
            
            // Set new timeout
            popup.hideTimeout = setTimeout(() => {
                popup.style.opacity = '0';
                popup.className = '';
            }, 3000);
        }
        
        // Victory popup function
        function showVictoryScreen(type, target) {
            const overlay = document.getElementById('victoryOverlay');
            const scoreDisplay = document.getElementById('victoryScore');
            const discoveryDisplay = document.getElementById('victoryDiscoveries');
            const timeDisplay = document.getElementById('victoryTime');
            const loreDisplay = document.getElementById('victoryLore');
            
            // Calculate game time
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            // Set stats
            scoreDisplay.textContent = playerSnake.score.toLocaleString();
            const discoveryCount = discoveredElements.size;
            discoveryDisplay.textContent = `${discoveryCount}`;
            timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Set lore message based on victory type
            const loreMessages = {
                discovery: [
                    `You have mastered the art of elemental fusion, discovering ${target} unique combinations. The universe bows to your alchemical prowess!`,
                    `Through countless experiments, you've unlocked ${target} elemental secrets. Your name shall be etched in the annals of discovery!`,
                    `The elements themselves whisper your name. ${target} discoveries mark you as a true Alchemist of the Infinite!`
                ],
                points: [
                    `With ${playerSnake.score.toLocaleString()} points, you've proven your mastery over the elemental realm. The serpent of infinity coils in reverence!`,
                    `Your score of ${playerSnake.score.toLocaleString()} echoes through the void. You are the undisputed champion of the elemental dance!`,
                    `${playerSnake.score.toLocaleString()} points! The very fabric of reality trembles at your achievement. You are legend incarnate!`
                ]
            };
            
            const messages = loreMessages[type] || [`Victory achieved with ${playerSnake.score.toLocaleString()} points!`];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            loreDisplay.textContent = randomMessage;
            
            // Show overlay
            overlay.style.display = 'flex';
            gameRunning = false;
            
            // Play victory sound if available
            if (eatSounds.length > 0 && !musicMuted) {
                const sound = eatSounds[0];
                sound.currentTime = 0;
                sound.volume = 0.75;
                sound.play().catch(e => console.log('Could not play victory sound'));
            }
        }
        
        // Add discovery to the feed (MMO chat-style)
        function addDiscoveryToFeed(element, recipe) {
            const feed = document.getElementById('discoveryFeed');
            if (!feed) {
                console.error('Discovery feed element not found!');
                return;
            }
            
            // Debug: Make sure feed is visible
            const feedContainer = document.querySelector('.discovery-feed');
            if (feedContainer) {
                feedContainer.style.display = 'flex';
                feedContainer.style.opacity = '1';
                feedContainer.style.visibility = 'visible';
            }
            
            const message = document.createElement('div');
            message.className = 'discovery-message';
            
            // Recipe is passed as parameter now
            let recipeText = recipe || '';
            
            message.innerHTML = `
                <span class="emoji">${element.emoji}</span>
                <div class="discovery-text">
                    <div class="discovery-name">${element.name}</div>
                    ${recipeText ? `<div class="discovery-combo">${recipeText}</div>` : ''}
                </div>
            `;
            
            feed.appendChild(message);
            
            // Auto-scroll to bottom
            feed.scrollTop = feed.scrollHeight;
            
            // Limit messages to prevent memory issues
            while (feed.children.length > 20) {
                feed.removeChild(feed.firstChild);
            }
            
            console.log('Added to discovery feed:', element.name, 'Recipe:', recipeText);
            console.log('Feed now has', feed.children.length, 'messages');
            console.log('Feed container display:', feedContainer ? getComputedStyle(feedContainer).display : 'not found');
        }
        
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            
            // Sort snakes based on game mode
            let sortedSnakes = [...snakes].filter(s => s.alive);
            
            if (gameMode === 'discovery') {
                // Sort by discoveries, then by score
                sortedSnakes.sort((a, b) => {
                    if (b.discoveries !== a.discoveries) {
                        return b.discoveries - a.discoveries;
                    }
                    return b.score - a.score;
                });
            } else {
                // Sort by score
                sortedSnakes.sort((a, b) => b.score - a.score);
            }
            
            // Mark the leader
            snakes.forEach(s => s.isLeader = false);
            if (sortedSnakes.length > 0) {
                sortedSnakes[0].isLeader = true;
            }
            
            // Display top 5 with MMO-style formatting
            leaderboardList.innerHTML = '';
            sortedSnakes.slice(0, 5).forEach((snake, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                
                if (index === 0) {
                    div.classList.add('leader');
                }
                if (snake.isPlayer) {
                    div.classList.add('player');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                
                // Handle colored personality names for AI snakes
                if (!snake.isPlayer && snake.personality) {
                    // Add crown for leader
                    if (index === 0) {
                        const crownSpan = document.createElement('span');
                        crownSpan.textContent = '👑 ';
                        nameSpan.appendChild(crownSpan);
                    }
                    
                    // Split name into personality and actual name
                    const personalityName = snake.personality.name + ' ';
                    const actualName = snake.name.substring(personalityName.length);
                    
                    // Create colored personality span
                    const personalitySpan = document.createElement('span');
                    personalitySpan.style.color = snake.personalityColor;
                    personalitySpan.style.fontWeight = 'bold';
                    personalitySpan.textContent = personalityName;
                    
                    // Create white name span
                    const actualNameSpan = document.createElement('span');
                    actualNameSpan.style.color = '#ffffff';
                    actualNameSpan.textContent = actualName;
                    
                    nameSpan.appendChild(personalitySpan);
                    nameSpan.appendChild(actualNameSpan);
                } else {
                    // Player or fallback - normal display
                    nameSpan.textContent = (index === 0 ? '👑 ' : '') + snake.name;
                }
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'leaderboard-stats';
                statsDiv.innerHTML = `
                    <div>${Math.floor(snake.score).toLocaleString()} pts</div>
                    <div>${snake.discoveries || 0} discoveries</div>
                `;
                
                div.appendChild(nameSpan);
                div.appendChild(statsDiv);
                leaderboardList.appendChild(div);
            });
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            // Get all discovered elements and sort by tier (highest first)
            const discovered = Array.from(discoveredElements)
                .map(key => {
                    // Try new system first
                    if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                        const element = window.elementLoader.getElementByKey(key);
                        if (element) return { key, element };
                    }
                    // Fallback to old system
                    const element = elementDatabase[key];
                    if (element) return { key, element };
                    return null;
                })
                .filter(item => item !== null)
                .sort((a, b) => {
                    // Sort by tier descending, then alphabetically
                    if (b.element.tier !== a.element.tier) {
                        return b.element.tier - a.element.tier;
                    }
                    return a.element.name.localeCompare(b.element.name);
                });
            
            discovered.forEach(({ key, element }) => {
                const div = document.createElement('div');
                div.className = 'discovery-item';
                
                // Highlight if this is the newest discovery
                if (key === lastDiscoveredElement) {
                    div.classList.add('new');
                }
                
                div.innerHTML = `
                    <div class="emoji">${element.emoji}</div>
                    <div class="info">
                        <div class="name">${element.name}</div>
                        <div class="tier">Tier ${element.tier}</div>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update count in header
            const header = document.querySelector('#discoveryLog h3');
            if (header) {
                header.textContent = `Discoveries (${discovered.length})`;
            }
        }
        
        // Update boost bar separately for real-time updates
        function updateBoostBar() {
            if (!playerSnake) return;
            
            const boostFill = document.getElementById('boostBarFill');
            if (!boostFill) return;
            
            // Calculate stamina percentage
            const staminaPercent = Math.max(0, Math.min(100, (playerSnake.stamina / playerSnake.maxStamina) * 100));
            
            // Force immediate style update
            boostFill.style.width = staminaPercent + '%';
            
            // Force browser to recalculate styles
            boostFill.offsetWidth;
            
            // Change color based on stamina level
            if (staminaPercent <= 20) {
                boostFill.className = 'boost-bar-fill low';
            } else if (playerSnake.isBoosting) {
                boostFill.className = 'boost-bar-fill boosting';
            } else {
                boostFill.className = 'boost-bar-fill';
            }
        }
        
        function updateUI() {
            if (!playerSnake) return;
            
            // Handle dead player with respawn timer
            if (!playerSnake.alive && playerRespawnTimer > 0) {
                const respawnSeconds = Math.ceil(playerRespawnTimer / 1000);
                
                // Show respawn overlay
                const respawnOverlay = document.getElementById('respawnOverlay');
                if (respawnOverlay) {
                    respawnOverlay.style.display = 'block';
                    
                    // Update respawn stats
                    document.getElementById('respawnScore').textContent = Math.floor(playerSnake.score).toLocaleString();
                    document.getElementById('respawnDiscoveries').textContent = playerSnake.discoveries;
                    document.getElementById('respawnRank').textContent = '#' + (bestRank || 1);
                    document.getElementById('respawnKills').textContent = playerSnake.kills;
                    document.getElementById('respawnTimer').textContent = respawnSeconds;
                }
                
                return; // Don't update other UI elements while dead
            } else {
                // Hide respawn overlay when alive
                const respawnOverlay = document.getElementById('respawnOverlay');
                if (respawnOverlay) {
                    respawnOverlay.style.display = 'none';
                }
            }
            
            // Update player info box
            document.getElementById('playerScore').textContent = Math.floor(playerSnake.score).toLocaleString();
            
            // Update discoveries count
            const discoveryCount = discoveredElements.size;
            document.getElementById('playerDiscoveries').textContent = discoveryCount;
            
            // Update high score display if current score is higher
            if (playerSnake.score > highScore) {
                highScore = playerSnake.score;
                localStorage.setItem('highScore', Math.floor(highScore).toString());
            }
            
            // Update game time
            const gameTime = Date.now() - gameStartTime;
            const minutes = Math.floor(gameTime / 60000);
            const seconds = Math.floor((gameTime % 60000) / 1000);
            document.getElementById('playerTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update best rank (only after 60 seconds to make it meaningful)
            const bestRankElement = document.getElementById('playerBestRank');
            if (gameTime >= 60000) { // 60 seconds
                const playerRank = snakes.filter(s => s.alive).findIndex(s => s === playerSnake) + 1;
                if (playerRank > 0 && (bestRank === 0 || playerRank < bestRank)) {
                    bestRank = playerRank;
                    bestRankElement.textContent = `#${bestRank}`;
                }
            } else {
                // Show placeholder before 60 seconds
                bestRankElement.textContent = '-';
            }
            
            // Update kills
            document.getElementById('playerKills').textContent = playerSnake.kills;
            
            // Update AlchemyVision timer
            const timerElement = document.getElementById('alchemyVisionTimer');
            if (alchemyVisionActive && alchemyVisionTimer > 0) {
                timerElement.style.display = 'block';
                const seconds = Math.ceil(alchemyVisionTimer / 1000);
                document.getElementById('alchemyTime').textContent = seconds;
            } else {
                timerElement.style.display = 'none';
            }
            
            // Update boost bar
            updateBoostBar();
            
            // Check victory condition (only once)
            if (!gameWon) {
                if (gameMode === 'discovery' && discoveryCount >= gameTarget) {
                    gameWon = true;
                    showVictoryScreen('discovery', gameTarget);
                } else if (gameMode === 'points' && playerSnake.score >= gameTarget) {
                    gameWon = true;
                    showVictoryScreen('points', gameTarget);
                }
            }
            
            // Update leaderboard
            updateLeaderboard();
            
            // Update element collection bar (MMO skill bar style)
            const elementBar = document.getElementById('elementBar');
            elementBar.innerHTML = '';
            
            // Check if we're animating a combination
            const isCombining = playerSnake.isAnimatingCombination && playerSnake.combiningIndices;
            
            // Create slots for the fixed 6 slots
            for (let i = 0; i < playerSnake.maxVisibleElements; i++) {
                const div = document.createElement('div');
                div.className = 'element-slot';
                
                if (i < playerSnake.elements.length) {
                    // Filled slot with element
                    const elementType = playerSnake.elements[i];
                    const element = elementDatabase[elementType];
                    if (element) {
                        div.classList.add('filled');
                        
                        // Highlight the active element
                        if (i === playerSnake.highlightedIndex) {
                            div.classList.add('highlighted-element');
                        }
                        
                        // Add combination animation classes
                        if (isCombining) {
                            if (playerSnake.combiningIndices.includes(i)) {
                                div.classList.add('combining');
                                
                                // Add particle effects
                                const particleContainer = document.createElement('div');
                                particleContainer.className = 'combination-particles';
                                
                                // Create multiple particles
                                for (let p = 0; p < 8; p++) {
                                    const particle = document.createElement('div');
                                    particle.className = 'combination-particle';
                                    const angle = (p / 8) * Math.PI * 2;
                                    const distance = 30;
                                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                                    particle.style.animationDelay = `${p * 0.05}s`;
                                    particleContainer.appendChild(particle);
                                }
                                
                                div.appendChild(particleContainer);
                            }
                        }
                        
                        // Check if this is a newly created element
                        if (combinationAnimationState.isAnimating && i === combinationAnimationState.newElementIndex) {
                            div.classList.add('new-element');
                        }
                        
                        div.innerHTML += `<div class="emoji">${element.emoji}</div><div class="element-name">${element.name}</div>`;
                        div.title = element.name;
                    }
                } else {
                    // Empty slot
                    div.classList.add('empty');
                }
                
                elementBar.appendChild(div);
            }
            
            // Reset animation state after animation completes
            if (combinationAnimationState.isAnimating && Date.now() - combinationAnimationState.animationStartTime > 600) {
                combinationAnimationState.isAnimating = false;
                combinationAnimationState.combiningIndices = [];
                combinationAnimationState.newElementIndex = -1;
                playerSnake.isAnimatingCombination = false;
                playerSnake.combiningIndices = null;
            }
        }
        
        function checkCollisions() {
            for (const snake of snakes) {
                if (!snake.alive) continue;
                
                // Check element collisions
                const activeElements = elementPool.getActiveElements();
                for (const element of activeElements) {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + ELEMENT_SIZE) {
                        snake.consume(element);
                    }
                }
                
                // Check AlchemyVision power-up collision (player only)
                if (snake.isPlayer) {
                    for (let i = alchemyVisionPowerUps.length - 1; i >= 0; i--) {
                        const powerUp = alchemyVisionPowerUps[i];
                        const dist = Math.hypot(powerUp.x - snake.x, powerUp.y - snake.y);
                        if (dist < SEGMENT_SIZE + powerUp.size) {
                            // Activate Alchemy Vision
                            alchemyVisionActive = true;
                            alchemyVisionTimer = ALCHEMY_VISION_DURATION;
                            
                            // Remove collected power-up
                            alchemyVisionPowerUps.splice(i, 1);
                            
                            // Play alchemy vision sound (always player since only player can collect)
                            playAlchemyVisionSound(true);
                            
                            // Show notification
                            showMessage('🔮 Alchemy Vision Activated! 30s<br><small style="opacity: 0.8">Your eyes are opened to see all combinations</small>', 'success');
                            break; // Only collect one at a time
                        }
                    }
                }
                
                // Check Void Orb collision (all snakes can collect)
                for (let i = voidOrbs.length - 1; i >= 0; i--) {
                    const orb = voidOrbs[i];
                    const dist = Math.hypot(orb.x - snake.x, orb.y - snake.y);
                    if (dist < SEGMENT_SIZE + orb.size) {
                        // Consume the void orb
                        if (snake.elements.length > 0) {
                            const elementCount = snake.elements.length;
                            const points = elementCount * 100;
                            snake.score += points;
                            snake.elements = []; // Clear all elements
                            
                            // Visual feedback
                            if (snake.isPlayer) {
                                showMessage(`🌀 Void Orb consumed! +${points} points<br><small style="opacity: 0.8">Your elements have been purged to the void</small>`, 'info');
                            }
                            
                            // Play sound at appropriate volume
                            playVoidOrbSound(snake.isPlayer);
                            
                            // Create particle effect
                            for (let j = 0; j < 15; j++) {
                                const angle = (j / 15) * Math.PI * 2;
                                const speed = 2 + Math.random() * 3;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(orb.x, orb.y, vx, vy, 'rgba(100, 200, 255, 0.8)');
                            }
                            
                            // 50% chance to spawn a discovery element
                            if (Math.random() < 0.5) {
                                console.log('[VOID ORB] Attempting to spawn element...');
                                
                                // Get all available elements
                                let availableElements = [];
                                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                                    // Get all elements and extract their keys
                                    const allElements = window.elementLoader.getAllElements();
                                    availableElements = allElements.map(elem => elem.key);
                                    console.log('[VOID ORB] Using element loader, found', availableElements.length, 'total elements');
                                } else {
                                    availableElements = Object.keys(elementDatabase);
                                    console.log('[VOID ORB] Using legacy database, found', availableElements.length, 'total elements');
                                }
                                
                                // Filter to only discovered elements (except base elements which are always available)
                                const spawnableElements = availableElements.filter(elemKey => {
                                    // Always allow base elements (first 4)
                                    const elemIndex = availableElements.indexOf(elemKey);
                                    if (elemIndex < 4) return true;
                                    
                                    // For other elements, only spawn if discovered
                                    return discoveredElements.has(elemKey);
                                });
                                
                                // Prioritize elements that can lead to new discoveries
                                const discoveryPotentialElements = spawnableElements.filter(elemKey => {
                                    // Check if this element can combine with carried elements for new discoveries
                                    let hasDiscoveryPotential = false;
                                    snake.elements.forEach(carried => {
                                        const result = window.elementLoader ? 
                                            window.elementLoader.getCombinationByKeys(elemKey, carried) :
                                            (combinations[`${elemKey}+${carried}`] || combinations[`${carried}+${elemKey}`]);
                                        if (result && !discoveredElements.has(result.key || result)) {
                                            hasDiscoveryPotential = true;
                                        }
                                    });
                                    return hasDiscoveryPotential;
                                });
                                
                                // Use discovery potential elements if available, otherwise use any spawnable element
                                const finalPool = discoveryPotentialElements.length > 0 ? discoveryPotentialElements : spawnableElements;
                                
                                console.log('[VOID ORB] Spawnable elements:', spawnableElements.length, 'Discovery potential:', discoveryPotentialElements.length, 'Final pool:', finalPool.length);
                                
                                if (finalPool.length > 0) {
                                    // Pick a random element
                                    const randomElement = finalPool[Math.floor(Math.random() * finalPool.length)];
                                    console.log('[VOID ORB] Selected element to spawn:', randomElement);
                                    
                                    // Spawn it at a random location near the void orb
                                    const spawnAngle = Math.random() * Math.PI * 2;
                                    const spawnDistance = 50 + Math.random() * 100;
                                    const spawnX = orb.x + Math.cos(spawnAngle) * spawnDistance;
                                    const spawnY = orb.y + Math.sin(spawnAngle) * spawnDistance;
                                    
                                    // Spawn the element with glow effect (using isCatalystSpawned for glow)
                                    const newElement = elementPool.spawn(randomElement, spawnX, spawnY, true);
                                    elements.push(newElement);
                                    
                                    // Show message if player collected the orb
                                    if (snake.isPlayer) {
                                        const elementData = window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded() 
                                            ? window.elementLoader.getElementByKey(randomElement)
                                            : elementDatabase[randomElement];
                                        if (elementData) {
                                            showMessage(`✨ The void reveals: ${elementData.emoji} ${elementData.name}!`, 'discovery');
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Remove void orb
                        voidOrbs.splice(i, 1);
                        break;
                    }
                }
                
                // Check Catalyst Gem collision (all snakes can collect)
                for (let i = catalystGems.length - 1; i >= 0; i--) {
                    const gem = catalystGems[i];
                    const dist = Math.hypot(gem.x - snake.x, gem.y - snake.y);
                    if (dist < SEGMENT_SIZE + gem.size) {
                        // Only activate if snake has elements
                        if (snake.elements.length > 0) {
                            // Determine which elements to check for combinations
                            let elementsToCheck = [];
                            
                            if (snake.elements.length === 1) {
                                // If player has only 1 element, use it 4 times
                                elementsToCheck = Array(4).fill(snake.elements[0]);
                            } else if (snake.elements.length <= 4) {
                                // If player has 2-4 elements, use all of them
                                elementsToCheck = [...snake.elements];
                            } else {
                                // If player has more than 4 elements, randomly select 4
                                const shuffled = [...snake.elements].sort(() => Math.random() - 0.5);
                                elementsToCheck = shuffled.slice(0, 4);
                            }
                            
                            console.log('[CATALYST GEM] Checking elements:', elementsToCheck);
                            
                            // Find all compatible elements for each element we're checking
                            const allCompatibleElements = [];
                            const compatibleByElement = {};
                            
                            for (const element of elementsToCheck) {
                                compatibleByElement[element] = [];
                                
                                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                                    // Use new element loader system
                                    const allElements = window.elementLoader.getAllElements();
                                    
                                    for (const otherElement of allElements) {
                                        // Skip if not discovered (except base elements)
                                        if (otherElement.tier > 0 && !discoveredElements.has(otherElement.key)) {
                                            continue;
                                        }
                                        
                                        const result = window.elementLoader.getCombinationByKeys(element, otherElement.key);
                                        if (result) {
                                            compatibleByElement[element].push({
                                                element: otherElement.key,
                                                result: result.key,
                                                combo: `${element}+${otherElement.key}`
                                            });
                                            allCompatibleElements.push({
                                                element: otherElement.key,
                                                result: result.key,
                                                combo: `${element}+${otherElement.key}`,
                                                baseElement: element
                                            });
                                        }
                                    }
                                } else {
                                    // Fallback to old system
                                    for (const [combo, result] of Object.entries(combinations)) {
                                        const [elem1, elem2] = combo.split('+');
                                        if (elem1 === element) {
                                            compatibleByElement[element].push({
                                                element: elem2,
                                                result: result,
                                                combo: combo
                                            });
                                            allCompatibleElements.push({
                                                element: elem2,
                                                result: result,
                                                combo: combo,
                                                baseElement: element
                                            });
                                        }
                                    }
                                }
                            }
                            
                            console.log('[CATALYST GEM] Found', allCompatibleElements.length, 'compatible elements');
                            
                            // Continue with the rest of the logic for spawning elements
                            if (allCompatibleElements.length > 0 && snake.isPlayer) {
                                // Try to prioritize combinations that would create new discoveries
                                const undiscoveredCombos = allCompatibleElements.filter(item => {
                                    // Check if this combination would result in a new discovery
                                    return !discoveredElements.has(item.result);
                                });
                                
                                // Use undiscovered combinations if available, otherwise use all compatible
                                const prioritizedElements = undiscoveredCombos.length > 0 ? undiscoveredCombos : allCompatibleElements;
                                
                                const elementsToSpawn = [];
                                const spawnCount = Math.min(4, allCompatibleElements.length);
                                
                                // If we have undiscovered combinations, prioritize at least one
                                if (undiscoveredCombos.length > 0 && elementsToSpawn.length === 0) {
                                    const randomUndiscovered = undiscoveredCombos[Math.floor(Math.random() * undiscoveredCombos.length)];
                                    elementsToSpawn.push(randomUndiscovered.element);
                                }
                                
                                // If we have elements for different base elements, try to get one for each
                                if (elementsToCheck.length > 1) {
                                    const uniqueBaseElements = [...new Set(elementsToCheck)];
                                    for (const baseElement of uniqueBaseElements) {
                                        if (elementsToSpawn.length >= spawnCount) break;
                                        
                                        // First try to find undiscovered combinations for this base element
                                        const undiscoveredForBase = prioritizedElements.filter(item => 
                                            item.baseElement === baseElement
                                        );
                                        
                                        if (undiscoveredForBase.length > 0) {
                                            const randomUndiscovered = undiscoveredForBase[Math.floor(Math.random() * undiscoveredForBase.length)];
                                            if (!elementsToSpawn.includes(randomUndiscovered.element)) {
                                                elementsToSpawn.push(randomUndiscovered.element);
                                            }
                                        } else {
                                            // Fall back to any compatible element for this base
                                            const compatible = compatibleByElement[baseElement];
                                            if (compatible.length > 0) {
                                                const randomCompatible = compatible[Math.floor(Math.random() * compatible.length)];
                                                if (!elementsToSpawn.includes(randomCompatible.element)) {
                                                    elementsToSpawn.push(randomCompatible.element);
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                // Fill remaining slots with prioritized elements (undiscovered if available)
                                while (elementsToSpawn.length < spawnCount && prioritizedElements.length > 0) {
                                    const remainingElements = prioritizedElements.filter(item => 
                                        !elementsToSpawn.includes(item.element)
                                    );
                                    
                                    if (remainingElements.length > 0) {
                                        const randomItem = remainingElements[Math.floor(Math.random() * remainingElements.length)];
                                        elementsToSpawn.push(randomItem.element);
                                    } else {
                                        break;
                                    }
                                }
                                
                                console.log('[CATALYST GEM] Spawning', elementsToSpawn.length, 'elements:', elementsToSpawn);
                                
                                // Spawn the elements around the player
                                for (let j = 0; j < elementsToSpawn.length; j++) {
                                    const angle = (j / elementsToSpawn.length) * Math.PI * 2;
                                    const distance = 100 + Math.random() * 100;
                                    const spawnX = snake.x + Math.cos(angle) * distance;
                                    const spawnY = snake.y + Math.sin(angle) * distance;
                                    
                                    // Create the element with catalyst sparkle effect
                                    const newElement = elementPool.spawn(elementsToSpawn[j], spawnX, spawnY, true);
                                    elements.push(newElement); // Add to the game's elements array
                                }
                                
                                showMessage(`💎 Catalyst Gem activated! Spawned ${elementsToSpawn.length} compatible elements<br><small style="opacity: 0.8">New elements have resonated into existence</small>`, 'success');
                            } else if (allCompatibleElements.length > 0 && !snake.isPlayer) {
                                // AI snakes get points instead
                                snake.score += 200;
                            }
                            
                            // Play catalyst gem sound at appropriate volume
                            playCatalystGemSound(snake.isPlayer);
                            
                            // Create particle effect
                            for (let j = 0; j < 20; j++) {
                                const angle = (j / 20) * Math.PI * 2;
                                const speed = 3 + Math.random() * 4;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(gem.x, gem.y, vx, vy, 'rgba(255, 165, 0, 0.8)');
                            }
                        }
                        
                        // Remove catalyst gem
                        catalystGems.splice(i, 1);
                        break;
                    }
                }
                
                // Check snake collisions (skip if invincible)
                if (snake.invincibilityTimer > 0) continue;
                
                for (const otherSnake of snakes) {
                    if (snake === otherSnake || !otherSnake.alive) continue;
                    
                    // Check head collision with other snake's body
                    let collisionOccurred = false;
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        if (dist < SEGMENT_SIZE) {
                            // Track collision for near-miss prevention
                            if (snake.isPlayer) {
                                snake.recentCollisions.add(otherSnake);
                            }
                            if (otherSnake.isPlayer) {
                                otherSnake.recentCollisions.add(snake);
                            }
                            snake.explode(otherSnake);
                            collisionOccurred = true;
                            break;
                        }
                    }
                    
                    // Check head-to-head collision
                    if (snake.alive && otherSnake.alive) {
                        const headDist = Math.hypot(otherSnake.x - snake.x, otherSnake.y - snake.y);
                        if (headDist < SEGMENT_SIZE) {
                            // Smaller snake explodes, or both if same size
                            if (snake.length < otherSnake.length) {
                                snake.explode(otherSnake);
                            } else if (otherSnake.length < snake.length) {
                                otherSnake.explode(snake);
                            } else {
                                // Same size - both explode, no points awarded
                                snake.die();
                                otherSnake.die();
                            }
                        }
                    }
                }
            }
            
            // Near-miss detection (only for player snake, runs separately from collision)
            if (playerSnake && playerSnake.alive) {
                const now = Date.now();
                
                // Clean up old collision records
                for (const snake of playerSnake.recentCollisions) {
                    if (!snake.alive) {
                        playerSnake.recentCollisions.delete(snake);
                    }
                }
                
                for (const otherSnake of snakes) {
                    if (otherSnake === playerSnake || !otherSnake.alive) continue;
                    
                    // Skip if we recently collided with this snake
                    if (playerSnake.recentCollisions.has(otherSnake)) continue;
                    
                    // Calculate closest distance to any part of the other snake
                    let closestDistance = Infinity;
                    
                    // Check body segments
                    for (let i = 0; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - playerSnake.x, segment.y - playerSnake.y);
                        closestDistance = Math.min(closestDistance, dist);
                    }
                    
                    // Check head separately
                    const headDist = Math.hypot(otherSnake.x - playerSnake.x, otherSnake.y - playerSnake.y);
                    closestDistance = Math.min(closestDistance, headDist);
                    
                    // Get previous tracking data
                    const trackingData = playerSnake.nearMissTracking.get(otherSnake) || {
                        wasClose: false,
                        lastAwardTime: 0,
                        minDistance: Infinity
                    };
                    
                    // Update minimum distance seen
                    trackingData.minDistance = Math.min(trackingData.minDistance, closestDistance);
                    
                    // Define near-miss zone
                    const isClose = closestDistance <= SEGMENT_SIZE + 30; // Within 45 pixels
                    const isSafe = closestDistance > SEGMENT_SIZE + 10; // At least 25 pixels away (no collision)
                    
                    // Detect near miss: was close, now moving away, and didn't collide
                    if (trackingData.wasClose && !isClose && isSafe && 
                        trackingData.minDistance > SEGMENT_SIZE && // Never got closer than collision distance
                        trackingData.minDistance <= SEGMENT_SIZE + 20 && // But got pretty close
                        now - trackingData.lastAwardTime > 3000) { // 3 second cooldown per snake
                        
                        // Award near miss points
                        playerSnake.score += 50;
                        showMessage('Phew, Near Miss! +50', 'info');
                        trackingData.lastAwardTime = now;
                        trackingData.minDistance = Infinity; // Reset for next near miss
                    }
                    
                    // Update tracking state
                    trackingData.wasClose = isClose;
                    if (!isClose) {
                        trackingData.minDistance = Infinity; // Reset when we move away
                    }
                    
                    playerSnake.nearMissTracking.set(otherSnake, trackingData);
                }
                
                // Clean up tracking for dead snakes
                for (const [snake, data] of playerSnake.nearMissTracking) {
                    if (!snake.alive) {
                        playerSnake.nearMissTracking.delete(snake);
                    }
                }
            }
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw static stars (before grid so they appear behind)
            ctx.save();
            staticStars.forEach(star => {
                const screenX = star.x - camera.x + canvas.width / 2;
                const screenY = star.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen
                if (screenX < -10 || screenX > canvas.width + 10 ||
                    screenY < -10 || screenY > canvas.height + 10) return;
                
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // Draw shooting stars
            shootingStars.forEach(star => star.draw());
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw world borders with nebula effect
            const borderThickness = 80; // Increased for better visibility
            const leftBorder = -camera.x + canvas.width / 2;
            const rightBorder = WORLD_SIZE - camera.x + canvas.width / 2;
            const topBorder = -camera.y + canvas.height / 2;
            const bottomBorder = WORLD_SIZE - camera.y + canvas.height / 2;
            
            // Pulsating glow intensity (increased base intensity)
            const glowIntensity = 0.9 + Math.sin(animationTime * 2) * 0.1;
            
            // Create nebula gradient function
            function createNebulaGradient(x0, y0, x1, y1) {
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, `rgba(147, 51, 234, ${glowIntensity})`); // purple
                gradient.addColorStop(0.3, `rgba(236, 72, 153, ${glowIntensity * 0.8})`); // pink
                gradient.addColorStop(0.6, `rgba(59, 130, 246, ${glowIntensity * 0.6})`); // blue
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // fade to transparent
                return gradient;
            }
            
            // Left border nebula
            if (leftBorder > -borderThickness) {
                const borderWidth = Math.max(borderThickness, leftBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, borderWidth, 0);
                ctx.fillRect(0, 0, borderWidth, canvas.height);
                
                // Add solid danger line
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                ctx.strokeStyle = `rgba(255, 100, 100, ${glowIntensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(Math.max(10, leftBorder), 0);
                ctx.lineTo(Math.max(10, leftBorder), canvas.height);
                ctx.stroke();
                
                // Add inner danger line
                ctx.strokeStyle = `rgba(255, 200, 200, ${glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(Math.max(10, leftBorder), 0);
                ctx.lineTo(Math.max(10, leftBorder), canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Right border nebula
            if (rightBorder < canvas.width + borderThickness) {
                ctx.fillStyle = createNebulaGradient(canvas.width, 0, rightBorder, 0);
                ctx.fillRect(rightBorder, 0, canvas.width - rightBorder, canvas.height);
                
                // Add solid danger line
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                ctx.strokeStyle = `rgba(255, 100, 100, ${glowIntensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(rightBorder, 0);
                ctx.lineTo(rightBorder, canvas.height);
                ctx.stroke();
                
                // Add inner danger line
                ctx.strokeStyle = `rgba(255, 200, 200, ${glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rightBorder, 0);
                ctx.lineTo(rightBorder, canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Top border nebula
            if (topBorder > -borderThickness) {
                const borderHeight = Math.max(borderThickness, topBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, 0, borderHeight);
                ctx.fillRect(0, 0, canvas.width, borderHeight);
                
                // Add solid danger line
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                ctx.strokeStyle = `rgba(255, 100, 100, ${glowIntensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, Math.max(10, topBorder));
                ctx.lineTo(canvas.width, Math.max(10, topBorder));
                ctx.stroke();
                
                // Add inner danger line
                ctx.strokeStyle = `rgba(255, 200, 200, ${glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, Math.max(10, topBorder));
                ctx.lineTo(canvas.width, Math.max(10, topBorder));
                ctx.stroke();
                ctx.restore();
            }
            
            // Bottom border nebula
            if (bottomBorder < canvas.height + borderThickness) {
                ctx.fillStyle = createNebulaGradient(0, canvas.height, 0, bottomBorder);
                ctx.fillRect(0, bottomBorder, canvas.width, canvas.height - bottomBorder);
                
                // Add solid danger line
                ctx.save();
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                ctx.strokeStyle = `rgba(255, 100, 100, ${glowIntensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, bottomBorder);
                ctx.lineTo(canvas.width, bottomBorder);
                ctx.stroke();
                
                // Add inner danger line
                ctx.strokeStyle = `rgba(255, 200, 200, ${glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, bottomBorder);
                ctx.lineTo(canvas.width, bottomBorder);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw border particles
            borderParticles.forEach(particle => {
                // Only draw particles that are visible on screen
                if (particle.edge === 'left' && leftBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'right' && rightBorder < canvas.width + borderThickness + 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'top' && topBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'bottom' && bottomBorder < canvas.height + borderThickness + 20) {
                    particle.draw(ctx);
                }
            });
        }
        
        // Game functions
        function initializeStaticStars() {
            staticStars = [];
            // Reduce stars on mobile for better performance
            const starCount = isMobile ? 50 : 200; // Much fewer stars on mobile
            
            for (let i = 0; i < starCount; i++) {
                staticStars.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: Math.random() * 2 + 1, // 1-3px
                    opacity: Math.random() * 0.2 + 0.1, // 0.1-0.3 opacity
                    color: Math.random() > 0.5 ? '#ffffff' : '#e0e8ff' // white or pale blue
                });
            }
        }
        
        function initializeBorderParticles() {
            borderParticles = [];
            
            // Create particles along each border
            const particleSpacing = 30;
            
            // Left border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(Math.random() * 30, y, 'left'));
                }
            }
            
            // Right border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(canvas.width - Math.random() * 30, y, 'right'));
                }
            }
            
            // Top border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, Math.random() * 30, 'top'));
                }
            }
            
            // Bottom border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, canvas.height - Math.random() * 30, 'bottom'));
                }
            }
        }
        
        function startGame() {
            // Cancel any existing game loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Prevent multiple game instances
            if (gameStarted) {
                console.log('Game already running, ignoring start request');
                return;
            }
            
            // Clear all game state to ensure fresh start
            snakes = [];
            elements = [];
            gameWon = false; // Reset victory flag
            particles = [];
            voidOrbs = [];
            catalystGems = [];
            alchemyVisionPowerUps = [];
            aiRespawnQueue = [];
            usedAISkins.clear();
            
            // Load previously discovered elements if available
            if (window.elementCompatibility) {
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                discoveredElements = new Set();
                // Add saved discoveries
                if (savedDiscovered) {
                    Object.keys(savedDiscovered).forEach(key => {
                        if (savedDiscovered[key]) {
                            discoveredElements.add(key);
                        }
                    });
                    console.log(`[GAME START] Loaded ${discoveredElements.size} discovered elements`);
                }
            } else {
                // Fallback - start with base elements discovered
                discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
            }
            
            // Reset game variables
            lastDiscoveredElement = null;
            alchemyVisionActive = false;
            alchemyVisionTimer = 0;
            bestRank = 0;
            playerSnake = null;
            
            // Reset game loop timing variables
            lastTime = 0;
            accumulator = 0;
            frameCount = 0;
            lastFpsUpdate = 0;
            
            // Reset spawn timers
            lastAlchemyVisionSpawn = Date.now();
            lastVoidOrbSpawn = Date.now();
            lastCatalystGemSpawn = Date.now();
            
            // Initialize discovery feed - starts empty
            const discoveryFeed = document.getElementById('discoveryFeed');
            if (discoveryFeed) {
                discoveryFeed.innerHTML = '';
                // Players must discover everything, even base elements
                
                // Discovery feed ready for new discoveries
                console.log('[DEBUG] Discovery feed initialized');
            }
            
            // Start fresh game
            gameStarted = true;
            gameStartTime = Date.now();
            
            // Create player snake
            console.log('[GAME START] Creating player snake...');
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            snakes.push(playerSnake);
            console.log('[GAME START] Player snake created. Total snakes:', snakes.length);
            
            // Create AI snakes
            for (let i = 0; i < MAX_AI_SNAKES; i++) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            console.log('[GAME START] AI snakes created. Total snakes:', snakes.length);
            
            
            // Spawn initial elements - ONLY base elements at game start
            const baseElements = ['fire', 'water', 'earth', 'air'];
            for (let i = 0; i < 60; i++) {
                // Spawn only base elements, distributed evenly
                const elementType = baseElements[i % 4];
                spawnElement(elementType);
            }
            
            // Initialize music and sound effects
            initMusic();
            initSoundEffects();
            initPowerUpSounds();
            initCombinationSounds();
            
            // Update discovery log
            updateDiscoveryLog();
            
            // Initialize border particles
            initializeBorderParticles();
            
            // Initialize static stars
            initializeStaticStars();
            
            gameLoop();
        }
        
        function stopGame() {
            console.log('[STOP GAME] Stopping game...');
            
            // Cancel the game loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Reset game state
            gameStarted = false;
            paused = false;
            
            // Clear ALL game objects
            console.log('[STOP GAME] Clearing snakes:', snakes.length, 'Player snakes:', snakes.filter(s => s.isPlayer).length);
            snakes = [];
            playerSnake = null;
            elements = [];
            particles = [];
            voidOrbs = [];
            catalystGems = [];
            alchemyVisionPowerUps = [];
            aiRespawnQueue = [];
            usedAISkins.clear();
            comboStreak = 0;
            playerRespawnTimer = 0;
            
            // Clear the canvas to prevent solid color issue
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            console.log('[STOP GAME] Game stopped');
        }
        
        function togglePause() {
            if (!gameStarted) return;
            paused = !paused;
            document.getElementById('pauseOverlay').style.display = paused ? 'flex' : 'none';
            
            // Update music button state
            if (paused) {
                // Update music controls if they exist
                const muteButton = document.getElementById('muteButton');
                if (muteButton) {
                    muteButton.textContent = musicMuted ? '🔇 Unmute' : '🔊 Mute';
                }
                const volumeSlider = document.getElementById('volumeSlider');
                if (volumeSlider) {
                    volumeSlider.value = musicVolume * 100;
                }
                const volumeDisplay = document.getElementById('volumeDisplay');
                if (volumeDisplay) {
                    volumeDisplay.textContent = Math.round(musicVolume * 100) + '%';
                }
                
                // Update skin selection UI
                calculateAvailableUnlocks();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Update high score display
                document.getElementById('highScoreDisplay').textContent = Math.floor(highScore).toLocaleString();
                
                // Populate discovery journal
                populateDiscoveryJournal();
            }
        }
        
        window.resumeGame = function() {
            paused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
        }
        
        
        // Tab switching for pause menu
        window.switchTab = function(tabName) {
            // Update button states
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'skins') {
                document.getElementById('skinsTab').classList.add('active');
            } else if (tabName === 'journal') {
                document.getElementById('journalTab').classList.add('active');
            } else if (tabName === 'howto') {
                document.getElementById('howtoTab').classList.add('active');
            }
        }
        
        // Build skin selection UI
        function buildSkinGrid() {
            const grid = document.getElementById('skinGrid');
            if (!grid) {
                console.error('Skin grid element not found!');
                return;
            }
            grid.innerHTML = '';
            
            const allSkins = Object.keys(skinMetadata).filter(skin => skin !== 'snake-default-green');
            allSkins.unshift('snake-default-green'); // Put default first
            
            allSkins.forEach(skinId => {
                const skinData = skinMetadata[skinId];
                const div = document.createElement('div');
                div.className = 'skin-item';
                
                // Add appropriate classes
                if (skinId === currentPlayerSkin) {
                    div.classList.add('current');
                }
                
                if (!skinData.unlocked) {
                    if (availableUnlocks > 0) {
                        div.classList.add('unlockable');
                    } else {
                        div.classList.add('locked');
                    }
                }
                
                // Build content
                const img = document.createElement('img');
                img.className = 'skin-image';
                img.src = `skins/${skinId}.png`;
                img.alt = skinData.name;
                img.onerror = function() {
                    console.error(`Failed to load skin image: skins/${skinId}.png`);
                    // Try with .webp extension as fallback
                    this.src = `skins/${skinId}.webp`;
                    this.onerror = function() {
                        console.error(`Failed to load skin image with both .png and .webp: ${skinId}`);
                    };
                };
                
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skinData.name;
                
                div.appendChild(img);
                div.appendChild(name);
                
                // Add unlock icon if applicable
                if (!skinData.unlocked) {
                    const icon = document.createElement('div');
                    icon.className = 'skin-unlock-icon';
                    icon.textContent = availableUnlocks > 0 ? '🔓' : '🔒';
                    div.appendChild(icon);
                }
                
                // Click handler
                div.onclick = () => selectSkin(skinId);
                
                grid.appendChild(div);
            });
        }
        
        // Handle skin selection
        function selectSkin(skinId) {
            const skinData = skinMetadata[skinId];
            
            if (skinData.unlocked) {
                // Already unlocked - just select it
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${skinId}.png`;
                }
                saveSkinData();
                buildSkinGrid();
            } else if (availableUnlocks > 0) {
                // Unlock the skin
                skinData.unlocked = true;
                unlockedSkins.add(skinId);
                availableUnlocks--;
                
                // Select the newly unlocked skin
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${skinId}.png`;
                }
                
                saveSkinData();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Show unlock message
                showMessage(`Unlocked: ${skinData.name}!`, true);
            }
        }
        
        // Update unlock display
        function updateUnlockDisplay() {
            const display = document.getElementById('availableUnlocks');
            if (display) {
                display.textContent = `Available Unlocks: ${availableUnlocks}`;
                if (availableUnlocks > 0) {
                    display.style.color = '#4ecdc4';
                } else {
                    display.style.color = '#AAA';
                }
            }
        }
        
        // Populate discovery journal with discovered elements
        function populateDiscoveryJournal() {
            const grid = document.getElementById('discoveryGrid');
            if (!grid) {
                console.error('Discovery grid element not found!');
                return;
            }
            
            grid.innerHTML = '';
            
            // Use allTimeDiscoveries for persistent journal
            const sortedDiscoveries = Array.from(allTimeDiscoveries.entries()).sort((a, b) => {
                const nameA = elementDatabase[a[0]]?.name || a[0];
                const nameB = elementDatabase[b[0]]?.name || b[0];
                return nameA.localeCompare(nameB);
            });
            
            sortedDiscoveries.forEach(([elementKey, recipe]) => {
                const elementData = elementDatabase[elementKey];
                if (!elementData) return;
                
                const div = document.createElement('div');
                div.className = 'discovery-item';
                div.dataset.name = elementData.name.toLowerCase();
                div.dataset.recipe = recipe.toLowerCase();
                
                // Element emoji/symbol
                const symbol = document.createElement('div');
                symbol.className = 'element-symbol';
                symbol.textContent = elementData.emoji;
                
                // Element name
                const name = document.createElement('div');
                name.className = 'element-name';
                name.textContent = elementData.name;
                
                // Recipe tooltip
                const recipeTooltip = document.createElement('div');
                recipeTooltip.className = 'recipe';
                recipeTooltip.textContent = recipe;
                
                div.appendChild(symbol);
                div.appendChild(name);
                div.appendChild(recipeTooltip);
                
                grid.appendChild(div);
            });
        }
        
        // filterDiscoveries function removed - search bar no longer present
        
        // Fixed timestep constants
        const FIXED_TIMESTEP = 1000 / 60; // 60 FPS fixed timestep (16.67ms)
        const MAX_UPDATES = 5; // Prevent spiral of death
        
        function gameLoop(currentTime) {
            if (!gameStarted) {
                animationFrameId = null;
                return;
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
            
            if (paused) return;
            
            // Don't render if canvas is not visible
            if (canvas.style.opacity === '0') return;
            
            // Initialize lastTime on first frame
            if (lastTime === 0) {
                lastTime = currentTime;
                return;
            }
            
            // Calculate frame time
            if (!isFinite(currentTime)) {
                console.error('currentTime is not finite:', currentTime);
                return;
            }
            const frameTime = Math.min(currentTime - lastTime, 250); // Cap at 250ms (4 FPS min)
            lastTime = currentTime;
            
            // Add to accumulator
            accumulator += frameTime;
            
            // Check for NaN
            if (!isFinite(accumulator) || !isFinite(frameTime)) {
                console.error('Accumulator or frameTime became NaN! frameTime:', frameTime, 'currentTime:', currentTime, 'lastTime:', lastTime, 'accumulator:', accumulator);
                accumulator = 0;
                lastTime = currentTime;
                return;
            }
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) { // Update every second
                currentFPS = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
                
                // Update FPS display
                const fpsElement = document.getElementById('fpsCounter');
                if (fpsElement) {
                    fpsElement.textContent = `FPS: ${currentFPS}`;
                }
            }
            
            // Update animation time for border effects
            animationTime = currentTime * 0.001; // Convert to seconds
            
            // Fixed timestep updates
            let updates = 0;
            while (accumulator >= FIXED_TIMESTEP && updates < MAX_UPDATES) {
                // Update game objects with fixed timestep (1.0 = one 60fps frame)
                snakes.forEach(snake => {
                    if (snake.alive) {
                        snake.update(1.0);
                    }
                });
                elementPool.update(1.0);
                particlePool.update(1.0);
                
                // Update border particles
                borderParticles.forEach(particle => particle.update(1.0));
                
                // Update shooting stars
                shootingStars = shootingStars.filter(star => star.update(1.0));
                
                // Spawn shooting star occasionally (10-15 seconds)
                if (currentTime - lastShootingStarTime > (10000 + Math.random() * 5000) && shootingStars.length === 0) {
                    shootingStars.push(new ShootingStar());
                    lastShootingStarTime = currentTime;
                }
                
                // Check collisions
                checkCollisions();
                
                // Remove dead snakes
                snakes = snakes.filter(snake => snake.alive);
                
                // Spawn new elements occasionally
                if (Math.random() < 0.04 && elementPool.getActiveCount() < 150) {
                    spawnElement();
                }
                
                // Update AlchemyVision timer
                if (alchemyVisionActive) {
                    alchemyVisionTimer -= FIXED_TIMESTEP;
                    if (alchemyVisionTimer <= 0) {
                        alchemyVisionActive = false;
                        alchemyVisionTimer = 0;
                        // Clear any remaining power-ups when one expires
                        alchemyVisionPowerUps = [];
                    }
                }
                
                // AlchemyVision power-ups removed
                // if (alchemyVisionPowerUps.length === 0 && Date.now() - lastAlchemyVisionSpawn >= ALCHEMY_VISION_SPAWN_INTERVAL) {
                //     // Spawn multiple power-ups spread across the map
                //     for (let i = 0; i < ALCHEMY_VISION_SPAWN_COUNT; i++) {
                //         // Divide the map into sections to spread out spawns
                //         const sectionWidth = WORLD_SIZE / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT));
                //         const sectionHeight = WORLD_SIZE / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT));
                //         
                //         // Random position within each section
                //         const sectionX = (i % Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT))) * sectionWidth;
                //         const sectionY = Math.floor(i / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT))) * sectionHeight;
                //         
                //         const x = sectionX + 100 + Math.random() * (sectionWidth - 200);
                //         const y = sectionY + 100 + Math.random() * (sectionHeight - 200);
                //         
                //         alchemyVisionPowerUps.push(new AlchemyVision(x, y));
                //     }
                //     lastAlchemyVisionSpawn = Date.now();
                // }
                
                // Update AlchemyVision power-ups (keeping for existing ones to expire)
                alchemyVisionPowerUps.forEach(powerUp => powerUp.update(1.0));
                
                // Spawn Void Orbs to maintain count
                if (voidOrbs.length < VOID_ORB_SPAWN_COUNT && Date.now() - lastVoidOrbSpawn >= VOID_ORB_SPAWN_INTERVAL / VOID_ORB_SPAWN_COUNT) {
                    const x = 100 + Math.random() * (WORLD_SIZE - 200);
                    const y = 100 + Math.random() * (WORLD_SIZE - 200);
                    voidOrbs.push(new VoidOrb(x, y));
                    lastVoidOrbSpawn = Date.now();
                }
                
                // Update Void Orbs
                voidOrbs.forEach(orb => orb.update(1.0));
                
                // Spawn Catalyst Gems to maintain count (more spread out)
                if (catalystGems.length < CATALYST_GEM_SPAWN_COUNT && Date.now() - lastCatalystGemSpawn >= CATALYST_GEM_SPAWN_INTERVAL / CATALYST_GEM_SPAWN_COUNT) {
                    // Divide map into sections for better spread
                    const sectionWidth = WORLD_SIZE / CATALYST_GEM_SPAWN_COUNT;
                    const sectionIndex = catalystGems.length;
                    const sectionX = sectionIndex * sectionWidth;
                    
                    const x = sectionX + 100 + Math.random() * (sectionWidth - 200);
                    const y = 100 + Math.random() * (WORLD_SIZE - 200);
                    catalystGems.push(new CatalystGem(x, y));
                    lastCatalystGemSpawn = Date.now();
                }
                
                // Update Catalyst Gems
                catalystGems.forEach(gem => gem.update(1.0));
                
                accumulator -= FIXED_TIMESTEP;
                updates++;
            }
            
            // Handle AI snake respawning with cooldown
            const aiSnakes = snakes.filter(s => !s.isPlayer && s.alive).length;
            
            // Process respawn queue
            aiRespawnQueue = aiRespawnQueue.filter(respawnTime => {
                if (currentTime >= respawnTime && aiSnakes < MAX_AI_SNAKES) {
                    // Spawn new AI snake
                    const x = 200 + Math.random() * (WORLD_SIZE - 400);
                    const y = 200 + Math.random() * (WORLD_SIZE - 400);
                    snakes.push(new Snake(x, y, false));
                    return false; // Remove from queue
                }
                return true; // Keep in queue
            });
            
            // Check if we need to add dead snakes to respawn queue
            if (aiSnakes < MAX_AI_SNAKES) {
                const deadAICount = MAX_AI_SNAKES - aiSnakes - aiRespawnQueue.length;
                for (let i = 0; i < deadAICount; i++) {
                    aiRespawnQueue.push(currentTime + AI_RESPAWN_COOLDOWN);
                }
            }
            
            // Handle player respawn
            if (playerSnake && !playerSnake.alive) {
                if (playerRespawnTimer <= 0) {
                    // Start respawn timer
                    playerRespawnTimer = 3000; // 3 seconds
                    comboStreak = 0; // Reset combo streak on death
                }
                
                // Update respawn timer
                playerRespawnTimer -= frameTime;
                
                if (playerRespawnTimer <= 0) {
                    // Store previous score before creating new snake
                    const previousScore = playerSnake.score;
                    const previousCapacity = playerSnake.elementCapacity;
                    const previousDiscoveries = playerSnake.discoveries;
                    const previousKills = playerSnake.kills;
                    
                    // Debug logging
                    console.log('[RESPAWN] Player died, respawning...');
                    console.log('[RESPAWN] Snakes before cleanup:', snakes.length, 'Player snakes:', snakes.filter(s => s.isPlayer).length);
                    
                    // Remove ALL player snakes from array (in case of duplicates)
                    const oldPlayerCount = snakes.filter(snake => snake.isPlayer).length;
                    snakes = snakes.filter(snake => !snake.isPlayer);
                    
                    // Double check that playerSnake is cleared
                    if (snakes.some(s => s.isPlayer)) {
                        console.error('[RESPAWN] ERROR: Player snake still exists after cleanup!');
                        snakes = snakes.filter(snake => !snake.isPlayer);
                    }
                    
                    console.log('[RESPAWN] Removed', oldPlayerCount, 'player snake(s)');
                    console.log('[RESPAWN] Snakes after cleanup:', snakes.length);
                    
                    // Respawn player at center
                    playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
                    
                    // Keep 75% of score (25% penalty)
                    playerSnake.score = Math.floor(previousScore * 0.75);
                    
                    // Restore some game state
                    playerSnake.elementCapacity = Math.max(4, Math.floor(previousCapacity * 0.5));
                    playerSnake.discoveries = Math.floor(previousDiscoveries * 0.5);
                    playerSnake.kills = Math.floor(previousKills * 0.5);
                    
                    // Grant 3 seconds of invincibility on respawn
                    playerSnake.invincibilityTimer = 3000;
                    
                    // Add back to snakes array
                    snakes.push(playerSnake);
                    
                    console.log('[RESPAWN] New player snake created. Total snakes:', snakes.length, 'Player snakes:', snakes.filter(s => s.isPlayer).length);
                    
                    // Set camera to new player position to prevent jumping
                    camera.x = WORLD_SIZE / 2;
                    camera.y = WORLD_SIZE / 2;
                    
                    // Reset respawn timer
                    playerRespawnTimer = 0;
                }
            }
            
            // Update UI
            updateUI();
            
            // Update boost bar every frame for real-time feedback
            updateBoostBar();
            
            // Calculate interpolation factor for smooth rendering
            const interpolation = accumulator / FIXED_TIMESTEP;
            
            // Update camera to follow player with interpolation
            if (playerSnake && playerSnake.alive && playerSnake.segments.length > 0) {
                const head = playerSnake.segments[0];
                
                // Interpolate player position for camera
                let playerX = playerSnake.x;
                let playerY = playerSnake.y;
                
                if (playerSnake.prevX !== undefined && playerSnake.prevY !== undefined) {
                    playerX = playerSnake.prevX + (playerSnake.x - playerSnake.prevX) * interpolation;
                    playerY = playerSnake.prevY + (playerSnake.y - playerSnake.prevY) * interpolation;
                }
                
                // Ensure camera coordinates stay within reasonable bounds to prevent overflow
                camera.x = Math.max(0, Math.min(WORLD_SIZE, playerX));
                camera.y = Math.max(0, Math.min(WORLD_SIZE, playerY));
                
                // Additional check for NaN or Infinity
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            } else if (playerSnake && !playerSnake.alive) {
                // Keep camera at last known position when player is dead
                // This prevents camera jumping during respawn
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            }
            
            // Draw everything
            drawBackground();
            
            // Draw elements (element pool handles viewport culling)
            elementPool.draw();
            
            // Draw AlchemyVision power-ups (with viewport culling)
            alchemyVisionPowerUps.forEach(powerUp => {
                if (isInViewport(powerUp.x, powerUp.y, 100)) {
                    powerUp.draw();
                }
            });
            
            // Draw Void Orbs (with viewport culling)
            voidOrbs.forEach(orb => {
                if (isInViewport(orb.x, orb.y, 100)) {
                    orb.draw();
                }
            });
            
            // Draw Catalyst Gems (with viewport culling)
            catalystGems.forEach(gem => {
                if (isInViewport(gem.x, gem.y, 100)) {
                    gem.draw();
                }
            });
            
            // Draw snakes (they already have internal viewport culling)
            snakes.forEach(snake => {
                if (snake.alive) {
                    snake.draw(interpolation);
                }
            });
            
            // Draw particles (particle pool handles viewport culling)
            particlePool.draw();
        }
        
        // Initialize mobile controls
        function initMobileControls() {
            if (!isMobile) return;
            
            // Add mobile class to body
            document.body.classList.add('mobile');
            
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const boostBtn = document.getElementById('boostButton');
            
            let joystickTouch = null;
            
            // Joystick controls
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouch === null && e.changedTouches.length > 0) {
                    joystickTouch = e.changedTouches[0].identifier;
                    joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    joystickBase.x = rect.left + rect.width / 2;
                    joystickBase.y = rect.top + rect.height / 2;
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouch) {
                        const dx = touch.clientX - joystickBase.x;
                        const dy = touch.clientY - joystickBase.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = 40; // Max knob travel distance
                        
                        let knobX = dx;
                        let knobY = dy;
                        
                        if (distance > maxDistance) {
                            knobX = (dx / distance) * maxDistance;
                            knobY = (dy / distance) * maxDistance;
                        }
                        
                        // Update knob position
                        knob.style.left = `${50 + (knobX / 60) * 50}%`;
                        knob.style.top = `${50 + (knobY / 60) * 50}%`;
                        
                        // Update mouse angle for game controls
                        if (distance > 10) { // Dead zone
                            mouseAngle = Math.atan2(dy, dx);
                        }
                        break;
                    }
                }
            });
            
            const resetJoystick = () => {
                joystickActive = false;
                joystickTouch = null;
                knob.style.left = '50%';
                knob.style.top = '50%';
            };
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouch) {
                        resetJoystick();
                        break;
                    }
                }
            });
            
            joystick.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                resetJoystick();
            });
            
            // Boost button controls
            boostBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouseDown = true;
                boostBtn.classList.add('active');
            });
            
            boostBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            boostBtn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            // Prevent scrolling on game canvas
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            });
        }
        
        // Initialize
        Promise.all([loadElements(), loadSnakeNames()]).then(() => {
            console.log('Game ready!');
            
            // Sync discovered elements from new system if available
            if (window.elementLoader && window.elementCompatibility) {
                // Load previously discovered elements
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                if (savedDiscovered && savedDiscovered.size > 0) {
                    // Merge with existing discovered elements
                    for (const elementKey of savedDiscovered) {
                        discoveredElements.add(elementKey);
                    }
                    console.log(`Loaded ${savedDiscovered.size} discovered elements from new system`);
                }
            }
            
            // Load skin data
            loadSkinData();
            preloadSkins();
            
            // Load all-time discoveries
            loadAllTimeDiscoveries();
            
            // Initialize mobile controls if needed
            initMobileControls();
        });
        
        // Stars animation for splash and game mode screens
        (function() {
            const splashCanvas = document.getElementById('splashStarsCanvas');
            const splashCtx = splashCanvas.getContext('2d');
            const gameModeCanvas = document.getElementById('gameModeStarsCanvas');
            const gameModeCtx = gameModeCanvas.getContext('2d');
            
            // Resize canvases
            function resizeCanvases() {
                splashCanvas.width = window.innerWidth;
                splashCanvas.height = window.innerHeight;
                gameModeCanvas.width = window.innerWidth;
                gameModeCanvas.height = window.innerHeight;
            }
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Stars array (shared between both screens)
            const stars = [];
            const shootingStars = [];
            let lastShootingStarTime = 0;
            
            // Initialize stars
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            
            // Shooting star class for splash
            class SplashShootingStar {
                constructor() {
                    // Start from screen edge
                    const edge = Math.floor(Math.random() * 4);
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    switch(edge) {
                        case 0: // Top
                            this.x = Math.random() * width;
                            this.y = -10;
                            break;
                        case 1: // Right
                            this.x = width + 10;
                            this.y = Math.random() * height;
                            break;
                        case 2: // Bottom
                            this.x = Math.random() * width;
                            this.y = height + 10;
                            break;
                        case 3: // Left
                            this.x = -10;
                            this.y = Math.random() * height;
                            break;
                    }
                    
                    // Aim towards screen center area
                    const targetX = width * (0.3 + Math.random() * 0.4);
                    const targetY = height * (0.3 + Math.random() * 0.4);
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    const speed = 3 + Math.random() * 2;
                    
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.trail = [];
                    this.maxTrailLength = 30;
                    this.life = 1.0;
                }
                
                update() {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.01;
                    
                    return this.life > 0 && this.x > -50 && this.x < window.innerWidth + 50 && 
                           this.y > -50 && this.y < window.innerHeight + 50;
                }
                
                draw(ctx) {
                    // Draw trail
                    ctx.save();
                    this.trail.forEach((point, index) => {
                        const alpha = (index / this.trail.length) * this.life * 0.3;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ffffff';
                        const size = (index / this.trail.length) * 2;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw star
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Animation loop
            function animateStars(timestamp) {
                // Check which screen is active
                const splashActive = document.getElementById('splashScreen').style.display !== 'none' && 
                                   document.getElementById('splashScreen').style.opacity !== '0';
                const gameModeActive = document.getElementById('gameModeSelect').style.display !== 'none';
                
                if (!splashActive && !gameModeActive) {
                    requestAnimationFrame(animateStars);
                    return;
                }
                
                // Determine which canvas to draw on
                const activeCanvas = splashActive ? splashCanvas : gameModeCanvas;
                const activeCtx = splashActive ? splashCtx : gameModeCtx;
                
                // Clear canvas
                activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);
                
                // Draw static stars with twinkling
                stars.forEach(star => {
                    star.opacity += Math.sin(timestamp * star.twinkleSpeed) * 0.05;
                    star.opacity = Math.max(0.1, Math.min(0.8, star.opacity));
                    
                    activeCtx.globalAlpha = star.opacity;
                    activeCtx.fillStyle = '#ffffff';
                    activeCtx.beginPath();
                    activeCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    activeCtx.fill();
                });
                
                // Update and draw shooting stars
                shootingStars.forEach((star, index) => {
                    if (!star.update()) {
                        shootingStars.splice(index, 1);
                    } else {
                        star.draw(activeCtx);
                    }
                });
                
                // Spawn new shooting star occasionally
                if (timestamp - lastShootingStarTime > 3000 + Math.random() * 4000) {
                    shootingStars.push(new SplashShootingStar());
                    lastShootingStarTime = timestamp;
                }
                
                activeCtx.globalAlpha = 1;
                requestAnimationFrame(animateStars);
            }
            
            // Start animation
            requestAnimationFrame(animateStars);
        })();
        
        // Try to play music on first user interaction
        document.addEventListener('click', function playMusicOnInteraction() {
            if (currentTrack && currentTrack.paused && gameStarted) {
                currentTrack.play().catch(() => {});
            }
        }, { once: true });
    </script>
</body>
</html>