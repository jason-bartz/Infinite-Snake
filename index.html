<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Snake - Elemental Mastery</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 1;
        }
        
        /* Splash Screen */
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        #splashStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #splashContent {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #splashScreen img {
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        #startButton:hover {
            transform: scale(1.1);
        }
        
        #splashTitle {
            font-size: 60px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: none;
        }
        
        /* Game Mode Selection */
        #gameModeSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            display: none;
            z-index: 50;
        }
        
        #gameModeStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #gameModeContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #444;
            max-width: 800px;
            width: 90%;
            z-index: 1;
        }
        
        #gameModeSelect h3 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        .modeSection {
            margin-bottom: 30px;
        }
        
        .modeSection h4 {
            color: #AAA;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #gameModeSelect button {
            margin: 5px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 180px;
        }
        
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        
        /* Victory Mode Layout */
        #victoryButtons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .victory-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .victory-column h5 {
            color: #FFD700;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .victory-infinite {
            grid-column: span 2;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        /* Discovery Mode Buttons */
        .btn-discovery {
            background: linear-gradient(135deg, #2E7D32, #1B5E20) !important;
            border: 1px solid #4CAF50 !important;
        }
        
        .btn-discovery:hover {
            background: linear-gradient(135deg, #388E3C, #2E7D32) !important;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Points Mode Buttons */
        .btn-points {
            background: linear-gradient(135deg, #D32F2F, #B71C1C) !important;
            border: 1px solid #F44336 !important;
        }
        
        .btn-points:hover {
            background: linear-gradient(135deg, #E53935, #D32F2F) !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
        }
        
        /* Infinite Mode Button */
        .btn-infinite {
            background: linear-gradient(135deg, #7B1FA2, #4A148C) !important;
            border: 1px solid #9C27B0 !important;
            min-width: 250px !important;
            font-size: 18px !important;
            padding: 15px 30px !important;
        }
        
        .btn-infinite:hover {
            background: linear-gradient(135deg, #8E24AA, #6A1B9A) !important;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.6);
        }
        
        #loadingIndicator {
            display: none;
            margin: 10px 0;
            color: #FFD700;
            font-size: 14px;
        }
        
        /* Canvas */
        #gameCanvas {
            display: block;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
            margin-left: 200px;
        }
        
        /* Discovery Sidebar */
        #discoveryLog {
            position: fixed;
            top: 0;
            left: 0;
            width: 200px;
            height: 100%;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
            z-index: 20;
            box-sizing: border-box;
            display: none;
        }
        
        #discoveryLog h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #FFD700;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .discovery-item {
            margin: 8px 0;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .discovery-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        
        .discovery-item .emoji {
            font-size: 24px;
        }
        
        .discovery-item .info {
            flex: 1;
        }
        
        .discovery-item .name {
            font-weight: bold;
            color: white;
        }
        
        .discovery-item .tier {
            font-size: 11px;
            color: #AAA;
        }
        
        .discovery-item.new {
            animation: newItemGlow 2s ease-out;
            background: rgba(255, 215, 0, 0.2);
        }
        
        @keyframes newItemGlow {
            0% {
                background: rgba(255, 215, 0, 0.5);
                transform: translateX(10px);
            }
            100% {
                background: rgba(255, 215, 0, 0.2);
                transform: translateX(0);
            }
        }
        
        /* UI Elements */
        #ui {
            position: absolute;
            top: 0;
            left: 200px;
            right: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #discoveries {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #elementQueue {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(2, 60px);
            gap: 4px;
            width: fit-content;
        }
        
        .element-square {
            width: 40px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            padding: 2px;
        }
        
        .element-square .element-name {
            font-size: 8px;
            color: #CCC;
            text-align: center;
            margin-top: 2px;
            line-height: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 36px;
        }
        
        .element-square.empty {
            background: rgba(255,255,255,0.05);
            border: 1px dashed rgba(255,255,255,0.1);
        }
        
        .element-square.filled {
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .element-square:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        #recentDiscovery {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95));
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: all 0.5s;
            pointer-events: none;
            padding: 15px 30px;
            border-radius: 10px;
            border: 3px solid #FFD700;
            z-index: 25;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.2);
            animation: none;
        }
        
        #recentDiscovery.show {
            animation: flashyEntrance 0.5s ease-out;
        }
        
        @keyframes flashyEntrance {
            0% {
                transform: translateX(-50%) scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) scale(1.1) rotate(5deg);
            }
            100% {
                transform: translateX(-50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        #recentDiscovery.combo {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.95), rgba(69, 183, 170, 0.95));
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.8), inset 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        /* Leaderboard */
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
            min-width: 200px;
        }
        
        #leaderboard h4 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 16px;
            text-align: center;
        }
        
        #leaderboard-list {
            font-size: 14px;
            line-height: 1.6;
        }
        
        #leaderboard-list .leader {
            color: #FFD700;
            font-weight: bold;
        }
        
        #leaderboard-list .player {
            color: #4ecdc4;
        }
        
        /* Pause Menu */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #pauseMenu {
            background: rgba(20,20,40,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        /* How to Play Section */
        .howToPlay {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            color: #CCC;
            line-height: 1.6;
        }
        
        .howToPlay h5 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .howToPlay ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .howToPlay li {
            margin-bottom: 5px;
        }
        
        .howToPlay strong {
            color: #FFD700;
        }
        
        /* Skin Selection */
        #skinSelection {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        #skinSelection h4 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #availableUnlocks {
            text-align: center;
            color: #4ecdc4;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        #skinGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .skin-item {
            position: relative;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .skin-item:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .skin-item.current {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .skin-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .skin-item.locked:hover {
            transform: none;
        }
        
        .skin-item.unlockable {
            border-color: #4ecdc4;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #4ecdc4; }
            50% { box-shadow: 0 0 20px #4ecdc4, 0 0 30px #4ecdc4; }
        }
        
        .skin-image {
            width: 60px;
            height: 60px;
            margin: 0 auto 5px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .skin-name {
            font-size: 11px;
            color: #CCC;
            margin-top: 5px;
        }
        
        .skin-unlock-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }
    </style>
    <!-- New Element System Scripts -->
    <script src="elements/element-loader.js"></script>
    <script src="elements/compatibility-layer.js"></script>
    <script src="elements/integrate.js"></script>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen">
        <canvas id="splashStarsCanvas"></canvas>
        <div id="splashContent">
            <img src="assets/word-logo.webp" alt="Infinite Snake" style="width: 400px; max-width: 80%; margin-bottom: 30px;" onerror="this.style.display='none'; document.getElementById('splashTitle').style.display='block';">
            <h1 id="splashTitle">Infinite Snake</h1>
            <p>Reality has shattered. The elements of creation lie scattered across the void.<br><br>
            You are the Infinite Snake - a primordial being born from chaos. Consume these fragments. Combine them within your endless coils. Forge new existence.<br><br>
            From Fire and Water to stars and civilizations, rebuild the cosmos itself. The universe awaits.</p>
            <button id="startButton">Begin Your Journey</button>
        </div>
    </div>
    
    <!-- Game Mode Selection -->
    <div id="gameModeSelect">
        <canvas id="gameModeStarsCanvas"></canvas>
        <div id="gameModeContent">
            <h3>Game Setup</h3>
        
        <div class="modeSection">
            <h4>Victory Condition</h4>
            <div id="victoryButtons">
                <div class="victory-column">
                    <h5>üß™ Discovery Race</h5>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 100)">Discover 100 Elements</button>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 500)">Discover 500 Elements</button>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 1000)">Discover 1000 Elements</button>
                </div>
                <div class="victory-column">
                    <h5>‚≠ê Points Race</h5>
                    <button class="btn-points" onclick="selectVictoryMode('points', 50000)">Score 50,000 Points</button>
                    <button class="btn-points" onclick="selectVictoryMode('points', 250000)">Score 250,000 Points</button>
                    <button class="btn-points" onclick="selectVictoryMode('points', 1000000)">Score 1,000,000 Points</button>
                </div>
                <div class="victory-infinite">
                    <button class="btn-infinite" onclick="selectVictoryMode('infinite', 0)">‚àû Infinite Mode</button>
                </div>
            </div>
        </div>
        
        <div class="modeSection" id="controlSection" style="display: none;">
            <h4>Control Method</h4>
            <div id="loadingIndicator">
                Loading element database... <span id="loadingProgress"></span>
            </div>
            <button class="controlOption" onclick="selectControls('arrows')">‚Üë ‚Üì ‚Üê ‚Üí Arrow Keys</button>
            <button class="controlOption" onclick="selectControls('wasd')">W A S D Keys</button>
            <button class="controlOption" onclick="selectControls('mouse')">üñ±Ô∏è Mouse / Touchpad</button>
            
            <div class="howToPlay">
                <h5>How to Play</h5>
                <ul>
                    <li><strong>Collect Elements:</strong> Guide your snake to consume elemental orbs scattered across the map</li>
                    <li><strong>Combine Elements:</strong> Elements in your snake automatically combine to create new discoveries</li>
                    <li><strong>Grow & Survive:</strong> Each combination makes you longer. Bigger snakes can hold more elements!</li>
                    <li><strong>Battle Strategy:</strong> In head-to-head collisions, the longer snake wins. Avoid all snake bodies!</li>
                    <li><strong>Discover Everything:</strong> Find all possible element combinations to master the realm</li>
                    <li><strong>Beware the Borders:</strong> Red borders mean instant death - stay away!</li>
                </ul>
                <p style="text-align: center; margin-top: 10px; color: #888; font-size: 12px;">Press P to pause ‚Ä¢ New discoveries grant invincibility!</p>
            </div>
        </div>
        </div>
    </div>
    
    <!-- Discovery Sidebar -->
    <div id="discoveryLog">
        <h3>Discoveries (0)</h3>
        <div id="discoveryList"></div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div id="recentDiscovery"></div>
        <div id="score">Score: 0</div>
        <div id="discoveries">Discoveries: 0</div>
        <div id="elementQueue"></div>
        <div id="leaderboard">
            <h4>Leaderboard</h4>
            <div id="leaderboard-list"></div>
        </div>
    </div>
    
    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <p style="color: #AAA; font-size: 14px; margin: 10px 0;">High Score: <span style="color: #FFD700;" id="highScoreDisplay">0</span></p>
            
            <div style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 10px;">
                <h4 style="color: #FFD700; margin-bottom: 10px;">Music Controls</h4>
                <div style="display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 10px;">
                    <button onclick="toggleMusic()" id="muteButton" style="padding: 8px 20px; background: linear-gradient(135deg, #4B79A1, #283E51); border: 1px solid #666; color: white; border-radius: 5px; cursor: pointer;">üîä Mute</button>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="color: #AAA;">Volume:</span>
                        <input type="range" id="volumeSlider" min="0" max="100" value="30" onchange="changeVolume(this.value)" style="width: 150px;">
                        <span id="volumeDisplay" style="color: #AAA; width: 40px;">30%</span>
                    </div>
                </div>
            </div>
            
            <div id="skinSelection">
                <h4>Snake Skins</h4>
                <div id="availableUnlocks">Available Unlocks: 0</div>
                <div id="skinGrid"></div>
            </div>
            
            <button onclick="resumeGame()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #4ecdc4; color: white; border: none; border-radius: 10px; cursor: pointer;">Resume</button>
            <button onclick="location.reload()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer;">New Game</button>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas fit with sidebar
        function resizeCanvas() {
            canvas.width = window.innerWidth - 200; // Account for sidebar
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game constants
        const WORLD_SIZE = 4000;
        const SEGMENT_SIZE = 15;
        const SNAKE_SPEED = 3;
        const TURN_SPEED = 0.08;
        const ELEMENT_SIZE = 20;
        
        // Game state
        let gameStarted = false;
        let paused = false;
        let controlScheme = 'arrows';
        let gameMode = 'infinite'; // 'discovery', 'points', or 'infinite'
        let gameTarget = 0; // Target value for victory
        let camera = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
        let playerSnake = null;
        let snakes = [];
        let elements = [];
        let particles = [];
        let lastDiscoveredElement = null;
        let highScore = parseInt(localStorage.getItem('highScore') || '0');
        
        // Space effects
        let staticStars = [];
        let shootingStars = [];
        let lastShootingStarTime = 0;
        
        // Nebula border effect variables
        let borderParticles = [];
        let animationTime = 0;
        const MAX_BORDER_PARTICLES = 150;
        
        // Element database
        let elementDatabase = {};
        let combinations = {};
        let discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
        
        // Snake names data
        let snakeNameData = null;
        
        // Skin system
        const skinMetadata = {
            'snake-default-green': { name: 'Default Green', unlocked: true, colors: ['#2ecc71', '#27ae60'] },
            '35mm': { name: 'Hipstamatic', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'Frank': { name: 'Franklin', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'af-one': { name: "Don't Scuff on Me", unlocked: false, colors: ['#e74c3c', '#ecf0f1'] },
            'barbi': { name: 'Pink Plastic', unlocked: false, colors: ['#ff69b4', '#ff1493'] },
            'boat-mcboatface': { name: 'Boaty McBoatface', unlocked: false, colors: ['#3498db', '#2980b9'] },
            'camera-guy': { name: 'Say Cheese', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'coffee': { name: 'Caffeine Fiend', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'controller': { name: 'Game On', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'diet-cola': { name: 'Cola Crusader', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'dog': { name: 'Good Boy', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'donut': { name: 'Sweet Tooth', unlocked: false, colors: ['#daa520', '#ff69b4'] },
            'flame': { name: 'Hot Head', unlocked: false, colors: ['#ff8c00', '#ffd700'] },
            'football': { name: 'Touchdown', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'fries': { name: 'Salty Serpent', unlocked: false, colors: ['#e74c3c', '#ffd700'] },
            'green-dragon': { name: 'Emerald Drake', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'handheld-game': { name: 'Retro Gamer', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'hotdog': { name: 'Wiener Winner', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'infinity-glove': { name: 'Snap Master', unlocked: false, colors: ['#e74c3c', '#9b59b6', '#ffd700', '#2ecc71'] },
            'kid-car': { name: 'Speed Demon Jr.', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'lovecraft': { name: 'Eldritch Horror', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'neko': { name: 'Sir Beans', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'nyan': { name: 'Poptart Cat', unlocked: false, colors: ['#e74c3c', '#ff8c00', '#ffd700', '#2ecc71', '#3498db', '#9b59b6'] },
            'pizza': { name: 'Slice of Life', unlocked: false, colors: ['#ffd700', '#f39c12'] },
            'potato': { name: 'Spud Buddy', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'racer': { name: 'Speed Demon', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'ramen': { name: 'Noodle Master', unlocked: false, colors: ['#ffd700', '#f39c12'] },
            'red-dragon': { name: 'Crimson Drake', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'robot': { name: 'Mecha Boi', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'santa': { name: 'Ho Ho Snake', unlocked: false, colors: ['#2ecc71', '#e74c3c', '#ecf0f1'] },
            'saturn': { name: 'Ring Leader', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'skibidi': { name: 'Mr. Swirley', unlocked: false, colors: ['#ecf0f1', '#bdc3c7'] },
            'snake-2': { name: 'Classic Redux', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'space-cadet': { name: 'Cosmic Crawler', unlocked: false, colors: ['#34495e', '#2c3e50'] },
            'tornado': { name: 'Whirlwind', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'tv': { name: 'Channel Surfer', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'unicorn': { name: 'Magical Mover', unlocked: false, colors: ['#ff69b4', '#ffd700'] },
            'brick-man': { name: 'Everything is Awesome', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'buffalo': { name: "Let's Go Buffalo", unlocked: false, colors: ['#3498db', '#2980b9'] },
            'clock': { name: 'Tick Tock', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'floral': { name: 'Bouquet', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'gnome': { name: 'Garden Party', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'mac': { name: 'Boop Beep', unlocked: false, colors: ['#f5deb3', '#e6d7c3'] },
            'murica': { name: "'Murica", unlocked: false, colors: ['#e74c3c', '#ecf0f1', '#3498db'] },
            'pod-player': { name: 'One More Thing', unlocked: false, colors: ['#87ceeb', '#5f9ea0'] },
            'whale': { name: 'Big Fish', unlocked: false, colors: ['#3498db', '#2980b9'] }
        };
        
        const aiSkins = ['robot', 'green-dragon', 'red-dragon', 'space-cadet', 'neko', 'unicorn'];
        let currentPlayerSkin = 'snake-default-green';
        let unlockedSkins = new Set(['snake-default-green']);
        let availableUnlocks = 0;
        let skinImages = {}; // Cache for loaded skin images
        
        // Load skin system from localStorage
        function loadSkinData() {
            const saved = localStorage.getItem('unlockedSkins');
            if (saved) {
                unlockedSkins = new Set(JSON.parse(saved));
            }
            
            const savedCurrent = localStorage.getItem('currentSkin');
            if (savedCurrent && unlockedSkins.has(savedCurrent)) {
                currentPlayerSkin = savedCurrent;
            }
            
            // Update metadata
            for (const skin of unlockedSkins) {
                if (skinMetadata[skin]) {
                    skinMetadata[skin].unlocked = true;
                }
            }
        }
        
        // Save skin data
        function saveSkinData() {
            localStorage.setItem('unlockedSkins', JSON.stringify(Array.from(unlockedSkins)));
            localStorage.setItem('currentSkin', currentPlayerSkin);
        }
        
        // Preload skin images
        function preloadSkins() {
            const allSkins = Object.keys(skinMetadata).concat(aiSkins);
            allSkins.forEach(skin => {
                const img = new Image();
                img.src = `skins/${skin}.webp`;
                skinImages[skin] = img;
            });
        }
        
        // Calculate available unlocks based on high score
        function calculateAvailableUnlocks() {
            let unlocks = 0;
            if (highScore >= 50000) unlocks++;
            if (highScore >= 100000) unlocks++;
            if (highScore >= 150000) unlocks++;
            if (highScore > 150000) {
                unlocks += Math.floor((highScore - 150000) / 250000);
            }
            
            // Subtract already unlocked skins (minus the default)
            const alreadyUnlocked = unlockedSkins.size - 1;
            availableUnlocks = Math.max(0, unlocks - alreadyUnlocked);
            return availableUnlocks;
        }
        
        // Music system
        // Background music tracks - see CREDITS.md for full attribution
        // All tracks produced by ZapSplat under Standard License
        let currentTrack = null;
        let musicVolume = 0.3;
        let musicMuted = false;
        const musicTracks = [
            'bright-white-lights.mp3',
            'last-ones-standing.mp3', 
            'good-times.mp3',
            'summer-haze.mp3',
            'on-the-up.mp3',
            'headliner.mp3'
        ];
        let availableTracks = [];
        
        
        // Input handling
        const keys = {};
        let mouseAngle = 0;
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            
            // Resume pending music on first interaction
            if (window.pendingMusicTrack && !musicMuted) {
                window.pendingMusicTrack.play().then(() => {
                    console.log('Music resumed after user interaction');
                }).catch(err => {
                    console.error('Failed to resume music:', err);
                });
                window.pendingMusicTrack = null;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        window.addEventListener('mousemove', (e) => {
            if (controlScheme === 'mouse' && playerSnake) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
            }
        });
        
        // Splash screen
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        // Game mode selection
        function selectVictoryMode(mode, target) {
            gameMode = mode;
            gameTarget = target;
            document.getElementById('controlSection').style.display = 'block';
            
            // Highlight selected button
            const buttons = document.querySelectorAll('#victoryButtons button');
            buttons.forEach(btn => btn.style.opacity = '0.6');
            event.target.style.opacity = '1';
        }
        
        function selectControls(scheme) {
            controlScheme = scheme;
            
            // Create fade transition
            const gameModeSelect = document.getElementById('gameModeSelect');
            const discoveryLog = document.getElementById('discoveryLog');
            const gameCanvas = document.getElementById('gameCanvas');
            const gameModeStarsCanvas = document.getElementById('gameModeStarsCanvas');
            
            // Add transition styles
            gameModeSelect.style.transition = 'opacity 0.8s ease-out';
            gameCanvas.style.transition = 'opacity 0.8s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Create a temporary background during transition
            const transitionBg = document.createElement('div');
            transitionBg.style.position = 'fixed';
            transitionBg.style.top = '0';
            transitionBg.style.left = '0';
            transitionBg.style.width = '100%';
            transitionBg.style.height = '100%';
            transitionBg.style.background = '#000';
            transitionBg.style.zIndex = '40';
            transitionBg.appendChild(gameModeStarsCanvas.cloneNode(true));
            transitionBg.style.transition = 'opacity 1s ease-out';
            document.body.appendChild(transitionBg);
            
            // Fade out menu content but keep stars visible
            const menuContent = gameModeSelect.querySelector('#gameModeContent');
            if (menuContent) {
                menuContent.style.transition = 'opacity 0.4s ease-out';
                menuContent.style.opacity = '0';
            }
            
            // After content fades, start the game
            setTimeout(() => {
                gameModeSelect.style.display = 'none';
                discoveryLog.style.display = 'block';
                startGame();
                
                // Fade in game canvas and fade out transition background
                setTimeout(() => {
                    gameCanvas.style.opacity = '1';
                    transitionBg.style.opacity = '0';
                    
                    // Remove transition background after fade
                    setTimeout(() => {
                        transitionBg.remove();
                    }, 1000);
                }, 100);
            }, 400);
        }
        
        // Load snake names
        async function loadSnakeNames() {
            try {
                const response = await fetch('snake-names.json');
                const data = await response.json();
                snakeNameData = data;
                console.log('Loaded snake names data');
            } catch (error) {
                console.error('Failed to load snake names:', error);
                // Fallback data
                snakeNameData = {
                    firstParts: ['Sir', 'Lord', 'Captain', 'Master', 'Swift', 'Mighty', 'Sneaky'],
                    secondParts: ['Slithers', 'McSlitherface', 'the Magnificent', 'Noodle', 'Supreme']
                };
            }
        }
        
        // Generate random snake name
        function generateSnakeName() {
            if (!snakeNameData) {
                return `Snake${Math.floor(Math.random() * 1000)}`;
            }
            const first = snakeNameData.firstParts[Math.floor(Math.random() * snakeNameData.firstParts.length)];
            const second = snakeNameData.secondParts[Math.floor(Math.random() * snakeNameData.secondParts.length)];
            return `${first} ${second}`;
        }
        
        // Load element database
        async function loadElements() {
            try {
                document.getElementById('loadingIndicator').style.display = 'block';
                
                // Wait for the new element system to load
                if (!window.elementLoader || !window.elementCompatibility) {
                    // Wait for elementsLoaded event
                    await new Promise((resolve) => {
                        window.addEventListener('elementsLoaded', resolve, { once: true });
                    });
                }
                
                // Use the compatibility layer to get legacy format
                const legacyData = window.elementCompatibility.legacyCache;
                
                // Update local references
                elementDatabase = legacyData.elements;
                combinations = legacyData.combinations;
                
                console.log(`Loaded ${Object.keys(elementDatabase).length} elements and ${Object.keys(combinations).length} combinations`);
                document.getElementById('loadingIndicator').style.display = 'none';
            } catch (error) {
                console.error('Failed to load elements:', error);
                // Fallback to basic elements
                elementDatabase = {
                    fire: { emoji: 'üî•', name: 'Fire', tier: 0, base: true },
                    water: { emoji: 'üíß', name: 'Water', tier: 0, base: true },
                    earth: { emoji: 'üåç', name: 'Earth', tier: 0, base: true },
                    air: { emoji: 'üí®', name: 'Air', tier: 0, base: true }
                };
                document.getElementById('loadingIndicator').style.display = 'none';
            }
        }
        
        // Sound effects
        let eatSound = null;
        let explosionSound = null;
        
        function initSoundEffects() {
            // Preload eating sound
            eatSound = new Audio('sounds/8-bit-blip.mp3');
            eatSound.volume = 0.5; // 50% volume
            
            // Preload explosion sound
            explosionSound = new Audio('sounds/fire-impact.mp3');
            explosionSound.volume = 0.75; // 75% volume
        }
        
        function playEatSound() {
            if (eatSound && !musicMuted) {
                // Clone the audio to allow overlapping sounds
                const sound = eatSound.cloneNode();
                sound.volume = eatSound.volume;
                sound.play().catch(e => console.log('Eat sound blocked:', e));
            }
        }
        
        function playExplosionSound() {
            if (explosionSound && !musicMuted) {
                // Clone the audio to allow overlapping sounds
                const sound = explosionSound.cloneNode();
                sound.volume = explosionSound.volume;
                sound.play().catch(e => console.log('Explosion sound blocked:', e));
            }
        }
        
        // Music functions
        function initMusic() {
            // Check which tracks are available
            checkAvailableTracks().then(() => {
                if (availableTracks.length > 0) {
                    playRandomTrack();
                }
            });
        }
        
        async function checkAvailableTracks() {
            // For now, assume all tracks are available
            availableTracks = [...musicTracks];
            console.log('Available tracks loaded:', availableTracks);
            return true;
        }
        
        let isPlayingNext = false; // Prevent multiple simultaneous calls
        
        function playRandomTrack() {
            // Prevent multiple simultaneous calls
            if (isPlayingNext) {
                console.log('Already playing next track, ignoring call');
                return;
            }
            isPlayingNext = true;
            
            // Refill available tracks if empty
            if (availableTracks.length === 0) {
                console.log('Refilling available tracks...');
                availableTracks = [...musicTracks];
            }
            
            // Stop current track if playing
            if (currentTrack && currentTrack.stopRequested !== true) {
                // Mark that we're stopping this track intentionally
                currentTrack.stopRequested = true;
                // Remove all event listeners to prevent them from firing
                currentTrack.removeEventListener('ended', currentTrack.endedHandler);
                currentTrack.removeEventListener('error', currentTrack.errorHandler);
                currentTrack.pause();
                // Don't clear src as it can trigger ended event
                currentTrack = null; // Clear reference
            }
            
            // Pick random track
            const randomIndex = Math.floor(Math.random() * availableTracks.length);
            const trackName = availableTracks[randomIndex];
            
            // Remove the selected track from available tracks
            availableTracks.splice(randomIndex, 1);
            console.log(`Playing: ${trackName}, remaining tracks: ${availableTracks.length}`);
            
            // Create audio element
            currentTrack = new Audio(`music/${trackName}`);
            currentTrack.volume = musicMuted ? 0 : musicVolume;
            
            // Create event handlers that we can reference later for removal
            currentTrack.endedHandler = function() {
                console.log(`Track "${trackName}" ended, stopRequested: ${this.stopRequested}, currentTime: ${this.currentTime}, duration: ${this.duration}`);
                // Only play next if the track wasn't stopped intentionally and actually ended
                if (!this.stopRequested && this.currentTime > 0 && this.duration > 0 && this.currentTime >= this.duration - 0.5) {
                    console.log('Track ended naturally, playing next track...');
                    setTimeout(() => {
                        try {
                            playRandomTrack();
                        } catch (error) {
                            console.error('Error playing next track:', error);
                            // Try again in a few seconds
                            setTimeout(playRandomTrack, 3000);
                        }
                    }, 1000); // Wait 1 second before next track
                } else {
                    console.log('Track was stopped or ended prematurely, not playing next track');
                }
            };
            
            currentTrack.errorHandler = (e) => {
                console.error('Error loading track:', trackName, e);
                // Try next track after a short delay
                setTimeout(() => {
                    playRandomTrack();
                }, 1000);
            };
            
            // Add event listeners
            currentTrack.addEventListener('ended', currentTrack.endedHandler);
            currentTrack.addEventListener('error', currentTrack.errorHandler);
            
            // Try to play
            const playPromise = currentTrack.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Music started playing successfully');
                    isPlayingNext = false; // Reset flag on success
                }).catch(e => {
                    console.log('Music autoplay blocked:', e.message);
                    // Store track to retry on user interaction
                    window.pendingMusicTrack = currentTrack;
                    isPlayingNext = false; // Reset flag on error
                });
            } else {
                isPlayingNext = false; // Reset flag if no promise
            }
        }
        
        window.toggleMusic = function() {
            musicMuted = !musicMuted;
            const button = document.getElementById('muteButton');
            
            if (musicMuted) {
                button.textContent = 'üîá Unmute';
                if (currentTrack) currentTrack.volume = 0;
            } else {
                button.textContent = 'üîä Mute';
                if (currentTrack) currentTrack.volume = musicVolume;
            }
        };
        
        window.changeVolume = function(value) {
            musicVolume = value / 100;
            document.getElementById('volumeDisplay').textContent = value + '%';
            
            if (currentTrack && !musicMuted) {
                currentTrack.volume = musicVolume;
            }
        };
        
        // Border particle class
        class BorderParticle {
            constructor(x, y, edge) {
                this.x = x;
                this.y = y;
                this.edge = edge; // 'left', 'right', 'top', 'bottom'
                this.baseX = x;
                this.baseY = y;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 0.5 + 0.1;
                this.offset = Math.random() * Math.PI * 2;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = this.getRandomColor();
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(147, 51, 234, ', // purple
                    'rgba(236, 72, 153, ', // pink
                    'rgba(59, 130, 246, ', // blue
                    'rgba(168, 85, 247, ', // purple-pink
                    'rgba(99, 102, 241, '  // indigo
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(deltaTime) {
                const time = animationTime + this.offset;
                
                // Float in circular motion
                const radius = 15;
                const floatX = Math.cos(time * this.speed) * radius;
                const floatY = Math.sin(time * this.speed * 0.7) * radius;
                
                this.x = this.baseX + floatX;
                this.y = this.baseY + floatY;
                
                // Pulse opacity
                this.opacity = 0.3 + Math.sin(time * 2) * 0.2;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color + this.opacity + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color + '0.8)';
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Snake class
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.segments = [];
                this.elements = [];
                this.elementCapacity = 4; // Start with 4 element squares
                this.elementsEaten = 0; // Track total elements eaten for capacity growth
                this.length = 10;
                this.score = 0;
                this.discoveries = 0; // Track discoveries for this snake
                this.alive = true;
                this.isPlayer = isPlayer;
                this.speed = SNAKE_SPEED;
                this.name = isPlayer ? 'You' : generateSnakeName();
                this.invincibilityTimer = 0;
                this.discoveredElements = new Set(['fire', 'water', 'earth', 'air']); // Each snake tracks its own discoveries
                
                // Assign skin
                if (isPlayer) {
                    this.skin = currentPlayerSkin;
                } else {
                    // Random AI skin from all available skins
                    const allSkins = Object.keys(skinMetadata);
                    this.skin = allSkins[Math.floor(Math.random() * allSkins.length)];
                }
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    this.segments.push({
                        x: x - i * SEGMENT_SIZE * Math.cos(this.angle),
                        y: y - i * SEGMENT_SIZE * Math.sin(this.angle)
                    });
                }
                
                // Start with some random elements
                const basicElements = ['fire', 'water', 'earth', 'air'];
                for (let i = 0; i < 3; i++) {
                    this.elements.push(basicElements[Math.floor(Math.random() * basicElements.length)]);
                }
            }
            
            update() {
                if (!this.alive) return;
                
                // Update invincibility
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= 16; // Approx 60fps
                }
                
                // Handle controls
                if (this.isPlayer) {
                    if (controlScheme === 'arrows') {
                        if (keys['ArrowLeft']) this.angle -= TURN_SPEED;
                        if (keys['ArrowRight']) this.angle += TURN_SPEED;
                    } else if (controlScheme === 'wasd') {
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED;
                    } else if (controlScheme === 'mouse') {
                        // Smooth angle interpolation
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.1;
                    }
                } else {
                    // AI with border avoidance
                    const borderDanger = 100; // Distance from border to start avoiding
                    const emergencyDistance = 50; // Emergency turn distance
                    
                    // Check distance to borders
                    const distToLeftBorder = this.x;
                    const distToRightBorder = WORLD_SIZE - this.x;
                    const distToTopBorder = this.y;
                    const distToBottomBorder = WORLD_SIZE - this.y;
                    
                    // Determine if we're too close to any border
                    const nearBorder = distToLeftBorder < borderDanger || distToRightBorder < borderDanger ||
                                     distToTopBorder < borderDanger || distToBottomBorder < borderDanger;
                    
                    const emergencyTurn = distToLeftBorder < emergencyDistance || distToRightBorder < emergencyDistance ||
                                        distToTopBorder < emergencyDistance || distToBottomBorder < emergencyDistance;
                    
                    if (emergencyTurn) {
                        // Emergency evasion - turn away from nearest border
                        let avoidAngle = this.angle;
                        
                        if (distToLeftBorder < emergencyDistance) {
                            avoidAngle = 0; // Turn right
                        } else if (distToRightBorder < emergencyDistance) {
                            avoidAngle = Math.PI; // Turn left
                        }
                        
                        if (distToTopBorder < emergencyDistance) {
                            avoidAngle = Math.PI / 2; // Turn down
                        } else if (distToBottomBorder < emergencyDistance) {
                            avoidAngle = -Math.PI / 2; // Turn up
                        }
                        
                        let angleDiff = avoidAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.15; // Aggressive turn
                    } else {
                        // Normal AI - find nearest element but avoid borders
                        let nearestElement = null;
                        let minDist = 500;
                        
                        for (const element of elements) {
                            const dist = Math.hypot(element.x - this.x, element.y - this.y);
                            
                            // Skip elements that are too close to borders
                            if (nearBorder) {
                                const elemNearBorder = element.x < borderDanger || element.x > WORLD_SIZE - borderDanger ||
                                                     element.y < borderDanger || element.y > WORLD_SIZE - borderDanger;
                                if (elemNearBorder) continue;
                            }
                            
                            if (dist < minDist) {
                                minDist = dist;
                                nearestElement = element;
                            }
                        }
                        
                        if (nearestElement) {
                            const targetAngle = Math.atan2(nearestElement.y - this.y, nearestElement.x - this.x);
                            let angleDiff = targetAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            
                            // Slower turning when near borders to be more careful
                            const turnSpeed = nearBorder ? 0.05 : 0.08;
                            this.angle += angleDiff * turnSpeed;
                        } else {
                            // Wander randomly, but bias away from borders
                            let wanderAngle = (Math.random() - 0.5) * 0.1;
                            
                            // Add bias away from borders
                            if (this.x < 200) wanderAngle += 0.05; // Bias right
                            if (this.x > WORLD_SIZE - 200) wanderAngle -= 0.05; // Bias left
                            if (this.y < 200 && Math.cos(this.angle) < 0.5) wanderAngle = Math.abs(wanderAngle); // Bias down
                            if (this.y > WORLD_SIZE - 200 && Math.cos(this.angle) > -0.5) wanderAngle = -Math.abs(wanderAngle); // Bias up
                            
                            this.angle += wanderAngle;
                        }
                    }
                }
                
                // Move head
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // World boundaries
                if (this.x < 0 || this.x > WORLD_SIZE || this.y < 0 || this.y > WORLD_SIZE) {
                    this.die();
                    return;
                }
                
                // Update segments
                this.segments.unshift({ x: this.x, y: this.y });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
            }
            
            checkCombinations() {
                if (this.elements.length < 2) return;
                
                // Check all possible pairs for combinations
                for (let i = 0; i < this.elements.length; i++) {
                    for (let j = i + 1; j < this.elements.length; j++) {
                        const elem1 = this.elements[i];
                        const elem2 = this.elements[j];
                        
                        // Use the new element system for combination checking if available
                        let result = null;
                        if (window.elementLoader && window.elementCompatibility) {
                            const resultElement = window.elementLoader.getCombinationByKeys(elem1, elem2);
                            result = resultElement ? resultElement.key : null;
                            
                            // Debug logging
                            if (this.isPlayer && (elem1 === 'water' || elem2 === 'water') && (elem1 === 'ice' || elem2 === 'ice')) {
                                console.log(`Checking combination: ${elem1} + ${elem2}`);
                                console.log('Result element:', resultElement);
                                console.log('Result key:', result);
                            }
                        } else {
                            // Fallback to old system
                            const combo1 = `${elem1}+${elem2}`;
                            const combo2 = `${elem2}+${elem1}`;
                            result = combinations[combo1] || combinations[combo2];
                        }
                        
                        if (result && elementDatabase[result]) {
                            // Keep the result in the collection instead of removing elements
                            // Add the result to the collection
                            this.elements.push(result);
                            
                            // Remove the two original elements (remove j first since it's higher index)
                            this.elements.splice(j, 1);
                            this.elements.splice(i, 1);
                            
                            // Discovery check
                            if (!this.discoveredElements.has(result)) {
                                this.discoveredElements.add(result);
                                this.score += 1000; // 1000 points for new discovery
                                this.discoveries++; // Increment discovery count
                                
                                // Additional effects for player
                                if (this.isPlayer && this === playerSnake) {
                                    discoveredElements.add(result); // Update global discoveries
                                    
                                    // Update new system if available
                                    if (window.elementLoader && window.elementCompatibility) {
                                        const element = window.elementLoader.getElementByKey(result);
                                        if (element) {
                                            window.elementLoader.discoverElement(element.id);
                                            window.elementCompatibility.saveDiscoveredElements();
                                        }
                                    }
                                    
                                    showCombinationMessage(elem1, elem2, result, true); // Show new discovery
                                    // Grant invincibility on new discovery
                                    this.invincibilityTimer = 3000; // 3 seconds
                                    
                                    // Check for new high score
                                    if (this.score > highScore) {
                                        highScore = this.score;
                                        localStorage.setItem('highScore', highScore.toString());
                                    }
                                }
                            } else {
                                // Show popup for existing discovery
                                if (this.isPlayer && this === playerSnake) {
                                    showCombinationMessage(elem1, elem2, result, false); // Show combo
                                }
                            }
                            
                            // Create particle effect at snake head
                            createCombinationParticles(this.segments[0].x, this.segments[0].y);
                            
                            // Restart checking from the beginning
                            this.checkCombinations();
                            return;
                        }
                    }
                }
            }
            
            consume(element) {
                // Check if we have space
                if (this.elements.length >= this.elementCapacity) {
                    // Digest all elements when full
                    this.digest();
                }
                
                // Play eating sound for player only
                if (this.isPlayer) {
                    playEatSound();
                }
                
                // Add element to snake
                this.elements.push(element.type);
                
                // Track elements eaten for capacity growth
                this.elementsEaten++;
                
                // Progressive capacity growth - gets harder each time
                const capacityLevel = Math.floor((this.elementCapacity - 4) / 2); // Current capacity level
                const elementsNeededForNext = 10 + (capacityLevel * 5); // 10, 15, 20, 25, etc.
                const elementsForThisLevel = capacityLevel === 0 ? this.elementsEaten : 
                    this.elementsEaten - (10 + ((capacityLevel - 1) * capacityLevel * 5 / 2)); // Sum of arithmetic sequence
                
                if (elementsForThisLevel >= elementsNeededForNext && this.elementCapacity < 30) {
                    this.elementCapacity += 2;
                    if (this.isPlayer && this === playerSnake) {
                        // Visual feedback for capacity growth
                        showMessage(`Element capacity increased to ${this.elementCapacity}! Next upgrade: ${10 + ((capacityLevel + 1) * 5)} elements`, false);
                    }
                }
                
                // Grow snake
                this.length += 2;
                
                // Add score - 100 points per element
                this.score += 100;
                
                // Check for new high score
                if (this.isPlayer && this.score > highScore) {
                    highScore = this.score;
                    localStorage.setItem('highScore', highScore.toString());
                }
                
                // Remove element from world
                const index = elements.indexOf(element);
                if (index > -1) elements.splice(index, 1);
                
                // Update UI if player
                if (this.isPlayer) {
                    updateUI();
                }
            }
            
            digest() {
                if (!this.isPlayer || this.elements.length === 0) {
                    // Non-player digestion happens instantly
                    const digestedCount = this.elements.length;
                    this.elements = [];
                    
                    // Bonus points for digestion based on how full we were
                    const digestBonus = Math.floor(digestedCount * 50);
                    this.score += digestBonus;
                    
                    // Check for new high score
                    if (this.isPlayer && this.score > highScore) {
                        highScore = this.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                    return;
                }
                
                // Player digestion - show message immediately
                const digestedCount = this.elements.length;
                
                // Clear all elements immediately
                this.elements = [];
                
                // Bonus points for digestion based on how full we were
                const digestBonus = Math.floor(digestedCount * 50);
                this.score += digestBonus;
                
                // Show digestion message for player only
                if (this.isPlayer && this === playerSnake) {
                    showMessage(`Digesting ${digestedCount} elements! +${digestBonus} points`, false);
                    // Update UI immediately
                    updateUI();
                }
            }
            
            die() {
                this.alive = false;
                
                // Drop all elements
                for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    spawnElement(this.elements[i], segment.x, segment.y);
                }
                
                // Create death particles
                createDeathParticles(this.x, this.y);
                
                // Respawn if player
                if (this.isPlayer) {
                    // Lose half points and half capacity on death
                    const oldScore = this.score;
                    const oldDiscoveries = this.discoveries;
                    const oldDiscoveredElements = new Set(this.discoveredElements);
                    const oldElementsEaten = this.elementsEaten;
                    const oldCapacity = this.elementCapacity;
                    
                    setTimeout(() => {
                        // Remove the old dead player snake before creating new one
                        snakes = snakes.filter(s => s !== this);
                        
                        playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
                        playerSnake.score = Math.floor(oldScore / 2); // Keep half points
                        playerSnake.discoveries = oldDiscoveries; // Keep discoveries
                        playerSnake.discoveredElements = oldDiscoveredElements; // Keep discovered elements
                        playerSnake.elementsEaten = Math.floor(oldElementsEaten / 2); // Lose half progress
                        playerSnake.elementCapacity = Math.max(4, Math.floor(oldCapacity / 2)); // Lose half capacity (min 4)
                        snakes.push(playerSnake);
                    }, 3000);
                }
            }
            
            explode(killer) {
                // Play explosion sound
                playExplosionSound();
                
                // Award points to killer
                if (killer && killer.alive) {
                    killer.score += 500; // 500 points for snake explosion
                    
                    // Check for new high score if player
                    if (killer.isPlayer && killer.score > highScore) {
                        highScore = killer.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                }
                this.die();
            }
            
            draw() {
                if (!this.alive) return;
                
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    const screenX = segment.x - camera.x + canvas.width / 2;
                    const screenY = segment.y - camera.y + canvas.height / 2;
                    
                    // Skip if off-screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    // Snake body color based on skin
                    const skinData = skinMetadata[this.skin];
                    const colors = skinData ? skinData.colors : ['#4ecdc4', '#45b7aa'];
                    
                    if (this.invincibilityTimer > 0 && this.isPlayer) {
                        // Flash effect during invincibility
                        const flash = Math.sin(this.invincibilityTimer * 0.01) > 0;
                        ctx.fillStyle = flash ? '#FFD700' : colors[i % colors.length];
                    } else {
                        ctx.fillStyle = colors[i % colors.length];
                    }
                    
                    ctx.beginPath();
                    // Ensure segment radius never goes below 1 pixel
                    const segmentRadius = Math.max(1, SEGMENT_SIZE - Math.min(i * 0.05, SEGMENT_SIZE - 1));
                    ctx.arc(screenX, screenY, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    const screenX = head.x - camera.x + canvas.width / 2;
                    const screenY = head.y - camera.y + canvas.height / 2;
                    
                    // Draw skin image
                    const skinImage = skinImages[this.skin];
                    if (skinImage && skinImage.complete) {
                        ctx.save();
                        ctx.translate(screenX, screenY);
                        ctx.rotate(this.angle - Math.PI/2); // Rotate 90 degrees counter-clockwise so top faces body
                        const size = SEGMENT_SIZE * 3.1625; // Increased by 25% (2.875 * 1.1)
                        ctx.drawImage(skinImage, -size/2, -size/2, size, size);
                        ctx.restore();
                    } else {
                        // Fallback to emoji if image not loaded
                        ctx.font = `${SEGMENT_SIZE * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.isPlayer ? 'üòä' : 'üêç', screenX, screenY);
                    }
                    
                    // Draw name
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.name, screenX, screenY - SEGMENT_SIZE - 10);
                    ctx.fillText(this.name, screenX, screenY - SEGMENT_SIZE - 10);
                    
                    // Draw crown if leader
                    if (this.isLeader) {
                        ctx.font = '24px Arial';
                        ctx.fillText('üëë', screenX, screenY - SEGMENT_SIZE - 30);
                    }
                }
            }
        }
        
        // Element class
        class Element {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.data = elementDatabase[type];
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.05;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                // Glow effect
                if (this.data.tier > 0) {
                    const glowSize = ELEMENT_SIZE * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Draw emoji
                ctx.font = `${ELEMENT_SIZE * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.data.emoji, screenX, screenY);
                
                // Draw element name below emoji
                ctx.font = '10px Arial';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(this.data.name, screenX, screenY + ELEMENT_SIZE + 5);
                ctx.fillText(this.data.name, screenX, screenY + ELEMENT_SIZE + 5);
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.vx *= 0.98;
                this.vy *= 0.98;
                return this.life > 0;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // Shooting Star class
        class ShootingStar {
            constructor() {
                // Random starting position on screen edge
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // Top
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = 0;
                        break;
                    case 1: // Right
                        this.x = WORLD_SIZE;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = WORLD_SIZE;
                        break;
                    case 3: // Left
                        this.x = 0;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                }
                
                // Random angle and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = 15 + Math.random() * 10; // Fast movement
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.trail = [];
                this.maxTrailLength = 20;
                this.life = 1.0;
                this.fadeSpeed = 0.01; // Slower fade for 1-2 second visibility
            }
            
            update() {
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y, alpha: this.life });
                
                // Limit trail length
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Fade out
                this.life -= this.fadeSpeed;
                
                // Update trail alpha
                this.trail.forEach((point, index) => {
                    point.alpha = (index / this.trail.length) * this.life;
                });
                
                // Check if out of bounds or faded
                return this.life > 0 && this.x > -100 && this.x < WORLD_SIZE + 100 && 
                       this.y > -100 && this.y < WORLD_SIZE + 100;
            }
            
            draw() {
                // Draw trail
                ctx.save();
                this.trail.forEach((point, index) => {
                    const screenX = point.x - camera.x + canvas.width / 2;
                    const screenY = point.y - camera.y + canvas.height / 2;
                    
                    ctx.globalAlpha = point.alpha * 0.5;
                    ctx.fillStyle = '#ffffff';
                    const size = (index / this.trail.length) * 3;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main star
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Helper functions
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Use tier-based spawning if new system is available
                if (window.elementLoader) {
                    const rand = Math.random();
                    let selectedElement;
                    
                    if (rand < 0.7) {
                        // 70% chance for tier 0 (basic) elements
                        const tier0Elements = window.elementLoader.getElementsByTier(0);
                        selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                    } else if (rand < 0.9) {
                        // 20% chance for tier 1 elements
                        const tier1Elements = window.elementLoader.getElementsByTier(1);
                        if (tier1Elements.length > 0) {
                            selectedElement = tier1Elements[Math.floor(Math.random() * tier1Elements.length)];
                        } else {
                            // Fallback to tier 0
                            const tier0Elements = window.elementLoader.getElementsByTier(0);
                            selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                        }
                    } else {
                        // 10% chance for tier 2+ elements (if discovered)
                        const allElements = window.elementLoader.getAllElements();
                        const higherTierElements = allElements.filter(e => e.tier >= 2 && discoveredElements.has(e.key));
                        if (higherTierElements.length > 0) {
                            selectedElement = higherTierElements[Math.floor(Math.random() * higherTierElements.length)];
                        } else {
                            // Fallback to tier 1 or 0
                            const tier1Elements = window.elementLoader.getElementsByTier(1);
                            if (tier1Elements.length > 0) {
                                selectedElement = tier1Elements[Math.floor(Math.random() * tier1Elements.length)];
                            } else {
                                const tier0Elements = window.elementLoader.getElementsByTier(0);
                                selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                            }
                        }
                    }
                    
                    type = selectedElement.key;
                } else {
                    // Fallback to old system
                    const rand = Math.random();
                    if (rand < 0.7) {
                        // Basic element
                        const basics = ['fire', 'water', 'earth', 'air'];
                        type = basics[Math.floor(Math.random() * basics.length)];
                    } else {
                        // Any discovered element
                        const available = Object.keys(elementDatabase);
                        type = available[Math.floor(Math.random() * available.length)];
                    }
                }
            }
            
            // Random position if not specified
            if (!x || !y) {
                x = 100 + Math.random() * (WORLD_SIZE - 200);
                y = 100 + Math.random() * (WORLD_SIZE - 200);
            }
            
            elements.push(new Element(type, x, y));
        }
        
        function createCombinationParticles(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const speed = 2 + Math.random() * 3;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    `hsl(${Math.random() * 360}, 70%, 50%)`
                ));
            }
        }
        
        function createDeathParticles(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    '#ff0000'
                ));
            }
        }
        
        function showCombinationMessage(elem1, elem2, result, isNew) {
            const elem1Data = elementDatabase[elem1];
            const elem2Data = elementDatabase[elem2];
            const resultData = elementDatabase[result];
            
            let message = `${elem1Data.emoji} + ${elem2Data.emoji} = ${resultData.emoji} ${resultData.name}`;
            if (isNew) {
                message = `New Discovery! ${message}`;
                // Update discovery log for new discoveries
                lastDiscoveredElement = result;
                updateDiscoveryLog();
            } else {
                message = `Combo! ${message}`;
            }
            
            showMessage(message, isNew);
        }
        
        function showMessage(text, isDiscovery) {
            const popup = document.getElementById('recentDiscovery');
            popup.textContent = text;
            popup.className = isDiscovery ? 'show' : 'show combo';
            popup.style.opacity = '1';
            
            // Clear any existing timeout
            if (popup.hideTimeout) {
                clearTimeout(popup.hideTimeout);
            }
            
            // Set new timeout
            popup.hideTimeout = setTimeout(() => {
                popup.style.opacity = '0';
                popup.className = '';
            }, 3000);
        }
        
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboard-list');
            
            // Sort snakes based on game mode
            let sortedSnakes = [...snakes].filter(s => s.alive);
            
            if (gameMode === 'discovery') {
                // Sort by discoveries, then by score
                sortedSnakes.sort((a, b) => {
                    if (b.discoveries !== a.discoveries) {
                        return b.discoveries - a.discoveries;
                    }
                    return b.score - a.score;
                });
            } else {
                // Sort by score
                sortedSnakes.sort((a, b) => b.score - a.score);
            }
            
            // Mark the leader
            snakes.forEach(s => s.isLeader = false);
            if (sortedSnakes.length > 0) {
                sortedSnakes[0].isLeader = true;
            }
            
            // Display top 5
            leaderboardList.innerHTML = '';
            sortedSnakes.slice(0, 5).forEach((snake, index) => {
                const div = document.createElement('div');
                div.className = snake === sortedSnakes[0] ? 'leader' : '';
                if (snake.isPlayer) div.className += ' player';
                
                let text = `${index + 1}. ${snake.name} - `;
                if (gameMode === 'discovery') {
                    text += `${snake.discoveries} discoveries (${Math.floor(snake.score)} pts)`;
                } else {
                    text += `${Math.floor(snake.score)} points`;
                }
                
                div.textContent = text;
                leaderboardList.appendChild(div);
            });
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            // Get all discovered elements and sort by tier (highest first)
            const discovered = Array.from(discoveredElements)
                .filter(key => {
                    const element = elementDatabase[key];
                    return element && element.tier > 0;
                })
                .sort((a, b) => {
                    const elemA = elementDatabase[a];
                    const elemB = elementDatabase[b];
                    // Sort by tier descending, then alphabetically
                    if (elemB.tier !== elemA.tier) {
                        return elemB.tier - elemA.tier;
                    }
                    return a.localeCompare(b);
                });
            
            discovered.forEach(elementKey => {
                const element = elementDatabase[elementKey];
                if (element) {
                    const div = document.createElement('div');
                    div.className = 'discovery-item';
                    
                    // Highlight if this is the newest discovery
                    if (elementKey === lastDiscoveredElement) {
                        div.classList.add('new');
                    }
                    
                    div.innerHTML = `
                        <div class="emoji">${element.emoji}</div>
                        <div class="info">
                            <div class="name">${element.name}</div>
                            <div class="tier">Tier ${element.tier}</div>
                        </div>
                    `;
                    list.appendChild(div);
                }
            });
            
            // Update count in header
            const header = document.querySelector('#discoveryLog h3');
            if (header) {
                header.textContent = `Discoveries (${discovered.length})`;
            }
        }
        
        function updateUI() {
            if (!playerSnake) return;
            
            document.getElementById('score').textContent = `Score: ${Math.floor(playerSnake.score)}`;
            
            // Update high score display if current score is higher
            if (playerSnake.score > highScore) {
                document.getElementById('score').innerHTML = `Score: ${Math.floor(playerSnake.score)} <span style="color: #FFD700; font-size: 16px;">(NEW HIGH SCORE!)</span>`;
            }
            
            // Update discoveries count based on game mode
            const discoveryCount = discoveredElements.size - 4; // Subtract base elements
            if (gameMode === 'discovery') {
                document.getElementById('discoveries').textContent = `Discoveries: ${discoveryCount} / ${gameTarget}`;
            } else {
                document.getElementById('discoveries').textContent = `Discoveries: ${discoveryCount}`;
            }
            
            // Check victory condition
            if (gameMode === 'discovery' && discoveryCount >= gameTarget) {
                alert(`Victory! You discovered ${gameTarget} elements!`);
                location.reload();
            } else if (gameMode === 'points' && playerSnake.score >= gameTarget) {
                alert(`Victory! You reached ${gameTarget.toLocaleString()} points!`);
                location.reload();
            }
            
            // Update leaderboard
            updateLeaderboard();
            
            // Update element queue
            const queue = document.getElementById('elementQueue');
            queue.innerHTML = '';
            
            // Create squares for the full capacity
            for (let i = 0; i < playerSnake.elementCapacity; i++) {
                const div = document.createElement('div');
                div.className = 'element-square';
                
                if (i < playerSnake.elements.length) {
                    // Filled square with element
                    const elementType = playerSnake.elements[i];
                    const element = elementDatabase[elementType];
                    if (element) {
                        div.classList.add('filled');
                        div.innerHTML = `<div>${element.emoji}</div><div class="element-name">${element.name}</div>`;
                        div.title = element.name;
                    }
                } else {
                    // Empty square
                    div.classList.add('empty');
                }
                
                queue.appendChild(div);
            }
        }
        
        function checkCollisions() {
            for (const snake of snakes) {
                if (!snake.alive) continue;
                
                // Check element collisions
                for (const element of elements) {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + ELEMENT_SIZE) {
                        snake.consume(element);
                    }
                }
                
                // Check snake collisions (skip if invincible)
                if (snake.invincibilityTimer > 0) continue;
                
                for (const otherSnake of snakes) {
                    if (snake === otherSnake || !otherSnake.alive) continue;
                    
                    // Check head collision with other snake's body
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        if (dist < SEGMENT_SIZE) {
                            snake.explode(otherSnake);
                            break;
                        }
                    }
                    
                    // Check head-to-head collision
                    if (snake.alive && otherSnake.alive) {
                        const headDist = Math.hypot(otherSnake.x - snake.x, otherSnake.y - snake.y);
                        if (headDist < SEGMENT_SIZE) {
                            // Smaller snake explodes, or both if same size
                            if (snake.length < otherSnake.length) {
                                snake.explode(otherSnake);
                            } else if (otherSnake.length < snake.length) {
                                otherSnake.explode(snake);
                            } else {
                                // Same size - both explode, no points awarded
                                snake.die();
                                otherSnake.die();
                            }
                        }
                    }
                }
            }
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw static stars (before grid so they appear behind)
            ctx.save();
            staticStars.forEach(star => {
                const screenX = star.x - camera.x + canvas.width / 2;
                const screenY = star.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen
                if (screenX < -10 || screenX > canvas.width + 10 ||
                    screenY < -10 || screenY > canvas.height + 10) return;
                
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // Draw shooting stars
            shootingStars.forEach(star => star.draw());
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw world borders with nebula effect
            const borderThickness = 50; // Increased for gradient effect
            const leftBorder = -camera.x + canvas.width / 2;
            const rightBorder = WORLD_SIZE - camera.x + canvas.width / 2;
            const topBorder = -camera.y + canvas.height / 2;
            const bottomBorder = WORLD_SIZE - camera.y + canvas.height / 2;
            
            // Pulsating glow intensity
            const glowIntensity = 0.7 + Math.sin(animationTime * 2) * 0.3;
            
            // Create nebula gradient function
            function createNebulaGradient(x0, y0, x1, y1) {
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, `rgba(147, 51, 234, ${glowIntensity})`); // purple
                gradient.addColorStop(0.3, `rgba(236, 72, 153, ${glowIntensity * 0.8})`); // pink
                gradient.addColorStop(0.6, `rgba(59, 130, 246, ${glowIntensity * 0.6})`); // blue
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // fade to transparent
                return gradient;
            }
            
            // Left border nebula
            if (leftBorder > -borderThickness) {
                const borderWidth = Math.max(borderThickness, leftBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, borderWidth, 0);
                ctx.fillRect(0, 0, borderWidth, canvas.height);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(Math.max(10, leftBorder), 0);
                ctx.lineTo(Math.max(10, leftBorder), canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Right border nebula
            if (rightBorder < canvas.width + borderThickness) {
                ctx.fillStyle = createNebulaGradient(canvas.width, 0, rightBorder, 0);
                ctx.fillRect(rightBorder, 0, canvas.width - rightBorder, canvas.height);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rightBorder, 0);
                ctx.lineTo(rightBorder, canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Top border nebula
            if (topBorder > -borderThickness) {
                const borderHeight = Math.max(borderThickness, topBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, 0, borderHeight);
                ctx.fillRect(0, 0, canvas.width, borderHeight);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, Math.max(10, topBorder));
                ctx.lineTo(canvas.width, Math.max(10, topBorder));
                ctx.stroke();
                ctx.restore();
            }
            
            // Bottom border nebula
            if (bottomBorder < canvas.height + borderThickness) {
                ctx.fillStyle = createNebulaGradient(0, canvas.height, 0, bottomBorder);
                ctx.fillRect(0, bottomBorder, canvas.width, canvas.height - bottomBorder);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, bottomBorder);
                ctx.lineTo(canvas.width, bottomBorder);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw border particles
            borderParticles.forEach(particle => {
                // Only draw particles that are visible on screen
                if (particle.edge === 'left' && leftBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'right' && rightBorder < canvas.width + borderThickness + 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'top' && topBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'bottom' && bottomBorder < canvas.height + borderThickness + 20) {
                    particle.draw(ctx);
                }
            });
        }
        
        // Game functions
        function initializeStaticStars() {
            staticStars = [];
            const starCount = 200; // Sparse distribution
            
            for (let i = 0; i < starCount; i++) {
                staticStars.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: Math.random() * 2 + 1, // 1-3px
                    opacity: Math.random() * 0.2 + 0.1, // 0.1-0.3 opacity
                    color: Math.random() > 0.5 ? '#ffffff' : '#e0e8ff' // white or pale blue
                });
            }
        }
        
        function initializeBorderParticles() {
            borderParticles = [];
            
            // Create particles along each border
            const particleSpacing = 30;
            
            // Left border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(Math.random() * 30, y, 'left'));
                }
            }
            
            // Right border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(canvas.width - Math.random() * 30, y, 'right'));
                }
            }
            
            // Top border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, Math.random() * 30, 'top'));
                }
            }
            
            // Bottom border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, canvas.height - Math.random() * 30, 'bottom'));
                }
            }
        }
        
        function startGame() {
            gameStarted = true;
            
            // Create player snake
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            snakes.push(playerSnake);
            
            // Create AI snakes
            for (let i = 0; i < 5; i++) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            
            // Spawn initial elements
            for (let i = 0; i < 50; i++) {
                spawnElement();
            }
            
            // Initialize music and sound effects
            initMusic();
            initSoundEffects();
            
            // Update discovery log
            updateDiscoveryLog();
            
            // Initialize border particles
            initializeBorderParticles();
            
            // Initialize static stars
            initializeStaticStars();
            
            gameLoop();
        }
        
        function togglePause() {
            if (!gameStarted) return;
            paused = !paused;
            document.getElementById('pauseOverlay').style.display = paused ? 'flex' : 'none';
            
            // Update music button state
            if (paused) {
                const muteButton = document.getElementById('muteButton');
                muteButton.textContent = musicMuted ? 'üîá Unmute' : 'üîä Mute';
                document.getElementById('volumeSlider').value = musicVolume * 100;
                document.getElementById('volumeDisplay').textContent = Math.round(musicVolume * 100) + '%';
                
                // Update skin selection UI
                calculateAvailableUnlocks();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Update high score display
                document.getElementById('highScoreDisplay').textContent = Math.floor(highScore).toLocaleString();
            }
        }
        
        window.resumeGame = function() {
            paused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
        }
        
        // Build skin selection UI
        function buildSkinGrid() {
            const grid = document.getElementById('skinGrid');
            grid.innerHTML = '';
            
            const allSkins = Object.keys(skinMetadata).filter(skin => skin !== 'snake-default-green');
            allSkins.unshift('snake-default-green'); // Put default first
            
            allSkins.forEach(skinId => {
                const skinData = skinMetadata[skinId];
                const div = document.createElement('div');
                div.className = 'skin-item';
                
                // Add appropriate classes
                if (skinId === currentPlayerSkin) {
                    div.classList.add('current');
                }
                
                if (!skinData.unlocked) {
                    if (availableUnlocks > 0) {
                        div.classList.add('unlockable');
                    } else {
                        div.classList.add('locked');
                    }
                }
                
                // Build content
                const img = document.createElement('img');
                img.className = 'skin-image';
                img.src = `skins/${skinId}.webp`;
                img.alt = skinData.name;
                
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skinData.name;
                
                div.appendChild(img);
                div.appendChild(name);
                
                // Add unlock icon if applicable
                if (!skinData.unlocked) {
                    const icon = document.createElement('div');
                    icon.className = 'skin-unlock-icon';
                    icon.textContent = availableUnlocks > 0 ? 'üîì' : 'üîí';
                    div.appendChild(icon);
                }
                
                // Click handler
                div.onclick = () => selectSkin(skinId);
                
                grid.appendChild(div);
            });
        }
        
        // Handle skin selection
        function selectSkin(skinId) {
            const skinData = skinMetadata[skinId];
            
            if (skinData.unlocked) {
                // Already unlocked - just select it
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                saveSkinData();
                buildSkinGrid();
            } else if (availableUnlocks > 0) {
                // Unlock the skin
                skinData.unlocked = true;
                unlockedSkins.add(skinId);
                availableUnlocks--;
                
                // Select the newly unlocked skin
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                
                saveSkinData();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Show unlock message
                showMessage(`Unlocked: ${skinData.name}!`, true);
            }
        }
        
        // Update unlock display
        function updateUnlockDisplay() {
            const display = document.getElementById('availableUnlocks');
            if (display) {
                display.textContent = `Available Unlocks: ${availableUnlocks}`;
                if (availableUnlocks > 0) {
                    display.style.color = '#4ecdc4';
                } else {
                    display.style.color = '#AAA';
                }
            }
        }
        
        let lastTime = 0;
        function gameLoop(currentTime) {
            if (!gameStarted) return;
            
            requestAnimationFrame(gameLoop);
            
            if (paused) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update animation time for border effects
            animationTime = currentTime * 0.001; // Convert to seconds
            
            // Update camera to follow player with bounds checking
            if (playerSnake && playerSnake.alive) {
                // Ensure camera coordinates stay within reasonable bounds to prevent overflow
                camera.x = Math.max(0, Math.min(WORLD_SIZE, playerSnake.x));
                camera.y = Math.max(0, Math.min(WORLD_SIZE, playerSnake.y));
                
                // Additional check for NaN or Infinity
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            }
            
            // Update game objects
            snakes.forEach(snake => snake.update());
            elements.forEach(element => element.update());
            particles = particles.filter(particle => particle.update());
            
            // Update border particles
            borderParticles.forEach(particle => particle.update(deltaTime));
            
            // Update shooting stars
            shootingStars = shootingStars.filter(star => star.update());
            
            // Spawn shooting star occasionally (10-15 seconds)
            if (currentTime - lastShootingStarTime > (10000 + Math.random() * 5000) && shootingStars.length === 0) {
                shootingStars.push(new ShootingStar());
                lastShootingStarTime = currentTime;
            }
            
            // Check collisions
            checkCollisions();
            
            // Remove dead snakes (except the current player if they're respawning)
            snakes = snakes.filter(snake => snake.alive || (snake.isPlayer && snake === playerSnake));
            
            // Spawn new elements occasionally
            if (Math.random() < 0.04 && elements.length < 150) {
                spawnElement();
            }
            
            // Spawn new AI snakes if needed
            const aiSnakes = snakes.filter(s => !s.isPlayer && s.alive).length;
            if (aiSnakes < 5) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            
            // Update UI
            updateUI();
            
            // Draw everything
            drawBackground();
            elements.forEach(element => element.draw());
            snakes.forEach(snake => snake.draw());
            particles.forEach(particle => particle.draw());
        }
        
        // Initialize
        Promise.all([loadElements(), loadSnakeNames()]).then(() => {
            console.log('Game ready!');
            
            // Sync discovered elements from new system if available
            if (window.elementLoader && window.elementCompatibility) {
                // Load previously discovered elements
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                if (savedDiscovered && savedDiscovered.size > 0) {
                    // Merge with existing discovered elements
                    for (const elementKey of savedDiscovered) {
                        discoveredElements.add(elementKey);
                    }
                    console.log(`Loaded ${savedDiscovered.size} discovered elements from new system`);
                }
            }
            
            // Load skin data
            loadSkinData();
            preloadSkins();
        });
        
        // Stars animation for splash and game mode screens
        (function() {
            const splashCanvas = document.getElementById('splashStarsCanvas');
            const splashCtx = splashCanvas.getContext('2d');
            const gameModeCanvas = document.getElementById('gameModeStarsCanvas');
            const gameModeCtx = gameModeCanvas.getContext('2d');
            
            // Resize canvases
            function resizeCanvases() {
                splashCanvas.width = window.innerWidth;
                splashCanvas.height = window.innerHeight;
                gameModeCanvas.width = window.innerWidth;
                gameModeCanvas.height = window.innerHeight;
            }
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Stars array (shared between both screens)
            const stars = [];
            const shootingStars = [];
            let lastShootingStarTime = 0;
            
            // Initialize stars
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            
            // Shooting star class for splash
            class SplashShootingStar {
                constructor() {
                    // Start from screen edge
                    const edge = Math.floor(Math.random() * 4);
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    switch(edge) {
                        case 0: // Top
                            this.x = Math.random() * width;
                            this.y = -10;
                            break;
                        case 1: // Right
                            this.x = width + 10;
                            this.y = Math.random() * height;
                            break;
                        case 2: // Bottom
                            this.x = Math.random() * width;
                            this.y = height + 10;
                            break;
                        case 3: // Left
                            this.x = -10;
                            this.y = Math.random() * height;
                            break;
                    }
                    
                    // Aim towards screen center area
                    const targetX = width * (0.3 + Math.random() * 0.4);
                    const targetY = height * (0.3 + Math.random() * 0.4);
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    const speed = 3 + Math.random() * 2;
                    
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.trail = [];
                    this.maxTrailLength = 30;
                    this.life = 1.0;
                }
                
                update() {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.01;
                    
                    return this.life > 0 && this.x > -50 && this.x < window.innerWidth + 50 && 
                           this.y > -50 && this.y < window.innerHeight + 50;
                }
                
                draw(ctx) {
                    // Draw trail
                    ctx.save();
                    this.trail.forEach((point, index) => {
                        const alpha = (index / this.trail.length) * this.life * 0.3;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ffffff';
                        const size = (index / this.trail.length) * 2;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw star
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Animation loop
            function animateStars(timestamp) {
                // Check which screen is active
                const splashActive = document.getElementById('splashScreen').style.display !== 'none' && 
                                   document.getElementById('splashScreen').style.opacity !== '0';
                const gameModeActive = document.getElementById('gameModeSelect').style.display !== 'none';
                
                if (!splashActive && !gameModeActive) {
                    requestAnimationFrame(animateStars);
                    return;
                }
                
                // Determine which canvas to draw on
                const activeCanvas = splashActive ? splashCanvas : gameModeCanvas;
                const activeCtx = splashActive ? splashCtx : gameModeCtx;
                
                // Clear canvas
                activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);
                
                // Draw static stars with twinkling
                stars.forEach(star => {
                    star.opacity += Math.sin(timestamp * star.twinkleSpeed) * 0.05;
                    star.opacity = Math.max(0.1, Math.min(0.8, star.opacity));
                    
                    activeCtx.globalAlpha = star.opacity;
                    activeCtx.fillStyle = '#ffffff';
                    activeCtx.beginPath();
                    activeCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    activeCtx.fill();
                });
                
                // Update and draw shooting stars
                shootingStars.forEach((star, index) => {
                    if (!star.update()) {
                        shootingStars.splice(index, 1);
                    } else {
                        star.draw(activeCtx);
                    }
                });
                
                // Spawn new shooting star occasionally
                if (timestamp - lastShootingStarTime > 3000 + Math.random() * 4000) {
                    shootingStars.push(new SplashShootingStar());
                    lastShootingStarTime = timestamp;
                }
                
                activeCtx.globalAlpha = 1;
                requestAnimationFrame(animateStars);
            }
            
            // Start animation
            requestAnimationFrame(animateStars);
        })();
        
        // Try to play music on first user interaction
        document.addEventListener('click', function playMusicOnInteraction() {
            if (currentTrack && currentTrack.paused && gameStarted) {
                currentTrack.play().catch(() => {});
            }
        }, { once: true });
    </script>
</body>
</html>