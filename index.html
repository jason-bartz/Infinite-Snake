<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Snake - Elemental Mastery</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
            margin-left: 250px;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #discoveries {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #recentDiscovery {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #00FF00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #elementQueue {
            position: absolute;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #444;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
            max-width: 600px;
            font-size: 14px;
            max-height: 120px;
            overflow: hidden;
        }
        .queueElement {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            position: relative;
            min-width: 40px;
        }
        .queueElement .emoji {
            font-size: 20px;
        }
        .queueElement .name {
            font-size: 9px;
            color: #AAA;
            margin-top: 2px;
        }
        .queueElement.compatible {
            animation: glow 1s infinite;
        }
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255,215,0,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,215,0,0.8); }
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 1px solid #444;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 14px;
            border: 1px solid #444;
        }
        #discoveryLog {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100%;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
            z-index: 20;
            box-sizing: border-box;
        }
        #discoveryLog h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #FFD700;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .discovery-item {
            margin: 8px 0;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        .discovery-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        .discovery-item .emoji {
            font-size: 24px;
        }
        .discovery-item .info {
            flex: 1;
        }
        .discovery-item .name {
            font-weight: bold;
            color: white;
        }
        .discovery-item .tier {
            font-size: 11px;
            color: #AAA;
        }
        .discovery-item.new {
            animation: newItemGlow 2s ease-out;
            background: rgba(255, 215, 0, 0.2);
        }
        @keyframes newItemGlow {
            0% {
                background: rgba(255, 215, 0, 0.5);
                transform: translateX(10px);
            }
            100% {
                background: rgba(255, 215, 0, 0.2);
                transform: translateX(0);
            }
        }
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0033, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        #splashScreen img {
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        #gameModeSelect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            display: none;
            z-index: 50;
            text-align: center;
            border: 2px solid #444;
            max-width: 600px;
            width: 90%;
        }
        #gameModeSelect h3 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 20px;
        }
        .modeSection {
            margin-bottom: 30px;
        }
        .modeSection h4 {
            color: #AAA;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #gameModeSelect button {
            margin: 5px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 180px;
        }
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        #powerUpIndicator {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 15;
        }
        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            z-index: 200;
            opacity: 0;
            animation: achievementPop 3s ease-out;
            text-align: center;
        }
        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 500;
            justify-content: center;
            align-items: center;
        }
        #pauseMenu {
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #444;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
            max-width: 1200px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        #pauseMenu h2 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 36px;
        }
        #pauseMenu .totalScore {
            color: #AAA;
            margin-bottom: 20px;
            font-size: 18px;
        }
        #skinMenu {
            display: grid;
            grid-template-columns: repeat(5, 80px);
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }
        .skinOption {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        .skinOption:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .skinOption.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        .skinOption.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skinOption small {
            font-size: 10px;
            color: #AAA;
            margin-top: 5px;
        }
        @keyframes achievementPop {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1);
            }
            30% {
                transform: translate(-50%, -50%) scale(1);
            }
            80% {
                opacity: 1;
            }
            100% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }
        .achievement h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .achievement .element-display {
            font-size: 48px;
            margin: 10px 0;
        }
        .achievement .element-name {
            font-size: 20px;
            color: white;
            margin-bottom: 5px;
        }
        .achievement .tier-info {
            font-size: 14px;
            color: #AAA;
        }
        .score-popup {
            position: fixed;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            animation: scoreFloat 1.5s ease-out;
        }
        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }
        @keyframes elementFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }
        @keyframes combinationPop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1.1);
            }
            40% {
                transform: translateX(-50%) translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px);
            }
        }
        @keyframes newDiscoveryPop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.5) rotate(-10deg);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1.2) rotate(5deg);
            }
            40% {
                transform: translateX(-50%) translateY(0) scale(1) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px) scale(0.9);
            }
        }
        @keyframes flashExpand {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="splashScreen">
        <img src="assets/word-logo.png" alt="Infinite Snake" style="width: 400px; max-width: 80%; margin-bottom: 30px;" onerror="this.style.display='none'; document.getElementById('splashTitle').style.display='block';">
        <h1 id="splashTitle" style="display: none; font-size: 60px; margin-bottom: 30px; background: linear-gradient(45deg, #FFD700, #FF6B6B); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Infinite Snake</h1>
        <p>You are an Infinite Snake - a mystical serpent capable of endless growth and elemental mastery. Consume the scattered elements of creation, combine them within your ever-expanding form, and unlock the infinite possibilities that lie within the realm.</p>
        <button id="startButton">Begin Your Journey</button>
    </div>
    
    <div id="score">Score: 0</div>
    <div id="discoveries">Discoveries: 0 / ?</div>
    <div id="recentDiscovery"></div>
    <div id="powerUpIndicator"></div>
    
    <div id="elementQueue"></div>
    
    <div id="discoveryLog">
        <h3>Discovered Elements (0)</h3>
        <div id="discoveryList"></div>
    </div>
    
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-list"></div>
    </div>
    
    <div id="controls">
        <span id="controlsText">Arrow Keys: Move ‚Ä¢ P: Pause</span>
    </div>
    
    <div id="pauseOverlay">
        <div id="pauseMenu">
            <h2>PAUSED</h2>
            <div class="totalScore" id="totalScoreDisplay">Total Score: 0</div>
            
            <div style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 10px;">
                <h4 style="color: #FFD700; margin-bottom: 10px;">Music Controls</h4>
                <div style="display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 10px;">
                    <button onclick="toggleMusic()" id="muteButton" style="padding: 8px 20px; background: linear-gradient(135deg, #4B79A1, #283E51); border: 1px solid #666; color: white; border-radius: 5px; cursor: pointer;">üîä Mute</button>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="color: #AAA;">Volume:</span>
                        <input type="range" id="volumeSlider" min="0" max="100" value="30" onchange="changeVolume(this.value)" style="width: 150px;">
                        <span id="volumeDisplay" style="color: #AAA; width: 40px;">30%</span>
                    </div>
                </div>
            </div>
            
            <h3>Select Your Skin</h3>
            <div id="skinMenu"></div>
            
            <div style="margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.5); border-radius: 10px; max-height: 400px; overflow-y: auto;">
                <h4 style="color: #FFD700; margin-bottom: 10px;">Your Discovered Elements</h4>
                <div id="pauseDiscoveryList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px;"></div>
            </div>
            
            <button onclick="resumeGame()" style="margin-top: 20px; padding: 10px 30px; background: linear-gradient(135deg, #4B79A1, #283E51); border: 1px solid #666; color: white; border-radius: 5px; cursor: pointer; font-size: 18px;">Resume Game</button>
            <button onclick="resetGame()" style="margin-top: 10px; padding: 10px 30px; background: linear-gradient(135deg, #8B0000, #4B0000); border: 1px solid #666; color: white; border-radius: 5px; cursor: pointer; font-size: 18px;">Reset Game (Lose All Progress)</button>
        </div>
    </div>
    
    
    <div id="gameModeSelect">
        <h3>Game Setup</h3>
        
        <div class="modeSection">
            <h4>Victory Condition</h4>
            <div id="victoryButtons">
                <button onclick="selectVictoryMode(100)">Discovery Race: 100</button>
                <button onclick="selectVictoryMode(200)">Discovery Race: 200</button>
                <button onclick="selectVictoryMode(500)">Discovery Race: 500</button>
                <button onclick="selectVictoryMode(1000)">Discovery Race: 1000</button>
                <button onclick="selectVictoryMode(0)">Infinite Mode</button>
            </div>
        </div>
        
        <div class="modeSection" id="controlSection" style="display: none;">
            <h4>Control Method</h4>
            <div id="loadingIndicator" style="display: none; margin: 10px 0; color: #FFD700; font-size: 14px;">
                Loading element database... <span id="loadingProgress"></span>
            </div>
            <button class="controlOption" onclick="selectControls('arrows')">‚Üë ‚Üì ‚Üê ‚Üí Arrow Keys</button>
            <button class="controlOption" onclick="selectControls('wasd')">W A S D Keys</button>
            <button class="controlOption" onclick="selectControls('mouse')">üñ±Ô∏è Mouse / Touchpad</button>
            
            <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; text-align: left; font-size: 14px; color: #CCC; line-height: 1.6;">
                <h5 style="color: #FFD700; margin-bottom: 10px; text-align: center;">How to Play</h5>
                <ul style="margin: 0; padding-left: 20px;">
                    <li><strong>Collect Elements:</strong> Guide your snake to consume elemental orbs scattered across the map</li>
                    <li><strong>Combine Elements:</strong> Elements in your snake automatically combine to create new discoveries</li>
                    <li><strong>Grow & Survive:</strong> Each combination makes you longer. Bigger snakes can hold more elements!</li>
                    <li><strong>Battle Strategy:</strong> In head-to-head collisions, the longer snake wins. Avoid all snake bodies!</li>
                    <li><strong>Discover Everything:</strong> Find all possible element combinations to master the realm</li>
                    <li><strong>Beware the Borders:</strong> Red borders mean instant death - stay away!</li>
                </ul>
                <p style="text-align: center; margin-top: 10px; color: #888; font-size: 12px;">Press P to pause ‚Ä¢ New discoveries grant invincibility!</p>
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas globally accessible
        window.canvas = canvas;
        
        canvas.width = window.innerWidth - 290; // Account for sidebar
        canvas.height = window.innerHeight - 40;
        
        // Game constants
        const WORLD_SIZE = 4000; // Doubled map size
        const SEGMENT_SIZE = 20;
        const ELEMENT_SIZE = 15;
        const SPEED = 4;
        const TURN_SPEED = 0.08;
        
        // Element System - Will be loaded from database
        let BASIC_ELEMENTS = {
            fire: { emoji: 'üî•', name: 'Fire', tier: 0 },
            water: { emoji: 'üíß', name: 'Water', tier: 0 },
            earth: { emoji: 'üåç', name: 'Earth', tier: 0 },
            air: { emoji: 'üí®', name: 'Air', tier: 0 }
        };
        
        let COMBINATIONS = {};
        let ALL_ELEMENTS = { ...BASIC_ELEMENTS }; // Initialize with basics
        let elementsLoaded = false;
        let loadedChunks = new Set();
        let isLoadingChunk = false;
        
        // IndexedDB for caching
        let db = null;
        const DB_NAME = 'InfiniteSnakeDB';
        const DB_VERSION = 1;
        const CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days
        
        // Initialize IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains('databases')) {
                        db.createObjectStore('databases', { keyPath: 'name' });
                    }
                    if (!db.objectStoreNames.contains('chunks')) {
                        db.createObjectStore('chunks', { keyPath: 'id' });
                    }
                };
            });
        }
        
        // Save data to IndexedDB
        async function saveToCache(storeName, data) {
            if (!db) return;
            
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put({
                ...data,
                timestamp: Date.now()
            });
            
            return new Promise((resolve, reject) => {
                request.onsuccess = resolve;
                request.onerror = reject;
            });
        }
        
        // Load data from IndexedDB
        async function loadFromCache(storeName, key) {
            if (!db) return null;
            
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            
            return new Promise((resolve) => {
                request.onsuccess = () => {
                    const data = request.result;
                    if (data && Date.now() - data.timestamp < CACHE_EXPIRY) {
                        resolve(data);
                    } else {
                        resolve(null);
                    }
                };
                request.onerror = () => resolve(null);
            });
        }
        
        // Manifest-based chunk loading
        let chunkManifest = {};
        const chunkFileMapping = {
            'intermediate': 'elements-intermediate.json',
            'advanced': 'elements-advanced.json',
            'pokemon': 'elements-pokemon.json',
            'fictional': 'elements-fictional.json',
            'special': 'elements-special.json'
        };
        
        // Lazy loading system for database chunks
        async function loadChunk(chunkId) {
            if (loadedChunks.has(chunkId) || isLoadingChunk) return;
            
            isLoadingChunk = true;
            try {
                // Try cache first
                const cachedChunk = await loadFromCache('chunks', chunkId);
                
                if (cachedChunk) {
                    // Use cached chunk
                    mergeChunkData(cachedChunk);
                    
                    loadedChunks.add(chunkId);
                    console.log(`Loaded chunk ${chunkId} from cache: ${Object.keys(cachedChunk.elements || {}).length} elements`);
                } else {
                    // Determine file to load based on chunkId
                    const fileName = chunkFileMapping[chunkId];
                    if (!fileName) {
                        console.warn(`Unknown chunk ID: ${chunkId}`);
                        return;
                    }
                    
                    // Fetch from network
                    const response = await fetch(fileName);
                    const chunk = await response.json();
                    
                    // Merge chunk data
                    mergeChunkData(chunk);
                    
                    // Cache the chunk
                    saveToCache('chunks', {
                        id: chunkId,
                        ...chunk
                    }).catch(err => console.warn(`Failed to cache chunk ${chunkId}`, err));
                    
                    loadedChunks.add(chunkId);
                    console.log(`Loaded chunk ${chunkId}: ${Object.keys(chunk.elements || {}).length} elements`);
                }
            } catch (err) {
                console.error(`Failed to load chunk ${chunkId}:`, err);
            } finally {
                isLoadingChunk = false;
            }
        }
        
        // Helper function to merge chunk data into global objects
        function mergeChunkData(chunk) {
            // Merge all tier elements into ALL_ELEMENTS
            const allElements = {};
            if (chunk.basicElements) Object.assign(allElements, chunk.basicElements);
            if (chunk.tier1Elements) Object.assign(allElements, chunk.tier1Elements);
            if (chunk.tier2Elements) Object.assign(allElements, chunk.tier2Elements);
            if (chunk.tier3Elements) Object.assign(allElements, chunk.tier3Elements);
            if (chunk.tier4Elements) Object.assign(allElements, chunk.tier4Elements);
            if (chunk.tier5Elements) Object.assign(allElements, chunk.tier5Elements);
            if (chunk.tier6Elements) Object.assign(allElements, chunk.tier6Elements);
            if (chunk.tier7Elements) Object.assign(allElements, chunk.tier7Elements);
            if (chunk.elements) Object.assign(allElements, chunk.elements);
            
            Object.assign(ALL_ELEMENTS, allElements);
            Object.assign(elementDatabase, allElements);
            
            // Merge combinations
            if (chunk.combinations) {
                Object.assign(COMBINATIONS, chunk.combinations);
            }
        }
        
        // Check if element requires loading additional chunks
        function checkElementAvailability(elementKey) {
            if (ALL_ELEMENTS[elementKey]) return true;
            
            // Check discovery triggers from manifest
            if (chunkManifest.discoveryTriggers) {
                for (const [trigger, triggerElements] of Object.entries(chunkManifest.discoveryTriggers)) {
                    if (triggerElements.includes(elementKey)) {
                        // Load appropriate chunk based on trigger
                        if (trigger === 'tier3' && !loadedChunks.has('intermediate')) {
                            loadChunk('intermediate');
                        } else if (trigger === 'tier5' && !loadedChunks.has('advanced')) {
                            loadChunk('advanced');
                        } else if (trigger === 'pokemonworld' && !loadedChunks.has('pokemon')) {
                            loadChunk('pokemon');
                        } else if (trigger === 'magic' && !loadedChunks.has('fictional')) {
                            loadChunk('fictional');
                        } else if (trigger === 'infinity' && !loadedChunks.has('special')) {
                            loadChunk('special');
                        }
                        break;
                    }
                }
            }
            return false;
        }
        
        // Initialize database loading
        async function loadDatabase() {
            try {
                // Try to initialize IndexedDB
                await initDB();
                
                // Try to load from cache first
                const cachedData = await loadFromCache('databases', 'essential');
                
                if (cachedData) {
                    // Use cached data
                    BASIC_ELEMENTS = cachedData.basicElements || {};
                    COMBINATIONS = cachedData.combinations || {};
                    ALL_ELEMENTS = cachedData.elements || {};
                    elementsLoaded = true;
                    
                    console.log(`Loaded essential database from cache: ${Object.keys(ALL_ELEMENTS).length} elements`);
                    elementDatabase = { ...BASIC_ELEMENTS, ...ALL_ELEMENTS };
                    
                    // Hide loading indicator
                    const loadingIndicator = document.getElementById('loadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    // Load manifest for chunk info
                    fetch('elements-database-consolidated.json')
                        .then(response => response.json())
                        .then(manifest => {
                            chunkManifest = manifest;
                            // Pre-load intermediate chunk
                            setTimeout(() => loadChunk('intermediate'), 1000);
                        })
                        .catch(err => console.warn('Failed to load manifest', err));
                } else {
                    // Fetch from network
                    fetchEssentialDatabase();
                }
            } catch (err) {
                console.warn('IndexedDB not available, falling back to network', err);
                fetchEssentialDatabase();
            }
        }
        
        // Fetch essential database from network
        function fetchEssentialDatabase() {
            // First load the manifest to understand chunk structure
            fetch('elements-database-consolidated.json')
                .then(response => response.json())
                .then(manifest => {
                    chunkManifest = manifest;
                    console.log('Loaded chunk manifest');
                    
                    // Now load essential database
                    return fetch('elements-essential.json');
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Merge tiered elements into single objects
                    BASIC_ELEMENTS = data.basicElements || {};
                    ALL_ELEMENTS = {};
                    
                    // Merge all tier elements into ALL_ELEMENTS
                    if (data.basicElements) Object.assign(ALL_ELEMENTS, data.basicElements);
                    if (data.tier1Elements) Object.assign(ALL_ELEMENTS, data.tier1Elements);
                    if (data.tier2Elements) Object.assign(ALL_ELEMENTS, data.tier2Elements);
                    
                    COMBINATIONS = data.combinations || {};
                    elementsLoaded = true;
                    
                    console.log(`Loaded essential database: ${Object.keys(ALL_ELEMENTS).length} elements, ${Object.keys(COMBINATIONS).length} combinations`);
                    
                    // Update elementDatabase with all loaded elements
                    Object.assign(elementDatabase, ALL_ELEMENTS);
                    
                    // Cache the data
                    saveToCache('databases', {
                        name: 'essential',
                        basicElements: BASIC_ELEMENTS,
                        combinations: COMBINATIONS,
                        elements: ALL_ELEMENTS
                    }).catch(err => console.warn('Failed to cache database', err));
                    
                    // Hide loading indicator if visible
                    const loadingIndicator = document.getElementById('loadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    // Pre-load intermediate chunk in background after a delay
                    setTimeout(() => loadChunk('intermediate'), 2000);
                })
                .catch(err => {
                    console.error('Failed to load element database, using defaults', err);
                    // Ensure we have basic elements at least
                    if (Object.keys(ALL_ELEMENTS).length === 0) {
                        ALL_ELEMENTS = { ...BASIC_ELEMENTS };
                    }
                    if (Object.keys(elementDatabase).length === 0) {
                        elementDatabase = { ...BASIC_ELEMENTS };
                    }
                    elementsLoaded = true; // Continue with defaults
                    
                    // Hide loading indicator if visible
                    const loadingIndicator = document.getElementById('loadingIndicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                });
        }
        
        // Start loading the database
        loadDatabase();
        
        // Fallback: ensure game can start even if database fails
        setTimeout(() => {
            if (!elementsLoaded) {
                console.warn('Database load timeout, using defaults');
                ALL_ELEMENTS = { ...BASIC_ELEMENTS };
                elementDatabase = { ...BASIC_ELEMENTS };
                elementsLoaded = true;
            }
        }, 5000);
        
        // Power-up mappings
        const ELEMENT_POWERS = {
            'lava': { type: 'lava_body', duration: 5000, color: '#FF4500' },
            'lightning': { type: 'speed', duration: 6000, color: '#FFD700' },
            'crystal': { type: 'armor', duration: 7000, color: '#00BFFF' },
            'ice': { type: 'ice_trail', duration: 5000, color: '#87CEEB' },
            'wind': { type: 'magnet', duration: 8000, color: '#98FB98' },
            'hurricane': { type: 'magnet', duration: 10000, color: '#4169E1' },
            'dragon': { type: 'lava_body', duration: 10000, color: '#FF6347' },
            'magic': { type: 'speed', duration: 8000, color: '#FF1493' }
        };
        
        // Game state
        let gameMode = 0;
        let targetDiscoveries = 0;
        let paused = false;
        let gameStarted = false;
        const camera = { x: 0, y: 0 };
        
        // Music system
        let currentTrack = null;
        let musicVolume = 0.3;
        let musicMuted = false;
        const musicTracks = ['track1.mp3', 'track2.mp3', 'track3.mp3', 'track4.mp3'];
        let availableTracks = [];
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false, W: false,
            a: false, A: false,
            s: false, S: false,
            d: false, D: false,
            p: false,
            P: false
        };
        
        // Snake skins with unlock requirements
        const SNAKE_SKINS = [
            { id: 'default', name: 'Classic', emoji: 'üòä', primary: '#FF6B6B', secondary: '#FF5252', unlockPoints: 0 },
            { id: 'happy', name: 'Happy', emoji: 'üòÑ', primary: '#4ECDC4', secondary: '#45B7AA', unlockPoints: 100 },
            { id: 'cool', name: 'Cool', emoji: 'üòé', primary: '#FFE66D', secondary: '#FFD93D', unlockPoints: 250 },
            { id: 'love', name: 'Love', emoji: 'ü•∞', primary: '#FF8CC8', secondary: '#FF6BB3', unlockPoints: 500 },
            { id: 'star', name: 'Star', emoji: 'ü§©', primary: '#A8E6CF', secondary: '#81C784', unlockPoints: 750 },
            { id: 'fire', name: 'Fire', emoji: 'üî•', primary: '#FF4500', secondary: '#FF6347', unlockPoints: 1000 },
            { id: 'ice', name: 'Ice', emoji: 'üßä', primary: '#00BFFF', secondary: '#87CEEB', unlockPoints: 1500 },
            { id: 'rainbow', name: 'Rainbow', emoji: 'üåà', primary: '#FF1493', secondary: '#FFD700', unlockPoints: 2000 },
            { id: 'dragon', name: 'Dragon', emoji: 'üêâ', primary: '#8B0000', secondary: '#DC143C', unlockPoints: 3000 },
            { id: 'cosmic', name: 'Cosmic', emoji: 'üåå', primary: '#4B0082', secondary: '#8A2BE2', unlockPoints: 5000 }
        ];
        
        // Snake names data
        let snakeNameData = null;
        
        // Load snake names
        fetch('snake-names.json')
            .then(response => response.json())
            .then(data => {
                snakeNameData = data;
            })
            .catch(err => {
                console.warn('Could not load snake names, using fallback', err);
                // Fallback data if file fails to load
                snakeNameData = {
                    firstParts: ['Sir', 'Lord', 'Captain', 'Master', 'Swift', 'Mighty', 'Sneaky'],
                    secondParts: ['Slithers', 'McSlitherface', 'the Magnificent', 'Noodle', 'Supreme']
                };
            });
        
        // Function to generate random snake name
        function generateSnakeName() {
            if (!snakeNameData) {
                return `Snake${Math.floor(Math.random() * 1000)}`;
            }
            const first = snakeNameData.firstParts[Math.floor(Math.random() * snakeNameData.firstParts.length)];
            const second = snakeNameData.secondParts[Math.floor(Math.random() * snakeNameData.secondParts.length)];
            return `${first} ${second}`;
        }
        
        // Control scheme
        let controlScheme = 'arrows'; // 'arrows', 'wasd', or 'mouse'
        let mouseAngle = 0;
        let playerSkin = SNAKE_SKINS[0];
        let totalScore = parseInt(localStorage.getItem('infiniteSnakeTotalScore') || '0');
        
        // Initialize arrays
        let snakes = [];
        let elements = [];
        // Particle pool for performance optimization
        const particlePool = [];
        let activeParticles = [];
        const MAX_PARTICLES = 500;
        
        // Pre-allocate particle objects
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlePool.push({
                x: 0, y: 0, vx: 0, vy: 0,
                life: 0, color: '#FFF', active: false
            });
        }
        
        function getParticle() {
            for (let i = 0; i < particlePool.length; i++) {
                if (!particlePool[i].active) {
                    particlePool[i].active = true;
                    return particlePool[i];
                }
            }
            return null; // Pool exhausted
        }
        
        function releaseParticle(particle) {
            particle.active = false;
            particle.life = 0;
        }
        let playerSnake = null;
        
        // Discovery tracking (now per-player)
        let elementDatabase = {
            fire: { emoji: 'üî•', name: 'Fire', tier: 0 },
            water: { emoji: 'üíß', name: 'Water', tier: 0 },
            earth: { emoji: 'üåç', name: 'Earth', tier: 0 },
            air: { emoji: 'üí®', name: 'Air', tier: 0 }
        };
        
        // This will be populated when the database loads
        
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.segments = [];
                this.elements = []; // Elements in body
                this.length = 10;
                this.score = 0;
                this.discoveries = 0;
                this.isPlayer = isPlayer;
                this.speed = SPEED;
                this.alive = true;
                this.name = isPlayer ? 'You' : generateSnakeName();
                
                // Per-snake discovery tracking
                this.discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
                
                // Assign skin
                if (isPlayer) {
                    this.skin = playerSkin;
                } else {
                    // AI snakes get random unlocked skins
                    const unlockedSkins = SNAKE_SKINS.filter(s => s.unlockPoints <= totalScore);
                    this.skin = unlockedSkins[Math.floor(Math.random() * unlockedSkins.length)];
                }
                
                // Power-ups
                this.activePower = null;
                this.powerTimer = 0;
                this.invincibilityTimer = 0;
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    this.segments.push({
                        x: x - i * SEGMENT_SIZE * Math.cos(this.angle),
                        y: y - i * SEGMENT_SIZE * Math.sin(this.angle)
                    });
                }
                
                // Initialize with random basic elements
                for (let i = 0; i < 5; i++) {
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    const randomElement = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    this.elements.push(randomElement);
                }
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                // Update power-up timer
                if (this.activePower && this.powerTimer > 0) {
                    this.powerTimer -= deltaTime;
                    if (this.powerTimer <= 0) {
                        this.activePower = null;
                        if (this.isPlayer) {
                            document.getElementById('powerUpIndicator').style.opacity = '0';
                        }
                    }
                }
                
                // Update invincibility timer
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= deltaTime;
                }
                
                // Calculate speed
                let currentSpeed = this.speed;
                if (this.activePower === 'speed') {
                    currentSpeed *= 1.5;
                }
                
                // Player controls
                if (this.isPlayer) {
                    if (controlScheme === 'arrows') {
                        if (keys.ArrowLeft) this.angle -= TURN_SPEED;
                        if (keys.ArrowRight) this.angle += TURN_SPEED;
                    } else if (controlScheme === 'wasd') {
                        if (keys.a || keys.A) this.angle -= TURN_SPEED;
                        if (keys.d || keys.D) this.angle += TURN_SPEED;
                    } else if (controlScheme === 'mouse') {
                        // Smooth angle interpolation
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.1;
                    }
                } else {
                    // Simple AI - target nearest element
                    let nearestElement = null;
                    let minDist = 600; // Increased vision range for larger map
                    
                    elements.forEach(element => {
                        const dist = Math.hypot(element.x - this.x, element.y - this.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestElement = element;
                        }
                    });
                    
                    if (nearestElement) {
                        const targetAngle = Math.atan2(nearestElement.y - this.y, nearestElement.x - this.x);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.08; // Slightly faster turning
                    } else {
                        // Wander
                        this.angle += (Math.random() - 0.5) * 0.1;
                    }
                }
                
                // Move head
                this.x += Math.cos(this.angle) * currentSpeed;
                this.y += Math.sin(this.angle) * currentSpeed;
                
                // Border collision - explode on contact
                if (this.x < 0 || this.x > WORLD_SIZE || this.y < 0 || this.y > WORLD_SIZE) {
                    this.die();
                    return;
                }
                
                // Update segments
                this.segments.unshift({ x: this.x, y: this.y });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
                
                // Survival score
                this.score += 1 * deltaTime / 1000; // Reduced from 10 to 1 for balance
                
                if (this.isPlayer) {
                    document.getElementById('score').textContent = `Score: ${Math.floor(this.score)}`;
                    // Count total non-basic elements available
                    const totalDiscoverable = elementsLoaded ? 
                        Object.values(ALL_ELEMENTS).filter(e => e.tier > 0).length : '?';
                    
                    document.getElementById('discoveries').textContent = 
                        gameMode === 0 ? `Discoveries: ${this.discoveries} / ${totalDiscoverable}` : 
                        `Discoveries: ${this.discoveries} / ${targetDiscoveries}`;
                    
                    // Show invincibility status
                    if (this.invincibilityTimer > 0 && !this.activePower) {
                        const indicator = document.getElementById('powerUpIndicator');
                        indicator.textContent = `‚ú® INVINCIBLE (${Math.ceil(this.invincibilityTimer/1000)}s)`;
                        indicator.style.color = '#FFD700';
                        indicator.style.opacity = '1';
                    } else if (this.invincibilityTimer <= 0 && !this.activePower) {
                        document.getElementById('powerUpIndicator').style.opacity = '0';
                    }
                }
            }
            
            checkCombinations() {
                if (this.elements.length < 2) return;
                
                let madeAnyCombination = false;
                
                // Keep checking until no more combinations can be made
                do {
                    madeAnyCombination = false;
                    let foundCombo = null;
                    
                    // Check ALL pairs of elements, not just adjacent
                    outerLoop: for (let i = 0; i < this.elements.length; i++) {
                        for (let j = i + 1; j < this.elements.length; j++) {
                            const elem1 = this.elements[i];
                            const elem2 = this.elements[j];
                            
                            // Normalize element names for combination lookup
                            const normalizedElem1 = elem1.toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
                            const normalizedElem2 = elem2.toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9]/g, '');
                            
                            // Try both orders with normalized names
                            const combo1 = [normalizedElem1, normalizedElem2].sort().join('+');
                            
                            let result = COMBINATIONS[combo1];
                            
                            if (result) {
                                foundCombo = {
                                    index1: i,
                                    index2: j,
                                    result: result,
                                    elem1: elem1,
                                    elem2: elem2
                                };
                                break outerLoop; // Process one combination at a time
                            }
                        }
                    }
                    
                    // Process the combination if found
                    if (foundCombo) {
                        madeAnyCombination = true;
                        const combo = foundCombo;
                    
                    // Visual flash at head location
                    if (this.segments.length > 0) {
                        createCombinationFlash(
                            this.segments[0].x,
                            this.segments[0].y
                        );
                    }
                    
                    // Remove used elements (remove higher index first to maintain validity)
                    this.elements.splice(combo.index2, 1);
                    this.elements.splice(combo.index1, 1);
                    
                    // Discovery tracking (per-snake)
                    const elementKey = combo.result.name.toLowerCase();
                    const isNewDiscovery = !this.discoveredElements.has(elementKey);
                    
                    if (isNewDiscovery) {
                        this.discoveredElements.add(elementKey);
                        this.discoveries++;
                        
                        // Scoring
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        const totalPoints = discoveryPoints * 2; // Double points for first discovery
                        this.score += totalPoints;
                        
                        // Add extra segments for new discovery
                        const bonusSegments = 3 + combo.result.tier * 2;
                        this.length += bonusSegments;
                        
                        // Grant invincibility for new discoveries
                        this.invincibilityTimer = 3000; // 3 seconds
                        
                        // Load additional chunks for higher tier discoveries
                        if (combo.result.tier >= 2 && !loadedChunks.has(0)) {
                            loadChunk(0);
                        }
                        if (combo.result.tier >= 3 && !loadedChunks.has(1)) {
                            loadChunk(1);
                        }
                        if (combo.result.tier >= 4) {
                            // Load remaining chunks progressively
                            for (let i = 2; i < 2; i++) {
                                if (!loadedChunks.has(i)) {
                                    setTimeout(() => loadChunk(i), i * 1000);
                                    break;
                                }
                            }
                        }
                        
                        // Visual feedback
                        if (this.isPlayer) {
                            showDiscovery(combo.result);
                            showAchievement(combo.result);
                            createDiscoveryParticles(this.x, this.y);
                            createScorePopup(this.x, this.y, totalPoints);
                            createCombinationPopup(0, 0, combo.result, true);
                            
                            // Save discoveries
                            localStorage.setItem('infiniteSnakeDiscoveries', 
                                JSON.stringify(Array.from(this.discoveredElements)));
                            
                            // Discovery cascade - spawn copies around the map
                            const spawnCount = 5 + Math.floor(Math.random() * 3) + combo.result.tier;
                            const borderPadding = 100;
                            for (let j = 0; j < spawnCount; j++) {
                                spawnElement(combo.result.name.toLowerCase(), 
                                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2),
                                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2));
                            }
                        }
                        
                        // Check for power-up
                        if (ELEMENT_POWERS[elementKey]) {
                            this.activatePower(elementKey);
                        }
                        
                        // Update discovery log
                        lastDiscoveredElement = elementKey;
                        updateDiscoveryLog();
                    } else {
                        // Existing combination - still give points and growth
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        this.score += discoveryPoints;
                        
                        // Add segments for any combination
                        const growthAmount = 1 + combo.result.tier;
                        this.length += growthAmount;
                        
                        if (this.isPlayer) {
                            createScorePopup(this.x, this.y, discoveryPoints);
                            // Show combination popup
                            createCombinationPopup(0, 0, combo.result, false);
                            
                            // Spawn copies around the snake for known combinations
                            const spawnCount = 3 + Math.floor(Math.random() * 2);
                            for (let j = 0; j < spawnCount; j++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 100 + Math.random() * 150;
                                spawnElement(combo.result.name.toLowerCase(), 
                                    this.x + Math.cos(angle) * distance,
                                    this.y + Math.sin(angle) * distance);
                            }
                        }
                    }
                    
                    // Particles for any combination
                    createCombinationParticles(
                        this.segments[0].x, 
                        this.segments[0].y,
                        combo.result.tier
                    );
                    }
                } while (madeAnyCombination);
                
                // Update element queue display
                if (this.isPlayer) {
                    updateElementQueue();
                }
            }
            
            activatePower(elementName) {
                const power = ELEMENT_POWERS[elementName];
                if (!power) return;
                
                this.activePower = power.type;
                this.powerTimer = power.duration;
                
                if (this.isPlayer) {
                    const indicator = document.getElementById('powerUpIndicator');
                    const powerName = power.type.replace(/_/g, ' ').toUpperCase();
                    const powerEmojis = {
                        'lava_body': 'üåã',
                        'speed': '‚ö°',
                        'armor': 'üõ°Ô∏è',
                        'ice_trail': '‚ùÑÔ∏è',
                        'magnet': 'üß≤'
                    };
                    const emoji = powerEmojis[power.type] || 'üî•';
                    indicator.textContent = `${emoji} ${powerName} (${power.duration/1000}s)`;
                    indicator.style.color = power.color;
                    indicator.style.opacity = '1';
                }
            }
            
            consume(element) {
                // Add element to body
                this.elements.push(element.type);
                
                // Grow based on tier
                const elementData = elementDatabase[element.type];
                const growthAmount = elementData.tier === 0 ? 1 : 
                                   elementData.tier <= 2 ? 2 : 
                                   elementData.tier <= 4 ? 3 : 4;
                
                this.length += growthAmount;
                
                // Show element name popup
                if (this.isPlayer) {
                    const points = 10 + elementData.tier * 5;
                    this.score += points;
                    createElementPopup(this.x, this.y, elementData, points);
                }
                
                // Remove element
                const index = elements.indexOf(element);
                if (index > -1) elements.splice(index, 1);
                
                // Update queue
                if (this.isPlayer) updateElementQueue();
            }
            
            die() {
                // Border collision causes instant explosion
                if (this.x < 0 || this.x > WORLD_SIZE || this.y < 0 || this.y > WORLD_SIZE) {
                    this.explode();
                    return;
                }
                
                // Regular death - lose half segments
                if (this.length > 10) {
                    const segmentsToLose = Math.floor(this.length / 2);
                    this.length = Math.max(10, this.length - segmentsToLose);
                    
                    // Drop half the elements
                    const elementsToDrop = Math.floor(this.elements.length / 2);
                    for (let i = 0; i < elementsToDrop && i < this.segments.length; i++) {
                        const segment = this.segments[this.segments.length - 1 - i];
                        if (segment && this.elements.length > 0) {
                            const droppedElement = this.elements.pop();
                            spawnElement(droppedElement, 
                                segment.x + (Math.random() - 0.5) * 30,
                                segment.y + (Math.random() - 0.5) * 30);
                        }
                    }
                    
                    // Grant brief invincibility after death
                    this.invincibilityTimer = 2000; // 2 seconds
                    
                    if (this.isPlayer) {
                        // Flash effect
                        createDeathParticles(this.x, this.y);
                    }
                } else {
                    // Actually die if too small
                    this.alive = false;
                    
                    // Drop remaining elements
                    for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                        const segment = this.segments[i];
                        spawnElement(this.elements[i], 
                            segment.x + (Math.random() - 0.5) * 30,
                            segment.y + (Math.random() - 0.5) * 30);
                    }
                    
                    if (this.isPlayer) {
                        // Save progress before respawn
                        saveProgress();
                        
                        // Respawn
                        setTimeout(() => {
                            playerSnake = new Snake(
                                Math.random() * WORLD_SIZE,
                                Math.random() * WORLD_SIZE,
                                true
                            );
                            snakes.push(playerSnake);
                        }, 3000);
                    }
                }
            }
            
            explode() {
                this.alive = false;
                
                // Create massive explosion effect
                createExplosionParticles(this.x, this.y);
                
                // Drop all elements in a burst pattern (but keep within bounds)
                const angleStep = (Math.PI * 2) / Math.max(1, this.elements.length);
                const borderPadding = 100;
                for (let i = 0; i < this.elements.length; i++) {
                    const angle = angleStep * i;
                    const distance = 50 + Math.random() * 100;
                    const dropX = Math.max(borderPadding, Math.min(WORLD_SIZE - borderPadding, 
                        this.x + Math.cos(angle) * distance));
                    const dropY = Math.max(borderPadding, Math.min(WORLD_SIZE - borderPadding, 
                        this.y + Math.sin(angle) * distance));
                    spawnElement(this.elements[i], dropX, dropY);
                }
                
                if (this.isPlayer) {
                    // Save progress before respawn
                    saveProgress();
                    
                    // Screen shake effect
                    createScreenShake();
                    
                    // Respawn
                    setTimeout(() => {
                        playerSnake = new Snake(
                            WORLD_SIZE / 2,
                            WORLD_SIZE / 2,
                            true
                        );
                        // Load discoveries
                        const savedDiscoveries = localStorage.getItem('infiniteSnakeDiscoveries');
                        if (savedDiscoveries) {
                            try {
                                const discoveries = JSON.parse(savedDiscoveries);
                                playerSnake.discoveredElements = new Set(discoveries);
                                playerSnake.discoveries = discoveries.filter(e => elementDatabase[e] && elementDatabase[e].tier > 0).length;
                            } catch (e) {
                                console.error('Failed to load discoveries:', e);
                            }
                        }
                        snakes.push(playerSnake);
                    }, 3000);
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                // Draw segments
                for (let i = 0; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const screenX = segment.x - camera.x + window.canvas.width / 2;
                    const screenY = segment.y - camera.y + window.canvas.height / 2;
                    
                    // Skip if off screen
                    if (screenX < -50 || screenX > window.canvas.width + 50 ||
                        screenY < -50 || screenY > window.canvas.height + 50) continue;
                    
                    ctx.save();
                    
                    // Use snake's assigned skin colors
                    ctx.fillStyle = i % 2 === 0 ? this.skin.primary : this.skin.secondary;
                    
                    // Invincibility effect
                    if (this.invincibilityTimer > 0) {
                        // Flash effect
                        const flash = Math.sin(this.invincibilityTimer * 0.01) > 0;
                        if (flash) {
                            ctx.fillStyle = '#FFD700';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#FFD700';
                        }
                    }
                    
                    // Power-up effects
                    if (this.activePower === 'lava_body') {
                        ctx.fillStyle = '#FF4500';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#FF4500';
                    } else if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                    }
                    
                    // Draw segment
                    const radius = SEGMENT_SIZE - i * 0.02;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add border
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Draw element emoji on segment (bigger and clearer)
                    if (i < this.elements.length) {
                        const elementType = this.elements[i];
                        const element = elementDatabase[elementType];
                        if (element) {
                            ctx.save();
                            // Add slight background for better visibility
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, radius * 0.8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.font = `${radius * 1.4}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(element.emoji, screenX, screenY);
                            ctx.restore();
                        }
                    }
                }
                
                // Draw cute face on head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    const screenX = head.x - camera.x + window.canvas.width / 2;
                    const screenY = head.y - camera.y + window.canvas.height / 2;
                    
                    // Draw face
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                    
                    // Face emoji from skin
                    ctx.font = `${SEGMENT_SIZE * 1.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.skin.emoji, 0, 0);
                    
                    ctx.restore();
                    
                    // Draw name
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                    ctx.fillText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                }
            }
        }
        
        class Element {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.data = elementDatabase[type];
                this.createdTime = Date.now();
                this.pulse = 0;
                
                // Size based on tier
                this.size = ELEMENT_SIZE * (1 + this.data.tier * 0.25);
                
                // Expiration for rare elements
                this.expirationTime = this.data.tier >= 3 ? 8000 : 
                                    this.data.tier >= 5 ? 5000 : null;
            }
            
            update(deltaTime) {
                this.pulse += deltaTime * 0.005;
                
                // Check expiration
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    if (age > this.expirationTime) {
                        return false; // Remove element
                    }
                }
                
                // Magnet effect for nearby players with magnet power
                if (playerSnake && playerSnake.activePower === 'magnet') {
                    const dist = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    if (dist < 200) {
                        const angle = Math.atan2(playerSnake.y - this.y, playerSnake.x - this.x);
                        this.x += Math.cos(angle) * 2;
                        this.y += Math.sin(angle) * 2;
                    }
                }
                
                return true;
            }
            
            draw() {
                const screenX = this.x - camera.x + window.canvas.width / 2;
                const screenY = this.y - camera.y + window.canvas.height / 2;
                
                // Skip if off screen
                if (screenX < -50 || screenX > window.canvas.width + 50 ||
                    screenY < -50 || screenY > window.canvas.height + 50) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                // Glow for higher tier elements
                if (this.data.tier > 0) {
                    const glowSize = this.size * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Expiration warning
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    const timeLeft = this.expirationTime - age;
                    if (timeLeft < 3000) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, this.size * scale + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Draw emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.data.emoji, screenX, screenY);
            }
        }
        
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Random spawn logic
                const rand = Math.random();
                if (rand < 0.7) {
                    // Basic element
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                } else if (rand < 0.95) {
                    // Any tier 1-2 element
                    const midTierElements = Object.entries(elementDatabase)
                        .filter(([key, elem]) => elem.tier >= 1 && elem.tier <= 2)
                        .map(([key]) => key);
                    if (midTierElements.length > 0) {
                        type = midTierElements[Math.floor(Math.random() * midTierElements.length)];
                    } else {
                        const basicKeys = Object.keys(BASIC_ELEMENTS);
                        type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    }
                } else {
                    // Rare element
                    const allElements = Object.keys(elementDatabase);
                    type = allElements[Math.floor(Math.random() * allElements.length)];
                }
            }
            
            // Keep elements away from borders
            const borderPadding = 100;
            x = x || (borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2));
            y = y || (borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2));
            
            elements.push(new Element(type, x, y));
        }
        
        function createCombinationParticles(x, y, tier) {
            const particleCount = Math.min(10 + tier * 5, 30); // Cap particle count
            const hue = (tier * 60) % 360;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = getParticle();
                if (!particle) break; // Pool exhausted
                
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 1;
                particle.color = `hsl(${hue}, 70%, 50%)`;
            }
        }
        
        function createDiscoveryParticles(x, y) {
            const count = Math.min(30, MAX_PARTICLES - activeParticles.length);
            for (let i = 0; i < count; i++) {
                const particle = getParticle();
                if (!particle) break;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                const hue = Math.random() * 360;
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 1.5;
                particle.color = `hsl(${hue}, 100%, 50%)`;
            }
        }
        
        function createDeathParticles(x, y) {
            const count = Math.min(20, MAX_PARTICLES - activeParticles.length);
            for (let i = 0; i < count; i++) {
                const particle = getParticle();
                if (!particle) break;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 1;
                particle.color = '#FF0000';
            }
        }
        
        function createExplosionParticles(x, y) {
            // Create a massive explosion effect with limited particles
            const primaryCount = Math.min(50, MAX_PARTICLES - activeParticles.length);
            for (let i = 0; i < primaryCount; i++) {
                const particle = getParticle();
                if (!particle) break;
                
                const angle = (Math.PI * 2 * i) / primaryCount;
                const speed = 5 + Math.random() * 10;
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 2;
                particle.color = i % 2 === 0 ? '#FF0000' : '#FFFF00';
            }
            
            // Secondary explosion ring
            const secondaryCount = Math.min(30, MAX_PARTICLES - activeParticles.length);
            for (let i = 0; i < secondaryCount; i++) {
                const particle = getParticle();
                if (!particle) break;
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.life = 1.5;
                particle.color = '#FF4500';
            }
        }
        
        let screenShakeAmount = 0;
        function createScreenShake() {
            screenShakeAmount = 20;
        }
        
        function updateParticles(deltaTime) {
            // Update active particles from pool
            activeParticles = particlePool.filter(p => p.active);
            
            for (let i = 0; i < activeParticles.length; i++) {
                const p = activeParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime / 1000;
                
                if (p.life <= 0) {
                    releaseParticle(p);
                }
            }
        }
        
        function drawParticles() {
            // Only draw active particles that are visible
            for (let i = 0; i < activeParticles.length; i++) {
                const p = activeParticles[i];
                const screenX = p.x - camera.x + canvas.width / 2;
                const screenY = p.y - camera.y + canvas.height / 2;
                
                // Viewport culling
                if (screenX < -10 || screenX > canvas.width + 10 ||
                    screenY < -10 || screenY > canvas.height + 10) continue;
                
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
            }
            ctx.globalAlpha = 1;
        }
        
        function createScorePopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            popup.textContent = `+${points}`;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1500);
        }
        
        function createElementPopup(x, y, element, points) {
            const popup = document.createElement('div');
            popup.className = 'element-popup';
            popup.style.cssText = `
                position: fixed;
                color: white;
                font-size: 16px;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
                z-index: 100;
                animation: elementFloat 1s ease-out;
                text-align: center;
            `;
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top - 20;
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            popup.innerHTML = `${element.emoji} ${element.name}<br><span style="color: #FFD700; font-size: 14px;">+${points}</span>`;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1000);
        }
        
        function createCombinationPopup(x, y, element, isNew) {
            const popup = document.createElement('div');
            popup.className = 'combination-popup';
            popup.style.cssText = `
                position: fixed;
                left: 50%;
                top: 80px;
                transform: translateX(-50%);
                color: ${isNew ? '#FFD700' : '#00FF00'};
                font-size: ${isNew ? '24px' : '20px'};
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
                z-index: 100;
                animation: ${isNew ? 'newDiscoveryPop' : 'combinationPop'} 2s ease-out;
                text-align: center;
                background: rgba(0,0,0,0.7);
                padding: 10px 20px;
                border-radius: 10px;
                border: 2px solid ${isNew ? '#FFD700' : '#00FF00'};
            `;
            popup.innerHTML = `
                ${isNew ? '‚ú® NEW DISCOVERY! ‚ú®<br>' : ''}
                ${element.emoji} ${element.name} created!
                ${isNew ? '<br><span style="font-size: 14px; color: #AAA;">First time discovering this element!</span>' : ''}
            `;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 2000);
        }
        
        function showAchievement(element) {
            // Achievement display removed - using only the fixed popup above element bar
        }
        
        function createCombinationFlash(x, y) {
            const flash = document.createElement('div');
            flash.className = 'combination-flash';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            flash.style.left = screenX + 'px';
            flash.style.top = screenY + 'px';
            flash.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.remove();
            }, 500);
        }
        
        function showDiscovery(element) {
            const display = document.getElementById('recentDiscovery');
            display.textContent = `NEW DISCOVERY: ${element.emoji} ${element.name}!`;
            display.style.opacity = '1';
            
            setTimeout(() => {
                display.style.opacity = '0';
            }, 4000);
        }
        
        function updateElementQueue() {
            if (!playerSnake) return;
            
            const queue = document.getElementById('elementQueue');
            queue.innerHTML = '';
            
            // Count unique elements
            const elementCounts = {};
            playerSnake.elements.forEach(elementType => {
                elementCounts[elementType] = (elementCounts[elementType] || 0) + 1;
            });
            
            const uniqueElements = Object.keys(elementCounts);
            const maxDisplay = 12; // Maximum elements to show before collapsing
            const isCollapsed = uniqueElements.length > maxDisplay;
            
            // Show unique elements with counts
            uniqueElements.slice(0, isCollapsed ? maxDisplay : uniqueElements.length).forEach((elementType, i) => {
                const element = elementDatabase[elementType];
                const count = elementCounts[elementType];
                
                if (element) {
                    const div = document.createElement('div');
                    div.className = 'queueElement';
                    
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji';
                    emoji.textContent = element.emoji;
                    
                    const info = document.createElement('div');
                    info.className = 'name';
                    info.textContent = count > 1 ? `${element.name} x${count}` : element.name;
                    
                    div.appendChild(emoji);
                    div.appendChild(info);
                    
                    queue.appendChild(div);
                }
            });
            
            // Add collapse indicator
            if (isCollapsed) {
                const more = document.createElement('div');
                more.className = 'queueElement';
                more.style.background = 'rgba(255,215,0,0.2)';
                more.innerHTML = `
                    <div class="emoji">...</div>
                    <div class="name">+${uniqueElements.length - maxDisplay} more</div>
                `;
                queue.appendChild(more);
            }
        }
        
        let lastDiscoveredElement = null;
        
        function updateDiscoveryLog() {
            if (!playerSnake) return;
            
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            // Get all discovered elements and sort by tier (highest first)
            const discovered = Array.from(playerSnake.discoveredElements)
                .filter(elementKey => {
                    const element = elementDatabase[elementKey];
                    return element && element.tier > 0;
                })
                .sort((a, b) => {
                    const elemA = elementDatabase[a];
                    const elemB = elementDatabase[b];
                    // Sort by tier descending, then alphabetically
                    if (elemB.tier !== elemA.tier) {
                        return elemB.tier - elemA.tier;
                    }
                    return a.localeCompare(b);
                });
            
            discovered.forEach(elementKey => {
                const element = elementDatabase[elementKey];
                if (element) {
                    const div = document.createElement('div');
                    div.className = 'discovery-item';
                    
                    // Highlight if this is the newest discovery
                    if (elementKey === lastDiscoveredElement) {
                        div.classList.add('new');
                        // Remove highlight after animation
                        setTimeout(() => {
                            lastDiscoveredElement = null;
                        }, 2000);
                    }
                    
                    div.innerHTML = `
                        <div class="emoji">${element.emoji}</div>
                        <div class="info">
                            <div class="name">${element.name}</div>
                            <div class="tier">Tier ${element.tier}</div>
                        </div>
                    `;
                    list.appendChild(div);
                }
            });
            
            // Update count in header
            const header = document.querySelector('#discoveryLog h3');
            if (header) {
                header.textContent = `Discovered Elements (${discovered.length})`;
            }
        }
        
        function updateLeaderboard() {
            const sortedSnakes = snakes
                .filter(s => s.alive)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = sortedSnakes.map((snake, index) => `
                <div style="${snake.isPlayer ? 'color: #FFD700;' : ''}">
                    ${index + 1}. ${snake.name} - ${Math.floor(snake.score)}
                </div>
            `).join('');
        }
        
        function checkCollisions() {
            snakes.forEach(snake => {
                if (!snake.alive) return;
                
                // Element collisions
                elements.forEach(element => {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + element.size + 5) { // Added 5 pixel buffer
                        snake.consume(element);
                    }
                });
                
                // Snake collisions
                snakes.forEach(otherSnake => {
                    if (snake === otherSnake || !otherSnake.alive) return;
                    
                    // Check head-to-head collision
                    const headDist = Math.hypot(otherSnake.x - snake.x, otherSnake.y - snake.y);
                    if (headDist < SEGMENT_SIZE) {
                        // Check for invincibility
                        if (snake.invincibilityTimer > 0 || otherSnake.invincibilityTimer > 0) {
                            return; // One or both are immune
                        }
                        
                        // Head-to-head: shorter snake explodes
                        if (snake.length < otherSnake.length) {
                            snake.explode();
                        } else if (otherSnake.length < snake.length) {
                            otherSnake.explode();
                        } else {
                            // Same length: both explode
                            snake.explode();
                            otherSnake.explode();
                        }
                        return;
                    }
                    
                    // Check head collision with other snake's body
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        
                        if (dist < SEGMENT_SIZE) {
                            // Check for invincibility
                            if (snake.invincibilityTimer > 0) {
                                return; // Immune to damage
                            }
                            
                            // Running into body always causes explosion
                            snake.explode();
                            return;
                        }
                    }
                });
            });
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw borders
            drawBorders();
        }
        
        function drawBorders() {
            const borderThickness = 20;
            const warningDistance = 100;
            
            // Calculate border positions in screen space
            const leftBorder = -camera.x + canvas.width / 2;
            const rightBorder = WORLD_SIZE - camera.x + canvas.width / 2;
            const topBorder = -camera.y + canvas.height / 2;
            const bottomBorder = WORLD_SIZE - camera.y + canvas.height / 2;
            
            // Warning gradient effect
            ctx.save();
            
            // Left border
            if (leftBorder > -borderThickness) {
                const grad = ctx.createLinearGradient(leftBorder, 0, leftBorder + warningDistance, 0);
                grad.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                grad.addColorStop(0.2, 'rgba(255, 0, 0, 0.5)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, leftBorder + warningDistance, canvas.height);
                
                // Solid border line
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(Math.max(0, leftBorder - borderThickness), 0, borderThickness, canvas.height);
            }
            
            // Right border
            if (rightBorder < canvas.width + borderThickness) {
                const grad = ctx.createLinearGradient(rightBorder, 0, rightBorder - warningDistance, 0);
                grad.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                grad.addColorStop(0.2, 'rgba(255, 0, 0, 0.5)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(rightBorder - warningDistance, 0, canvas.width, canvas.height);
                
                // Solid border line
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(rightBorder, 0, Math.min(borderThickness, canvas.width - rightBorder), canvas.height);
            }
            
            // Top border
            if (topBorder > -borderThickness) {
                const grad = ctx.createLinearGradient(0, topBorder, 0, topBorder + warningDistance);
                grad.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                grad.addColorStop(0.2, 'rgba(255, 0, 0, 0.5)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, canvas.width, topBorder + warningDistance);
                
                // Solid border line
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(0, Math.max(0, topBorder - borderThickness), canvas.width, borderThickness);
            }
            
            // Bottom border
            if (bottomBorder < canvas.height + borderThickness) {
                const grad = ctx.createLinearGradient(0, bottomBorder, 0, bottomBorder - warningDistance);
                grad.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                grad.addColorStop(0.2, 'rgba(255, 0, 0, 0.5)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, bottomBorder - warningDistance, canvas.width, canvas.height);
                
                // Solid border line
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(0, bottomBorder, canvas.width, Math.min(borderThickness, canvas.height - bottomBorder));
            }
            
            // Corner warning indicators
            const pulseIntensity = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseIntensity})`;
            ctx.lineWidth = 3;
            
            // Draw corner brackets if near edges
            const cornerSize = 50;
            if (leftBorder > -100 && topBorder > -100) {
                ctx.beginPath();
                ctx.moveTo(leftBorder + cornerSize, topBorder);
                ctx.lineTo(leftBorder, topBorder);
                ctx.lineTo(leftBorder, topBorder + cornerSize);
                ctx.stroke();
            }
            
            if (rightBorder < canvas.width + 100 && topBorder > -100) {
                ctx.beginPath();
                ctx.moveTo(rightBorder - cornerSize, topBorder);
                ctx.lineTo(rightBorder, topBorder);
                ctx.lineTo(rightBorder, topBorder + cornerSize);
                ctx.stroke();
            }
            
            if (leftBorder > -100 && bottomBorder < canvas.height + 100) {
                ctx.beginPath();
                ctx.moveTo(leftBorder + cornerSize, bottomBorder);
                ctx.lineTo(leftBorder, bottomBorder);
                ctx.lineTo(leftBorder, bottomBorder - cornerSize);
                ctx.stroke();
            }
            
            if (rightBorder < canvas.width + 100 && bottomBorder < canvas.height + 100) {
                ctx.beginPath();
                ctx.moveTo(rightBorder - cornerSize, bottomBorder);
                ctx.lineTo(rightBorder, bottomBorder);
                ctx.lineTo(rightBorder, bottomBorder - cornerSize);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function updateCamera() {
            if (playerSnake && playerSnake.alive) {
                // Apply screen shake if active
                const shakeX = screenShakeAmount > 0 ? (Math.random() - 0.5) * screenShakeAmount : 0;
                const shakeY = screenShakeAmount > 0 ? (Math.random() - 0.5) * screenShakeAmount : 0;
                
                camera.x = playerSnake.x + shakeX;
                camera.y = playerSnake.y + shakeY;
                
                // Decay screen shake
                if (screenShakeAmount > 0) {
                    screenShakeAmount *= 0.9;
                    if (screenShakeAmount < 0.1) screenShakeAmount = 0;
                }
            }
        }
        
        let elementSpawnTimer = 0;
        let lastTime = 0;
        let accumulator = 0;
        const FIXED_TIMESTEP = 16.67; // 60 FPS
        const MAX_UPDATES = 5; // Prevent spiral of death
        
        function gameLoop(currentTime) {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Calculate frame delta
            const frameTime = Math.min(currentTime - lastTime, 250); // Cap at 250ms
            lastTime = currentTime;
            
            // Accumulate time for fixed timestep
            accumulator += frameTime;
            
            // Fixed timestep updates
            let updates = 0;
            while (accumulator >= FIXED_TIMESTEP && updates < MAX_UPDATES) {
                if (!paused) {
                    updateGame(FIXED_TIMESTEP);
                }
                accumulator -= FIXED_TIMESTEP;
                updates++;
            }
            
            // Interpolation factor for smooth rendering
            const interpolation = accumulator / FIXED_TIMESTEP;
            
            // Render with interpolation
            render(interpolation);
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateGame(deltaTime) {
            // Element spawning - faster rate
            elementSpawnTimer += deltaTime;
            if (elementSpawnTimer > 1000) { // Spawn every second instead of 2
                elementSpawnTimer = 0;
                // Spawn 2-3 elements at once
                const spawnCount = 2 + Math.floor(Math.random() * 2);
                for (let i = 0; i < spawnCount; i++) {
                    spawnElement();
                }
            }
            
            // Maintain minimum elements on board
            if (elements.length < 50) { // Increased from 40 to 50
                spawnElement();
            }
            
            // Update elements
            for (let i = elements.length - 1; i >= 0; i--) {
                if (!elements[i].update(deltaTime)) {
                    elements.splice(i, 1);
                }
            }
            
            // Update snakes
            snakes.forEach(snake => snake.update(deltaTime));
            
            // Update particles
            updateParticles(deltaTime);
            
            // Collisions
            checkCollisions();
            
            // Camera
            updateCamera();
            
            // Remove dead AI snakes
            for (let i = snakes.length - 1; i >= 0; i--) {
                if (!snakes[i].alive && !snakes[i].isPlayer) {
                    snakes.splice(i, 1);
                }
            }
            
            // Spawn AI if needed
            const aliveAI = snakes.filter(s => !s.isPlayer && s.alive).length;
            if (aliveAI < 8) { // Increased from 5 to 8 for more activity
                const borderPadding = 200;
                const aiSnake = new Snake(
                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2),
                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2),
                    false
                );
                snakes.push(aiSnake);
            }
            
            // Check victory
            if (gameMode > 0 && playerSnake && playerSnake.discoveries >= targetDiscoveries) {
                alert(`üéâ VICTORY! üéâ\n\nYou've mastered the elements and discovered ${targetDiscoveries} combinations!\n\nFinal Score: ${Math.floor(playerSnake.score)}`);
                location.reload();
            }
        }
        
        function render(interpolation) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Draw elements
            elements.forEach(element => element.draw());
            
            // Draw snakes
            snakes.forEach(snake => snake.draw());
            
            // Draw particles
            drawParticles();
            
            // Update UI
            updateLeaderboard();
        }
        
        // Controls
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
                
                if (e.key === 'p' || e.key === 'P') {
                    togglePause();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        });
        
        // Start game
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        // Game mode selection
        let selectedMode = null;
        
        window.selectVictoryMode = function(mode) {
            selectedMode = mode;
            gameMode = mode;
            targetDiscoveries = mode;
            
            // Show control section
            document.getElementById('controlSection').style.display = 'block';
            
            // Show loading indicator if database isn't loaded
            if (!elementsLoaded) {
                document.getElementById('loadingIndicator').style.display = 'block';
            }
            
            // Highlight selected button
            const buttons = document.querySelectorAll('#victoryButtons button');
            buttons.forEach(btn => btn.style.opacity = '0.6');
            event.target.style.opacity = '1';
        };
        
        // Control selection
        window.selectControls = function(scheme) {
            if (selectedMode === null) {
                alert('Please select a victory condition first!');
                return;
            }
            
            controlScheme = scheme;
            
            // Update control display
            const controlsText = document.getElementById('controlsText');
            if (scheme === 'arrows') {
                controlsText.textContent = 'Arrow Keys: Move ‚Ä¢ P: Pause';
            } else if (scheme === 'wasd') {
                controlsText.textContent = 'WASD: Move ‚Ä¢ P: Pause';
            } else if (scheme === 'mouse') {
                controlsText.textContent = 'Mouse: Move ‚Ä¢ P: Pause';
                document.body.style.cursor = 'default';
            }
            
            // Hide game mode select and start game
            document.getElementById('gameModeSelect').style.display = 'none';
            
            // Make sure arrays are initialized
            if (!snakes) snakes = [];
            if (!elements) elements = [];
            if (!particles) particles = [];
            
            startActualGame();
        };
        
        function startActualGame() {
            // Wait for element database to load
            if (!elementsLoaded) {
                setTimeout(startActualGame, 100);
                return;
            }
            
            gameStarted = true;
            
            // Start music
            initMusic();
            
            // Initialize player
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            playerSnake.angle = -Math.PI / 2; // Face upward
            
            // Load discovered elements from localStorage
            const savedDiscoveries = localStorage.getItem('infiniteSnakeDiscoveries');
            if (savedDiscoveries) {
                try {
                    const discoveries = JSON.parse(savedDiscoveries);
                    playerSnake.discoveredElements = new Set(discoveries);
                    playerSnake.discoveries = discoveries.filter(e => elementDatabase[e] && elementDatabase[e].tier > 0).length;
                } catch (e) {
                    console.error('Failed to load discoveries:', e);
                }
            }
            
            snakes.push(playerSnake);
            
            // Initialize AI snakes (away from borders)
            const borderPadding = 200;
            for (let i = 0; i < 8; i++) {
                const aiSnake = new Snake(
                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2),
                    borderPadding + Math.random() * (WORLD_SIZE - borderPadding * 2),
                    false
                );
                snakes.push(aiSnake);
            }
            
            // Initial elements - more for less sparse board
            for (let i = 0; i < 60; i++) {
                spawnElement();
            }
            
            updateDiscoveryLog();
            updateElementQueue();
        }
        
        // Reset game function
        window.resetGame = function() {
            if (confirm('Are you sure you want to reset? This will delete ALL progress, discoveries, and unlocked skins!')) {
                // Clear all game data
                localStorage.removeItem('infiniteSnakeTotalScore');
                localStorage.removeItem('infiniteSnakeDiscoveries');
                totalScore = 0;
                playerSkin = SNAKE_SKINS[0];
                
                // Reload the page to reset everything
                location.reload();
            }
        };
        
        // Pause functionality
        function togglePause() {
            paused = !paused;
            const overlay = document.getElementById('pauseOverlay');
            if (paused) {
                overlay.style.display = 'flex';
                updateSkinMenu();
                // Update total score display
                document.getElementById('totalScoreDisplay').textContent = `Total Score: ${totalScore}`;
                // Update music button state
                const muteButton = document.getElementById('muteButton');
                muteButton.textContent = musicMuted ? 'üîá Unmute' : 'üîä Mute';
                document.getElementById('volumeSlider').value = musicVolume * 100;
                document.getElementById('volumeDisplay').textContent = Math.round(musicVolume * 100) + '%';
                // Update discovery list
                updatePauseDiscoveryList();
            } else {
                overlay.style.display = 'none';
            }
        }
        
        window.resumeGame = function() {
            paused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
        };
        
        // Skin menu
        function updateSkinMenu() {
            const menu = document.getElementById('skinMenu');
            menu.innerHTML = '';
            
            SNAKE_SKINS.forEach(skin => {
                const div = document.createElement('div');
                div.className = 'skinOption';
                
                if (skin.unlockPoints <= totalScore) {
                    div.innerHTML = `
                        ${skin.emoji}
                        <small>${skin.name}</small>
                    `;
                    if (skin.id === playerSkin.id) {
                        div.classList.add('selected');
                    }
                    div.onclick = () => selectSkin(skin);
                } else {
                    div.classList.add('locked');
                    div.innerHTML = `
                        üîí
                        <small>${skin.unlockPoints} pts</small>
                    `;
                }
                
                menu.appendChild(div);
            });
        }
        
        function selectSkin(skin) {
            playerSkin = skin;
            if (playerSnake) {
                playerSnake.skin = skin;
            }
            updateSkinMenu();
        }
        
        // Mouse controls
        window.addEventListener('mousemove', (e) => {
            if (controlScheme === 'mouse' && playerSnake && playerSnake.alive) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
            }
        });
        
        // Save total score
        function saveProgress() {
            if (playerSnake && playerSnake.score > 0) {
                const scoreToAdd = Math.floor(playerSnake.score);
                totalScore += scoreToAdd;
                localStorage.setItem('infiniteSnakeTotalScore', totalScore.toString());
                console.log(`Score added: ${scoreToAdd}, Total score: ${totalScore}`);
            }
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 290; // Account for sidebar
            canvas.height = window.innerHeight - 40;
        });
        
        // Music functions
        function initMusic() {
            // Check which tracks are available
            checkAvailableTracks().then(() => {
                if (availableTracks.length > 0) {
                    playRandomTrack();
                }
            });
        }
        
        async function checkAvailableTracks() {
            availableTracks = [];
            // For now, assume all tracks are available since HEAD requests might be blocked
            availableTracks = [...musicTracks];
        }
        
        function playRandomTrack() {
            if (availableTracks.length === 0) return;
            
            // Stop current track if playing
            if (currentTrack) {
                currentTrack.pause();
                currentTrack.remove();
            }
            
            // Pick random track
            const randomIndex = Math.floor(Math.random() * availableTracks.length);
            const trackName = availableTracks[randomIndex];
            
            // Create audio element
            currentTrack = new Audio(`music/${trackName}`);
            currentTrack.volume = musicMuted ? 0 : musicVolume;
            
            // Play next track when this one ends
            currentTrack.addEventListener('ended', () => {
                playRandomTrack();
            });
            
            // Try to play
            currentTrack.play().catch(e => {
                console.log('Music autoplay blocked, will play on first interaction:', e);
                // Try again on next user interaction
                document.addEventListener('click', () => {
                    if (currentTrack && currentTrack.paused) {
                        currentTrack.play().catch(() => {});
                    }
                }, { once: true });
            });
        }
        
        window.toggleMusic = function() {
            musicMuted = !musicMuted;
            const button = document.getElementById('muteButton');
            
            if (musicMuted) {
                button.textContent = 'üîá Unmute';
                if (currentTrack) currentTrack.volume = 0;
            } else {
                button.textContent = 'üîä Mute';
                if (currentTrack) currentTrack.volume = musicVolume;
            }
        };
        
        window.changeVolume = function(value) {
            musicVolume = value / 100;
            document.getElementById('volumeDisplay').textContent = value + '%';
            
            if (currentTrack && !musicMuted) {
                currentTrack.volume = musicVolume;
            }
        };
        
        // Try to play music on first user interaction
        document.addEventListener('click', function playMusicOnInteraction() {
            if (currentTrack && currentTrack.paused && gameStarted) {
                currentTrack.play().catch(() => {});
            }
            // Remove listener after first interaction
            document.removeEventListener('click', playMusicOnInteraction);
        }, { once: true });
        
        function updatePauseDiscoveryList() {
            if (!playerSnake) return;
            
            const list = document.getElementById('pauseDiscoveryList');
            list.innerHTML = '';
            
            // Get all discovered elements sorted by tier (excluding basic elements)
            const discovered = Array.from(playerSnake.discoveredElements)
                .map(elementKey => ({
                    key: elementKey,
                    element: elementDatabase[elementKey]
                }))
                .filter(item => item.element && item.element.tier > 0) // Only show tier 1+ to match sidebar
                .sort((a, b) => {
                    // Sort by tier descending, then alphabetically
                    if (b.element.tier !== a.element.tier) {
                        return b.element.tier - a.element.tier;
                    }
                    return a.element.name.localeCompare(b.element.name);
                });
            
            discovered.forEach(item => {
                const div = document.createElement('div');
                div.style.cssText = `
                    background: rgba(255,255,255,0.05);
                    border-radius: 6px;
                    padding: 8px;
                    text-align: center;
                    border: 1px solid rgba(255,255,255,0.1);
                    transition: all 0.2s;
                    cursor: pointer;
                `;
                
                // Color based on tier
                const tierColors = {
                    0: '#888',
                    1: '#4CAF50',
                    2: '#2196F3',
                    3: '#9C27B0',
                    4: '#FF9800',
                    5: '#F44336'
                };
                const borderColor = tierColors[item.element.tier] || '#FFD700';
                div.style.borderColor = borderColor;
                
                div.onmouseover = () => {
                    div.style.background = 'rgba(255,255,255,0.1)';
                    div.style.transform = 'scale(1.05)';
                };
                div.onmouseout = () => {
                    div.style.background = 'rgba(255,255,255,0.05)';
                    div.style.transform = 'scale(1)';
                };
                
                div.innerHTML = `
                    <div style="font-size: 24px; margin-bottom: 2px;">${item.element.emoji}</div>
                    <div style="font-weight: bold; font-size: 10px; color: white; line-height: 1.2;">${item.element.name}</div>
                    <div style="font-size: 9px; color: ${borderColor};">Tier ${item.element.tier}</div>
                `;
                
                list.appendChild(div);
            });
            
            // Add total count
            const totalDiv = document.createElement('div');
            totalDiv.style.cssText = `
                grid-column: 1 / -1;
                text-align: center;
                color: #AAA;
                font-size: 14px;
                margin-top: 10px;
            `;
            totalDiv.textContent = `Total Discoveries: ${discovered.length}`;
            list.appendChild(totalDiv);
        }
        
        // Start game loop
        requestAnimationFrame(gameLoop);
        
        // Debug: Log initial state
        console.log('Game initialized. Canvas:', canvas.width, 'x', canvas.height);
        console.log('Elements loaded:', elementsLoaded);
        console.log('Splash screen present:', !!document.getElementById('splashScreen'));
        console.log('Start button present:', !!document.getElementById('startButton'));
        
        // Ensure splash screen is visible
        const splash = document.getElementById('splashScreen');
        if (splash) {
            splash.style.display = 'flex';
            splash.style.opacity = '1';
        }
    </script>
</body>
</html>