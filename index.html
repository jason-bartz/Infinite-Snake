<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Snake - Elemental Mastery</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #discoveries {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
        #recentDiscovery {
            position: absolute;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            color: #00FF00;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #elementQueue {
            position: absolute;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid #444;
            display: flex;
            gap: 8px;
            align-items: center;
            font-size: 14px;
        }
        .queueElement {
            font-size: 20px;
            padding: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            position: relative;
        }
        .queueElement.compatible {
            animation: glow 1s infinite;
        }
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(255,215,0,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,215,0,0.8); }
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 1px solid #444;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 14px;
            border: 1px solid #444;
        }
        #discoveryLog {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #444;
        }
        #discoveryLog h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #FFD700;
        }
        .discovery-item {
            margin: 5px 0;
            font-size: 12px;
            padding: 3px 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0033, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s;
        }
        #splashScreen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B, #4ECDC4, #FFD700);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient 3s ease infinite;
        }
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        #gameModeSelect {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 50;
        }
        #gameModeSelect button {
            margin: 5px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        #powerUpIndicator {
            position: absolute;
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .achievement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 20px 40px;
            border-radius: 15px;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            z-index: 200;
            opacity: 0;
            animation: achievementPop 3s ease-out;
            text-align: center;
        }
        @keyframes achievementPop {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.1);
            }
            30% {
                transform: translate(-50%, -50%) scale(1);
            }
            80% {
                opacity: 1;
            }
            100% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }
        .achievement h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .achievement .element-display {
            font-size: 48px;
            margin: 10px 0;
        }
        .achievement .element-name {
            font-size: 20px;
            color: white;
            margin-bottom: 5px;
        }
        .achievement .tier-info {
            font-size: 14px;
            color: #AAA;
        }
        .score-popup {
            position: fixed;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
            animation: scoreFloat 1.5s ease-out;
        }
        @keyframes scoreFloat {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }
        @keyframes flashExpand {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="splashScreen">
        <h1>Infinite Snake</h1>
        <p>You are an Infinite Snake - a mystical serpent capable of endless growth and elemental mastery. Consume the scattered elements of creation, combine them within your ever-expanding form, and unlock the infinite possibilities that lie within the realm.</p>
        <button id="startButton">Begin Your Journey</button>
    </div>
    
    <div id="score">Score: 0</div>
    <div id="discoveries">Discoveries: 0 / ?</div>
    <div id="recentDiscovery"></div>
    <div id="powerUpIndicator"></div>
    
    <div id="elementQueue"></div>
    
    <div id="discoveryLog">
        <h3>Discovered Elements</h3>
        <div id="discoveryList"></div>
    </div>
    
    <div id="leaderboard">
        <h3>Leaderboard</h3>
        <div id="leaderboard-list"></div>
    </div>
    
    <div id="controls">
        Arrow Keys: Move â€¢ P: Pause
    </div>
    
    <div id="gameModeSelect">
        <h3>Select Victory Condition</h3>
        <button onclick="startGame(100)">Discovery Race: 100</button>
        <button onclick="startGame(200)">Discovery Race: 200</button>
        <button onclick="startGame(500)">Discovery Race: 500</button>
        <button onclick="startGame(1000)">Discovery Race: 1000</button>
        <button onclick="startGame(0)">Infinite Mode</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth - 40;
        canvas.height = window.innerHeight - 40;
        
        // Game constants
        const WORLD_SIZE = 2000;
        const SEGMENT_SIZE = 20;
        const ELEMENT_SIZE = 15;
        const SPEED = 4;
        const TURN_SPEED = 0.08;
        
        // Element System
        const BASIC_ELEMENTS = {
            fire: { emoji: 'ðŸ”¥', name: 'Fire', tier: 0 },
            water: { emoji: 'ðŸ’§', name: 'Water', tier: 0 },
            earth: { emoji: 'ðŸŒ', name: 'Earth', tier: 0 },
            air: { emoji: 'ðŸ’¨', name: 'Air', tier: 0 }
        };
        
        // Combination database - will be loaded from JSON files
        let COMBINATIONS = {};
        let ALL_ELEMENTS = {};
        let totalCombinations = 0;
        
        // Temporary fallback combinations
        const FALLBACK_COMBINATIONS = {
            'fire+water': { emoji: 'ðŸ’¨', name: 'Steam', tier: 1 },
            'fire+earth': { emoji: 'ðŸŒ‹', name: 'Lava', tier: 1 },
            'water+earth': { emoji: 'ðŸŒ±', name: 'Plant', tier: 1 },
            'air+air': { emoji: 'ðŸŒªï¸', name: 'Wind', tier: 1 },
            'fire+air': { emoji: 'âš¡', name: 'Energy', tier: 1 },
            'water+air': { emoji: 'â˜ï¸', name: 'Cloud', tier: 1 },
            'earth+earth': { emoji: 'ðŸª¨', name: 'Stone', tier: 1 },
            'water+water': { emoji: 'ðŸŒŠ', name: 'Wave', tier: 1 },
            'fire+fire': { emoji: 'ðŸ”¥', name: 'Blaze', tier: 1 }
        };
        
        // Initialize with fallback
        COMBINATIONS = { ...FALLBACK_COMBINATIONS };
        
        // Power-up mappings
        const ELEMENT_POWERS = {
            'lava': { type: 'lava_body', duration: 5000, color: '#FF4500' },
            'lightning': { type: 'speed', duration: 6000, color: '#FFD700' },
            'crystal': { type: 'armor', duration: 7000, color: '#00BFFF' },
            'ice': { type: 'ice_trail', duration: 5000, color: '#87CEEB' },
            'wind': { type: 'magnet', duration: 8000, color: '#98FB98' },
            'hurricane': { type: 'magnet', duration: 10000, color: '#4169E1' },
            'dragon': { type: 'lava_body', duration: 10000, color: '#FF6347' },
            'magic': { type: 'speed', duration: 8000, color: '#FF1493' }
        };
        
        // Game state
        let gameMode = 0;
        let targetDiscoveries = 0;
        let paused = false;
        let gameStarted = false;
        const camera = { x: 0, y: 0 };
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            p: false,
            P: false
        };
        
        // Game arrays
        let snakes = [];
        let elements = [];
        let particles = [];
        let playerSnake = null;
        
        // Snake colors palette
        const SNAKE_COLORS = [
            { primary: '#FF6B6B', secondary: '#FF5252', face: 'ðŸ˜Š' },
            { primary: '#4ECDC4', secondary: '#45B7AA', face: 'ðŸ˜„' },
            { primary: '#FFE66D', secondary: '#FFD93D', face: 'ðŸ˜' },
            { primary: '#A8E6CF', secondary: '#81C784', face: 'ðŸ˜Ž' },
            { primary: '#C7CEEA', secondary: '#B39DDB', face: 'ðŸ¤—' },
            { primary: '#FF8CC8', secondary: '#FF6BB3', face: 'ðŸ˜‹' },
            { primary: '#FFB347', secondary: '#FFA000', face: 'ðŸ˜Š' },
            { primary: '#B4E7CE', secondary: '#81C784', face: 'ðŸ˜Œ' },
            { primary: '#FFDAC1', secondary: '#FFAB91', face: 'ðŸ¥°' },
            { primary: '#E0BBE4', secondary: '#CE93D8', face: 'ðŸ˜‡' }
        ];
        
        let snakeColorIndex = 1; // Start at 1 since player gets 0
        
        // Discovery tracking
        const discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
        let elementDatabase = { ...BASIC_ELEMENTS };
        
        // Initialize discovered elements in database
        Object.values(COMBINATIONS).forEach(combo => {
            elementDatabase[combo.name.toLowerCase()] = combo;
        });
        
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * Math.PI * 2;
                this.segments = [];
                this.elements = []; // Elements in body
                this.length = 10;
                this.score = 0;
                this.discoveries = 0;
                this.isPlayer = isPlayer;
                this.speed = SPEED;
                this.alive = true;
                this.name = isPlayer ? 'You' : `Snake${Math.floor(Math.random() * 1000)}`;
                
                // Assign color
                if (isPlayer) {
                    this.color = SNAKE_COLORS[0]; // Player always gets the first color
                } else {
                    this.color = SNAKE_COLORS[snakeColorIndex % SNAKE_COLORS.length];
                    snakeColorIndex++;
                }
                
                // Power-ups
                this.activePower = null;
                this.powerTimer = 0;
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    this.segments.push({
                        x: x - i * SEGMENT_SIZE * Math.cos(this.angle),
                        y: y - i * SEGMENT_SIZE * Math.sin(this.angle)
                    });
                }
                
                // Initialize with random basic elements
                for (let i = 0; i < 5; i++) {
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    const randomElement = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    this.elements.push(randomElement);
                }
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                // Update power-up timer
                if (this.activePower && this.powerTimer > 0) {
                    this.powerTimer -= deltaTime;
                    if (this.powerTimer <= 0) {
                        this.activePower = null;
                        if (this.isPlayer) {
                            document.getElementById('powerUpIndicator').style.opacity = '0';
                        }
                    }
                }
                
                // Calculate speed
                let currentSpeed = this.speed;
                if (this.activePower === 'speed') {
                    currentSpeed *= 1.5;
                }
                
                // Player controls
                if (this.isPlayer) {
                    if (keys.ArrowLeft) {
                        this.angle -= TURN_SPEED;
                    }
                    if (keys.ArrowRight) {
                        this.angle += TURN_SPEED;
                    }
                } else {
                    // Simple AI - target nearest element
                    let nearestElement = null;
                    let minDist = 400; // Increased vision range
                    
                    elements.forEach(element => {
                        const dist = Math.hypot(element.x - this.x, element.y - this.y);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestElement = element;
                        }
                    });
                    
                    if (nearestElement) {
                        const targetAngle = Math.atan2(nearestElement.y - this.y, nearestElement.x - this.x);
                        let angleDiff = targetAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.08; // Slightly faster turning
                    } else {
                        // Wander
                        this.angle += (Math.random() - 0.5) * 0.1;
                    }
                }
                
                // Move head
                this.x += Math.cos(this.angle) * currentSpeed;
                this.y += Math.sin(this.angle) * currentSpeed;
                
                // World wrap
                if (this.x < 0) this.x = WORLD_SIZE;
                if (this.x > WORLD_SIZE) this.x = 0;
                if (this.y < 0) this.y = WORLD_SIZE;
                if (this.y > WORLD_SIZE) this.y = 0;
                
                // Update segments
                this.segments.unshift({ x: this.x, y: this.y });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
                
                // Survival score
                this.score += 1 * deltaTime / 1000; // Reduced from 10 to 1 for balance
                
                if (this.isPlayer) {
                    document.getElementById('score').textContent = `Score: ${Math.floor(this.score)}`;
                    const totalPossible = Object.keys(ALL_ELEMENTS).length || '?';
                    document.getElementById('discoveries').textContent = 
                        gameMode === 0 ? `Discoveries: ${this.discoveries} / ${totalPossible}` : 
                        `Discoveries: ${this.discoveries} / ${targetDiscoveries}`;
                }
            }
            
            checkCombinations() {
                if (this.elements.length < 2) return;
                
                const combinationsFound = [];
                
                // Check adjacent elements
                for (let i = 0; i < this.elements.length - 1; i++) {
                    const elem1 = this.elements[i];
                    const elem2 = this.elements[i + 1];
                    
                    // Try both orders
                    const combo1 = `${elem1}+${elem2}`;
                    const combo2 = `${elem2}+${elem1}`;
                    
                    let result = COMBINATIONS[combo1] || COMBINATIONS[combo2];
                    
                    if (result) {
                        combinationsFound.push({
                            index: i,
                            result: result,
                            elem1: elem1,
                            elem2: elem2
                        });
                    }
                }
                
                // Process combinations (in reverse to maintain indices)
                for (let i = combinationsFound.length - 1; i >= 0; i--) {
                    const combo = combinationsFound[i];
                    
                    // Visual flash at combination location
                    if (combo.index < this.segments.length) {
                        createCombinationFlash(
                            this.segments[combo.index].x,
                            this.segments[combo.index].y
                        );
                    }
                    
                    // Remove used elements
                    this.elements.splice(combo.index, 2);
                    
                    // Add new element at the head
                    this.elements.unshift(combo.result.name.toLowerCase());
                    
                    // Discovery tracking
                    const elementKey = combo.result.name.toLowerCase();
                    const isNewDiscovery = !discoveredElements.has(elementKey);
                    
                    if (isNewDiscovery) {
                        discoveredElements.add(elementKey);
                        this.discoveries++;
                        
                        // Add to element database for spawning
                        if (!elementDatabase[elementKey]) {
                            elementDatabase[elementKey] = combo.result;
                        }
                        
                        // Scoring
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        const totalPoints = discoveryPoints * 2; // Double points for first discovery
                        this.score += totalPoints;
                        
                        // Visual feedback
                        if (this.isPlayer) {
                            showDiscovery(combo.result);
                            showAchievement(combo.result);
                            createDiscoveryParticles(this.x, this.y);
                            createScorePopup(this.x, this.y, totalPoints);
                            
                            // Discovery cascade - spawn copies
                            for (let j = 0; j < 3 + Math.floor(Math.random() * 3); j++) {
                                spawnElement(combo.result.name.toLowerCase(), 
                                    this.x + (Math.random() - 0.5) * 200,
                                    this.y + (Math.random() - 0.5) * 200);
                            }
                        }
                        
                        // Check for power-up
                        if (ELEMENT_POWERS[elementKey]) {
                            this.activatePower(elementKey);
                        }
                        
                        // Update discovery log
                        updateDiscoveryLog();
                    } else {
                        // Existing combination - still give points
                        const discoveryPoints = (combo.result.tier + 1) * 50;
                        this.score += discoveryPoints;
                        
                        if (this.isPlayer) {
                            createScorePopup(this.x, this.y, discoveryPoints);
                        }
                    }
                    
                    // Particles for any combination
                    createCombinationParticles(
                        this.segments[0].x, 
                        this.segments[0].y,
                        combo.result.tier
                    );
                }
                
                // Update element queue display
                if (this.isPlayer) {
                    updateElementQueue();
                }
            }
            
            activatePower(elementName) {
                const power = ELEMENT_POWERS[elementName];
                if (!power) return;
                
                this.activePower = power.type;
                this.powerTimer = power.duration;
                
                if (this.isPlayer) {
                    const indicator = document.getElementById('powerUpIndicator');
                    const powerName = power.type.replace(/_/g, ' ').toUpperCase();
                    const powerEmojis = {
                        'lava_body': 'ðŸŒ‹',
                        'speed': 'âš¡',
                        'armor': 'ðŸ›¡ï¸',
                        'ice_trail': 'â„ï¸',
                        'magnet': 'ðŸ§²'
                    };
                    const emoji = powerEmojis[power.type] || 'ðŸ”¥';
                    indicator.textContent = `${emoji} ${powerName} (${power.duration/1000}s)`;
                    indicator.style.color = power.color;
                    indicator.style.opacity = '1';
                }
            }
            
            consume(element) {
                // Add element to body
                this.elements.push(element.type);
                
                // Grow based on tier
                const elementData = elementDatabase[element.type] || { tier: 0 };
                const growthAmount = elementData.tier === 0 ? 1 : 
                                   elementData.tier <= 2 ? 2 : 
                                   elementData.tier <= 4 ? 3 : 4;
                
                this.length += growthAmount;
                
                // Remove element
                const index = elements.indexOf(element);
                if (index > -1) elements.splice(index, 1);
                
                // Update queue
                if (this.isPlayer) updateElementQueue();
            }
            
            die() {
                this.alive = false;
                
                // Drop all elements
                for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    spawnElement(this.elements[i], 
                        segment.x + (Math.random() - 0.5) * 30,
                        segment.y + (Math.random() - 0.5) * 30);
                }
                
                if (this.isPlayer) {
                    // Respawn
                    setTimeout(() => {
                        playerSnake = new Snake(
                            Math.random() * WORLD_SIZE,
                            Math.random() * WORLD_SIZE,
                            true
                        );
                        snakes.push(playerSnake);
                    }, 3000);
                }
            }
            
            draw() {
                if (!this.alive) return;
                
                // Draw segments
                for (let i = 0; i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    const screenX = segment.x - camera.x + canvas.width / 2;
                    const screenY = segment.y - camera.y + canvas.height / 2;
                    
                    // Skip if off screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    ctx.save();
                    
                    // Use snake's assigned color
                    ctx.fillStyle = i % 2 === 0 ? this.color.primary : this.color.secondary;
                    
                    // Power-up effects
                    if (this.activePower === 'lava_body') {
                        ctx.fillStyle = '#FF4500';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#FF4500';
                    } else if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                    }
                    
                    // Draw segment
                    const radius = SEGMENT_SIZE - i * 0.02;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add border
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (this.activePower === 'armor') {
                        ctx.strokeStyle = '#00BFFF';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Draw element emoji on segment (bigger and clearer)
                    if (i < this.elements.length) {
                        const elementType = this.elements[i];
                        const element = elementDatabase[elementType] || ALL_ELEMENTS[elementType];
                        if (element) {
                            ctx.save();
                            // Add slight background for better visibility
                            ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, radius * 0.8, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.font = `${radius * 1.4}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(element.emoji, screenX, screenY);
                            ctx.restore();
                        }
                    }
                }
                
                // Draw cute face on head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    const screenX = head.x - camera.x + canvas.width / 2;
                    const screenY = head.y - camera.y + canvas.height / 2;
                    
                    // Draw face
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(this.angle);
                    
                    // Face emoji
                    ctx.font = `${SEGMENT_SIZE * 1.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.color.face, 0, 0);
                    
                    ctx.restore();
                    
                    // Draw name
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                    ctx.fillText(this.name, screenX, screenY - SEGMENT_SIZE - 15);
                }
            }
        }
        
        class Element {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.data = elementDatabase[type] || BASIC_ELEMENTS[type] || { emoji: 'â“', name: type, tier: 0 };
                this.createdTime = Date.now();
                this.pulse = 0;
                
                // Size based on tier
                this.size = ELEMENT_SIZE * (1 + this.data.tier * 0.25);
                
                // Expiration for rare elements
                this.expirationTime = this.data.tier >= 3 ? 8000 : 
                                    this.data.tier >= 5 ? 5000 : null;
            }
            
            update(deltaTime) {
                this.pulse += deltaTime * 0.005;
                
                // Check expiration
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    if (age > this.expirationTime) {
                        return false; // Remove element
                    }
                }
                
                // Magnet effect for nearby players with magnet power
                if (playerSnake && playerSnake.activePower === 'magnet') {
                    const dist = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    if (dist < 200) {
                        const angle = Math.atan2(playerSnake.y - this.y, playerSnake.x - this.x);
                        this.x += Math.cos(angle) * 2;
                        this.y += Math.sin(angle) * 2;
                    }
                }
                
                return true;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off screen
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                // Glow for higher tier elements
                if (this.data.tier > 0) {
                    const glowSize = this.size * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Expiration warning
                if (this.expirationTime) {
                    const age = Date.now() - this.createdTime;
                    const timeLeft = this.expirationTime - age;
                    if (timeLeft < 3000) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, this.size * scale + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Draw emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.data.emoji, screenX, screenY);
            }
        }
        
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Random spawn logic
                const rand = Math.random();
                if (rand < 0.7) {
                    // Basic element
                    const basicKeys = Object.keys(BASIC_ELEMENTS);
                    type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                } else if (rand < 0.95) {
                    // Discovered element
                    const discovered = Array.from(discoveredElements);
                    if (discovered.length > 4) {
                        type = discovered[Math.floor(Math.random() * discovered.length)];
                    } else {
                        const basicKeys = Object.keys(BASIC_ELEMENTS);
                        type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    }
                } else {
                    // Rare element
                    const allElements = Object.keys(elementDatabase);
                    if (allElements.length > 4) {
                        type = allElements[Math.floor(Math.random() * allElements.length)];
                    } else {
                        const basicKeys = Object.keys(BASIC_ELEMENTS);
                        type = basicKeys[Math.floor(Math.random() * basicKeys.length)];
                    }
                }
            }
            
            x = x || Math.random() * WORLD_SIZE;
            y = y || Math.random() * WORLD_SIZE;
            
            elements.push(new Element(type, x, y));
        }
        
        function createCombinationParticles(x, y, tier) {
            const particleCount = 10 + tier * 5;
            const hue = (tier * 60) % 360;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                const particle = {
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color: `hsl(${hue}, 70%, 50%)`
                };
                particles.push(particle);
            }
        }
        
        function createDiscoveryParticles(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                const hue = Math.random() * 360;
                const particle = {
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.5,
                    color: `hsl(${hue}, 100%, 50%)`
                };
                particles.push(particle);
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime / 1000;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                const screenX = p.x - camera.x + canvas.width / 2;
                const screenY = p.y - camera.y + canvas.height / 2;
                
                ctx.globalAlpha = Math.max(0, p.life);
                ctx.fillStyle = p.color;
                ctx.fillRect(screenX - 2, screenY - 2, 4, 4);
            });
            ctx.globalAlpha = 1;
        }
        
        function createScorePopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            popup.style.left = screenX + 'px';
            popup.style.top = screenY + 'px';
            popup.textContent = `+${points}`;
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.remove();
            }, 1500);
        }
        
        function showAchievement(element) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.innerHTML = `
                <h3>NEW DISCOVERY!</h3>
                <div class="element-display">${element.emoji}</div>
                <div class="element-name">${element.name}</div>
                <div class="tier-info">Tier ${element.tier} Element</div>
            `;
            document.body.appendChild(achievement);
            
            setTimeout(() => {
                achievement.remove();
            }, 3000);
        }
        
        function createCombinationFlash(x, y) {
            const flash = document.createElement('div');
            flash.className = 'combination-flash';
            const rect = canvas.getBoundingClientRect();
            const screenX = x - camera.x + canvas.width / 2 + rect.left;
            const screenY = y - camera.y + canvas.height / 2 + rect.top;
            flash.style.left = screenX + 'px';
            flash.style.top = screenY + 'px';
            flash.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.remove();
            }, 500);
        }
        
        function showDiscovery(element) {
            const display = document.getElementById('recentDiscovery');
            display.textContent = `NEW DISCOVERY: ${element.emoji} ${element.name}!`;
            display.style.opacity = '1';
            
            setTimeout(() => {
                display.style.opacity = '0';
            }, 4000); // Increased from 3000
        }
        
        function updateElementQueue() {
            if (!playerSnake) return;
            
            const queue = document.getElementById('elementQueue');
            queue.innerHTML = '<span style="color: #888; margin-right: 10px; font-size: 12px;">Your Elements:</span>';
            
            // Show first 10 elements
            for (let i = 0; i < Math.min(10, playerSnake.elements.length); i++) {
                const elementType = playerSnake.elements[i];
                const element = elementDatabase[elementType];
                
                if (element) {
                    const div = document.createElement('div');
                    div.className = 'queueElement';
                    div.textContent = element.emoji;
                    
                    // Check if compatible with next element
                    if (i < playerSnake.elements.length - 1) {
                        const nextType = playerSnake.elements[i + 1];
                        const combo1 = `${elementType}+${nextType}`;
                        const combo2 = `${nextType}+${elementType}`;
                        
                        if (COMBINATIONS[combo1] || COMBINATIONS[combo2]) {
                            div.classList.add('compatible');
                        }
                    }
                    
                    queue.appendChild(div);
                }
            }
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            const discovered = Array.from(discoveredElements).sort();
            discovered.forEach(elementKey => {
                const element = elementDatabase[elementKey] || ALL_ELEMENTS[elementKey];
                if (element && element.tier > 0) {
                    const div = document.createElement('div');
                    div.className = 'discovery-item';
                    div.innerHTML = `${element.emoji} ${element.name} (Tier ${element.tier})`;
                    list.appendChild(div);
                }
            });
        }
        
        function updateLeaderboard() {
            const sortedSnakes = snakes
                .filter(s => s.alive)
                .sort((a, b) => b.score - a.score)
                .slice(0, 5);
            
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = sortedSnakes.map((snake, index) => `
                <div style="${snake.isPlayer ? 'color: #FFD700;' : ''}">
                    ${index + 1}. ${snake.name} - ${Math.floor(snake.score)}
                </div>
            `).join('');
        }
        
        function checkCollisions() {
            snakes.forEach(snake => {
                if (!snake.alive) return;
                
                // Element collisions
                elements.forEach(element => {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + element.size + 5) { // Added 5 pixel buffer
                        snake.consume(element);
                    }
                });
                
                // Snake collisions
                snakes.forEach(otherSnake => {
                    if (snake === otherSnake || !otherSnake.alive) return;
                    
                    // Check head collision with other snake's body
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        
                        if (dist < SEGMENT_SIZE) {
                            // Check for lava body power
                            if (otherSnake.activePower === 'lava_body') {
                                snake.die();
                            } else if (snake.activePower !== 'armor') {
                                snake.die();
                            }
                            return;
                        }
                    }
                });
            });
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function updateCamera() {
            if (playerSnake && playerSnake.alive) {
                camera.x = playerSnake.x;
                camera.y = playerSnake.y;
            }
        }
        
        let elementSpawnTimer = 0;
        let lastTime = 0;
        
        function gameLoop(currentTime) {
            if (!gameStarted) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            const deltaTime = Math.min(currentTime - lastTime, 100);
            lastTime = currentTime;
            
            if (!paused) {
                // Element spawning - faster rate
                elementSpawnTimer += deltaTime;
                if (elementSpawnTimer > 1000) { // Spawn every second instead of 2
                    elementSpawnTimer = 0;
                    // Spawn 2-3 elements at once
                    const spawnCount = 2 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < spawnCount; i++) {
                        spawnElement();
                    }
                }
                
                // Maintain minimum elements on board
                if (elements.length < 50) { // Increased from 40 to 50
                    spawnElement();
                }
                
                // Update elements
                for (let i = elements.length - 1; i >= 0; i--) {
                    if (!elements[i].update(deltaTime)) {
                        elements.splice(i, 1);
                    }
                }
                
                // Update snakes
                snakes.forEach(snake => snake.update(deltaTime));
                
                // Update particles
                updateParticles(deltaTime);
                
                // Collisions
                checkCollisions();
                
                // Camera
                updateCamera();
                
                // Remove dead AI snakes
                snakes.forEach((snake, index) => {
                    if (!snake.alive && !snake.isPlayer) {
                        const idx = snakes.indexOf(snake);
                        if (idx > -1) snakes.splice(idx, 1);
                    }
                });
                
                // Spawn AI if needed
                const aliveAI = snakes.filter(s => !s.isPlayer && s.alive).length;
                if (aliveAI < 8) { // Increased from 5 to 8 for more activity
                    const aiSnake = new Snake(
                        Math.random() * WORLD_SIZE,
                        Math.random() * WORLD_SIZE,
                        false
                    );
                    snakes.push(aiSnake);
                }
                
                // Check victory
                if (gameMode > 0 && playerSnake && playerSnake.discoveries >= targetDiscoveries) {
                    alert(`ðŸŽ‰ VICTORY! ðŸŽ‰\n\nYou've mastered the elements and discovered ${targetDiscoveries} combinations!\n\nFinal Score: ${Math.floor(playerSnake.score)}`);
                    location.reload();
                }
            }
            
            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            
            // Draw elements
            elements.forEach(element => element.draw());
            
            // Draw snakes
            snakes.forEach(snake => snake.draw());
            
            // Draw particles
            drawParticles();
            
            // Update UI
            updateLeaderboard();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
                
                if (e.key === 'p' || e.key === 'P') {
                    paused = !paused;
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        });
        
        // Start game
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        function startGame(mode) {
            gameMode = mode;
            targetDiscoveries = mode;
            gameStarted = true;
            
            document.getElementById('gameModeSelect').style.display = 'none';
            
            // Initialize player
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            playerSnake.angle = -Math.PI / 2; // Face upward
            snakes.push(playerSnake);
            
            // Initialize AI snakes
            for (let i = 0; i < 8; i++) {
                const aiSnake = new Snake(
                    Math.random() * WORLD_SIZE,
                    Math.random() * WORLD_SIZE,
                    false
                );
                snakes.push(aiSnake);
            }
            
            // Initial elements - more for less sparse board
            for (let i = 0; i < 60; i++) {
                spawnElement();
            }
            
            updateDiscoveryLog();
            updateElementQueue();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth - 40;
            canvas.height = window.innerHeight - 40;
        });
        
        // Load combination data from JSON files
        async function loadCombinationData() {
            const files = [
                'Element Files/Infinite Craft Part 1.json',
                'Element Files/Infinite Craft Part 2.json',
                'Element Files/Infinite Craft Part 3.json',
                'Element Files/Infinite Craft Part 4.json',
                'Element Files/infinite-craft-part5.json',
                'Element Files/infinite-craft-part6.json',
                'Element Files/infinite-craft-part7.json',
                'Element Files/infinite-craft-part8.json',
                'Element Files/infinite-craft-part9.json',
                'Element Files/infinite-craft-part10.json',
                'Element Files/infinite-craft-part11.json'
            ];
            
            try {
                for (const file of files) {
                    try {
                        const response = await fetch(file);
                        if (!response.ok) {
                            console.warn(`Failed to load ${file}:`, response.statusText);
                            continue;
                        }
                        const data = await response.json();
                    
                    // Process combinations from each file
                    if (data.combinations) {
                        // Handle different sections of combinations
                        for (const section of Object.values(data.combinations)) {
                            for (const [combo, result] of Object.entries(section)) {
                                const [elem1, elem2] = combo.split(' + ');
                                if (!elem1 || !elem2) continue;
                                
                                const key1 = `${elem1.toLowerCase()}+${elem2.toLowerCase()}`;
                                const key2 = `${elem2.toLowerCase()}+${elem1.toLowerCase()}`;
                                
                                // Parse result format "emoji|name"
                                let emoji, name;
                                if (typeof result === 'string') {
                                    [emoji, name] = result.split('|');
                                } else if (result.emoji && result.name) {
                                    emoji = result.emoji;
                                    name = result.name;
                                }
                                
                                if (emoji && name) {
                                    const tier = determineTier(name);
                                    const elementData = { emoji, name, tier };
                                    
                                    COMBINATIONS[key1] = elementData;
                                    COMBINATIONS[key2] = elementData;
                                    ALL_ELEMENTS[name.toLowerCase()] = elementData;
                                    totalCombinations++;
                                }
                            }
                        }
                    }
                    } catch (fileError) {
                        console.warn(`Error processing ${file}:`, fileError);
                    }
                }
                
                // Update element database
                elementDatabase = { ...BASIC_ELEMENTS, ...ALL_ELEMENTS };
                console.log(`Loaded ${totalCombinations} combinations!`);
                return true;
            } catch (error) {
                console.error('Error loading combinations:', error);
                // Use fallback combinations
                Object.values(FALLBACK_COMBINATIONS).forEach(combo => {
                    ALL_ELEMENTS[combo.name.toLowerCase()] = combo;
                });
                elementDatabase = { ...BASIC_ELEMENTS, ...ALL_ELEMENTS };
                return false;
            }
        }
        
        function determineTier(name) {
            // Tier determination based on complexity
            const lowerName = name.toLowerCase();
            
            // Tier 5 - Legendary/Mythical
            if (lowerName.includes('god') || lowerName.includes('universe') || 
                lowerName.includes('infinity') || lowerName.includes('dragon') ||
                lowerName.includes('phoenix') || lowerName.includes('titan')) {
                return 5;
            }
            // Tier 4 - Magical/Powerful
            if (lowerName.includes('magic') || lowerName.includes('wizard') ||
                lowerName.includes('galaxy') || lowerName.includes('star') ||
                lowerName.includes('demon') || lowerName.includes('angel')) {
                return 4;
            }
            // Tier 3 - Complex/Advanced
            if (lowerName.includes('city') || lowerName.includes('civilization') ||
                lowerName.includes('technology') || lowerName.includes('computer') ||
                lowerName.includes('robot') || lowerName.includes('spaceship')) {
                return 3;
            }
            // Tier 2 - Moderate complexity
            if (lowerName.includes('tool') || lowerName.includes('machine') ||
                lowerName.includes('building') || lowerName.includes('animal') ||
                lowerName.includes('plant') || lowerName.includes('metal')) {
                return 2;
            }
            // Tier 1 - Basic combinations
            return 1;
        }
        
        // Initialize game
        async function initGame() {
            console.log('Initializing game...');
            try {
                await loadCombinationData();
            } catch (error) {
                console.error('Failed to load combinations, using fallback:', error);
            }
            
            // Update total discoveries display
            const totalPossible = Object.keys(ALL_ELEMENTS).length || Object.keys(FALLBACK_COMBINATIONS).length;
            if (totalPossible > 0) {
                document.getElementById('discoveries').textContent = `Discoveries: 0 / ${totalPossible}`;
            }
            
            console.log('Starting game loop...');
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        
        initGame();
    </script>
</body>
</html>