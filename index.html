<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Infinite Snake - Craft the Cosmos | Free Element Crafting Snake Game</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" id="Viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta property="og:description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta name="keywords" content="infinite snake, snake game, element crafting, craft game, single player snake, browser game, free game, online snake, element combinations, discovery game, alchemy game, snake.io, slither.io, google snake, infinite craft snake, crafting game" />
    
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Infinite Snake - Craft the Cosmos" />
    <meta property="og:site_name" content="Infinite Snake" />
    <meta property="og:image" content="https://infinitesnake.io/assets/snake-logo.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="A snake game where you craft elements and rebuild the cosmos" />
    <meta property="og:locale" content="en_US" />
    
    <meta name="twitter:title" content="Infinite Snake - Craft the Cosmos" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="Combine elements, grow your snake, and discover endless combinations in this unique twist on the classic snake game. Free to play in your browser and mobile!">
    <meta name="twitter:image" content="https://infinitesnake.io/assets/snake-logo.png">
    
    <meta name='robots' content='index,follow' />
    <meta name="twitter:url" content="https://infinitesnake.io" />
    <meta property="og:url" content="https://infinitesnake.io" />
    <meta name="url" content="https://infinitesnake.io" />
    <link rel="canonical" href="https://infinitesnake.io">
    
    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org/",
        "@type": "Game",
        "image": "https://infinitesnake.io/assets/snake-logo.png",
        "name": "Infinite Snake",
        "url": "https://infinitesnake.io",
        "description": "A unique snake game featuring element crafting mechanics. Combine fire, water, earth, and air to discover endless elements while growing your snake and rebuilding the cosmos.",
        "genre": "Arcade, Puzzle, Strategy, Casual",
        "gamePlatform": ["Web Browser", "Mobile Web"],
        "operatingSystem": "Any",
        "applicationCategory": "Game",
        "inLanguage": "en",
        "author": {
            "@type": "Person",
            "name": "Jason Bartz"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.6",
            "bestRating": "5",
            "ratingCount": "2847"
        }
    }
    </script>
    
    <!-- FAQ Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [{
                "@type": "Question",
                "name": "What is Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake is a free browser game that combines classic snake gameplay with element crafting mechanics. Collect elements, combine them to discover new ones, and grow your snake while rebuilding the cosmos."
                }
            },
            {
                "@type": "Question",
                "name": "How do I play Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use your mouse, arrow keys, or WASD to control your snake on desktop, or touch controls on mobile. Collect elemental orbs and combine them in your snake's body to discover new elements. Avoid collisions with other snakes and borders while growing larger."
                }
            },
            {
                "@type": "Question",
                "name": "Is Infinite Snake free to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is completely free to play in your web browser on both desktop and mobile. No download or installation required - just visit infinitesnake.io and start playing instantly."
                }
            },
            {
                "@type": "Question",
                "name": "How many elements can I discover in Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "There are hundreds of unique elements to discover through combinations, ranging from basic elements like fire and water to complex creations like dragons, technology, and cosmic entities. New combinations are added regularly!"
                }
            },
            {
                "@type": "Question",
                "name": "Can I play Infinite Snake on mobile?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is fully optimized for mobile devices with intuitive touch controls. Simply visit infinitesnake.io on your mobile browser to play."
                }
            },
            {
                "@type": "Question",
                "name": "What makes Infinite Snake different from other snake games?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake uniquely combines snake gameplay with element crafting mechanics inspired by games like Little Alchemy and Infinite Craft. As you consume elements, they combine in your snake's body to create new discoveries, adding a strategic puzzle element to the classic snake formula."
                }
            },
            {
                "@type": "Question",
                "name": "Do I need to create an account to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "No account required! Your discoveries and progress are saved locally in your browser, allowing you to jump in and play immediately without any registration."
                }
            },
            {
                "@type": "Question",
                "name": "What are the controls for Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "On desktop, use your mouse to guide your snake - it will follow your cursor. Click and hold to boost. On mobile devices, use the virtual joystick to direct your snake and the boost button to speed up. Press P to pause the game at any time on desktop."
                }
            }
        ]
    }
    </script>
    
    <!-- Additional SEO -->
    <meta name="author" content="Jason Bartz">
    <meta name="theme-color" content="#4ecdc4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Mobile optimization tags -->
    <meta name="HandheldFriendly" content="true">
    <meta name="format-detection" content="telephone=no">
    <meta name="screen-orientation" content="landscape">
    
    <!-- Alternate language versions -->
    <link rel="alternate" hreflang="en" href="https://infinitesnake.io" />
    <link rel="alternate" hreflang="x-default" href="https://infinitesnake.io" />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/skin-selection.css">
    <link rel="stylesheet" href="css/unlock-notifications.css">
    <link rel="stylesheet" href="css/discovery-feed-gradients.css">
    <style>
        /* SNES-Era UI Theme with Cosmic Colors */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        /* Global pixel art style */
        * {
            box-shadow: none !important;
            text-shadow: none !important;
            border-radius: 0 !important;
            transition-duration: 0s !important;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: unset;
        }
        
        /* SNES Color Palette - Cosmic Theme */
        :root {
            --snes-primary-blue: #2038EC;
            --snes-dark-blue: #000080;
            --snes-light-blue: #5878F8;
            --snes-cosmic-purple: #7828F8;
            --snes-cosmic-pink: #F828F8;
            --snes-gold: #F8D800;
            --snes-red: #F83800;
            --snes-green: #00E800;
            --snes-white: #F8F8F8;
            --snes-black: #000000;
            --snes-gray: #A8A8A8;
            --snes-dark-purple: #4800A8;
            --snes-cosmic-teal: #00F8F8;
            
            /* Gradient control variables */
            --discovery-gradient-start: rgba(0, 0, 0, 0.8);
            --discovery-gradient-mid: rgba(0, 0, 0, 0.6);
            --discovery-gradient-end: rgba(0, 0, 0, 0);
            --discovery-blur-amount: 8px;
            --discovery-message-opacity: 0.95;
            
            /* Mobile UI Positioning Variables */
            --mobile-scorecard-top: 10px;
            --mobile-scorecard-left: 10px;
            --mobile-scorecard-bottom: unset;
            --mobile-scorecard-right: auto;
            
            --mobile-leaderboard-top: 10px;
            --mobile-leaderboard-right: 10px;
            --mobile-leaderboard-bottom: unset;
            --mobile-leaderboard-left: auto;
            
            --mobile-discovery-opacity: 0.7;
            --mobile-discovery-scale: 0.8;
            
            --mobile-joystick-opacity: 0.3;
            --mobile-boost-opacity: 0.7;
            
            --mobile-boost-bar-height: 20px;
            --mobile-landscape-ui-spacing: 15px;
        }
        
        body {
            margin: 0;
            padding: 0;
            background-color: #000011;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            color: var(--snes-white);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            font-size: 8px;
            line-height: 1.5;
        }
        
        /* Optional CRT Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: multiply;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.8s ease-in;
        }
        
        /* Splash Screen - SNES Style */
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--snes-black);
            overflow: hidden;
            z-index: 1000;
            transition: opacity 0.3s;
        }
        
        /* Removed - using persistent star canvas
        #splashStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        } */
        
        #splashContent {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #splashScreen img {
            animation: float 3s steps(4) infinite;
            image-rendering: pixelated;
            filter: drop-shadow(4px 4px 0 rgba(0,0,0,0.8));
        }
        
        /* Mobile splash logo sizing */
        @media (max-width: 800px) {
            #splashLogo {
                width: 250px !important;
                max-width: 70% !important;
            }
        }
        
        /* Landscape splash logo sizing */
        @media (orientation: landscape) {
            #splashLogo {
                width: 150px !important;
                max-width: 40% !important;
                margin-bottom: 10px !important;
            }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            25% { transform: translateY(-4px); }
            50% { transform: translateY(-8px); }
            75% { transform: translateY(-4px); }
        }
        
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 10px;
            line-height: 2;
            color: var(--snes-cosmic-teal);
            margin: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #startButton {
            margin-top: 30px;
            padding: 16px 32px;
            font-size: 12px;
            background: var(--snes-cosmic-purple);
            border: 4px solid var(--snes-white);
            border-radius: 0;
            box-shadow: 
                inset 2px 2px 0 var(--snes-cosmic-pink),
                inset -2px -2px 0 var(--snes-dark-purple),
                4px 4px 0 rgba(0,0,0,0.5);
            text-transform: uppercase;
            font-family: 'Press Start 2P';
            color: var(--snes-white);
            cursor: pointer;
            transition: none;
            letter-spacing: 1px;
        }
        
        #startButton:hover {
            background: var(--snes-cosmic-pink);
            transform: translate(2px, 2px);
            box-shadow: 
                inset 2px 2px 0 #FFA8FF,
                inset -2px -2px 0 var(--snes-dark-purple),
                2px 2px 0 rgba(0,0,0,0.5);
        }
        
        #startButton:active {
            transform: translate(4px, 4px);
            box-shadow: none;
        }
        
        #splashTitle {
            font-size: 48px;
            margin-bottom: 30px;
            background: none;
            color: var(--snes-gold);
            text-shadow: 
                2px 2px 0 var(--snes-cosmic-purple),
                4px 4px 0 var(--snes-black);
            letter-spacing: 2px;
            text-transform: uppercase;
            display: none;
        }
        
        /* Game Mode Selection - SNES Style */
        #gameModeSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--snes-black);
            overflow: hidden;
            display: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        /* Removed - using persistent star canvas
        #gameModeStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        } */
        
        #gameModeContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--snes-dark-blue);
            padding: 32px;
            border-radius: 0;
            text-align: center;
            border: 8px solid;
            border-color: var(--snes-white) var(--snes-black) var(--snes-black) var(--snes-white);
            max-width: 800px;
            width: 90%;
            z-index: 1;
            position: relative;
            box-shadow: 8px 8px 0 rgba(0,0,0,0.8);
        }
        
        /* Decorative corners */
        #gameModeContent::before,
        #gameModeContent::after {
            content: '◆';
            position: absolute;
            color: var(--snes-gold);
            font-size: 16px;
        }
        
        #gameModeContent::before {
            top: 8px;
            left: 8px;
        }
        
        #gameModeContent::after {
            bottom: 8px;
            right: 8px;
        }
        
        #gameModeSelect h3 {
            color: var(--snes-gold);
            font-size: 16px;
            margin-bottom: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 var(--snes-black);
        }
        
        .modeSection {
            margin-bottom: 30px;
        }
        
        .modeSection h4 {
            color: var(--snes-cosmic-teal);
            font-size: 10px;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 0 var(--snes-black);
        }
        
        #gameModeSelect button {
            margin: 4px;
            padding: 12px 24px;
            background: var(--snes-primary-blue);
            border: 4px solid;
            border-color: var(--snes-light-blue) var(--snes-black) var(--snes-black) var(--snes-light-blue);
            color: var(--snes-white);
            border-radius: 0;
            cursor: pointer;
            transition: none;
            font-size: 10px;
            min-width: 180px;
            font-family: 'Press Start 2P';
            text-transform: uppercase;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
        }
        
        #gameModeSelect button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        
        #gameModeSelect button:active {
            transform: translate(4px, 4px);
            box-shadow: none;
        }
        
        /* Victory Mode Layout */
        #victoryButtons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .victory-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .victory-column h5 {
            color: var(--snes-gold);
            margin: 0 0 12px 0;
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 0 var(--snes-black);
        }
        
        .victory-infinite {
            grid-column: span 2;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        /* Discovery Mode Buttons - SNES Green */
        .btn-discovery {
            background: #00A800 !important;
            border: 4px solid !important;
            border-color: var(--snes-green) #005800 #005800 var(--snes-green) !important;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5) !important;
        }
        
        .btn-discovery:hover {
            background: var(--snes-green) !important;
        }
        
        /* Points Mode Buttons - SNES Red */
        .btn-points {
            background: var(--snes-red) !important;
            border: 4px solid !important;
            border-color: #F86830 #A80000 #A80000 #F86830 !important;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5) !important;
        }
        
        .btn-points:hover {
            background: #F86830 !important;
        }
        
        /* Infinite Mode Button - SNES Purple/Cosmic */
        .btn-infinite {
            background: var(--snes-cosmic-purple) !important;
            border: 4px solid !important;
            border-color: #A858F8 var(--snes-dark-purple) var(--snes-dark-purple) #A858F8 !important;
            min-width: 250px !important;
            font-size: 12px !important;
            padding: 16px 32px !important;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5) !important;
        }
        
        .btn-infinite:hover {
            background: var(--snes-cosmic-pink) !important;
        }
        
        /* Leaderboard Button - SNES Teal */
        .btn-leaderboard {
            background: var(--snes-cosmic-teal) !important;
            border-color: #58F8F8 #008888 #008888 #58F8F8 !important;
            color: var(--snes-black) !important;
            border: 2px solid #2196F3 !important;
            min-width: 250px !important;
            font-size: 16px !important;
            padding: 12px 25px !important;
            color: white;
            cursor: pointer;
            font-family: monospace;
            transition: all 0.3s;
        }
        
        .btn-leaderboard:hover {
            background: linear-gradient(135deg, #1E88E5, #1565C0) !important;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.6);
            transform: scale(1.05);
        }
        
        #loadingIndicator {
            display: none;
            margin: 10px 0;
            color: #FFD700;
            font-size: 14px;
        }
        
        /* Canvas */
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Discovery Sidebar - Hidden (using discovery feed instead) */
        #discoveryLog {
            display: none;
        }
        
        #discoveryLog h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #FFD700;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .discovery-item {
            margin: 8px 0;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .discovery-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        
        .discovery-item .emoji {
            font-size: 24px;
        }
        
        .discovery-item .info {
            flex: 1;
        }
        
        .discovery-item .name {
            font-weight: bold;
            color: white;
        }
        
        .discovery-item .tier {
            font-size: 11px;
            color: #AAA;
        }
        
        .discovery-item.new {
            animation: newItemGlow 2s ease-out;
            background: rgba(255, 215, 0, 0.2);
        }
        
        @keyframes newItemGlow {
            0% {
                background: rgba(255, 215, 0, 0.5);
                transform: translateX(10px);
            }
            100% {
                background: rgba(255, 215, 0, 0.2);
                transform: translateX(0);
            }
        }
        
        /* Main UI overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in;
        }
        
        #score {
            display: none; /* Hidden - score shown in leaderboard */
        }
        
        #discoveries {
            display: none; /* Hidden - discoveries shown elsewhere */
        }
        
        /* Bottom UI Bar (MMO-style) */
        .bottom-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: auto;
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.7) 10%,
                rgba(10, 10, 26, 0.95) 30%,
                rgba(10, 10, 26, 0.98) 100%
            );
            padding-top: 20px;
            border-top: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 -10px 30px rgba(138, 43, 226, 0.2);
        }
        
        /* Element Collection Bar (Skill Bar Style) - SNES Style */
        .element-collection-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
            margin-bottom: 10px;
            gap: 4px;
            image-rendering: pixelated;
        }
        
        .element-slot {
            width: 64px;
            height: 64px;
            background: #1a1a2e;
            border: 3px solid;
            border-color: #4a4a6e #0a0a1e #0a0a1e #4a4a6e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            border-radius: 0;
            image-rendering: pixelated;
            padding: 2px;
        }
        
        .element-slot.empty {
            background: #0f0f1f;
            border-style: solid;
            border-color: #2a2a3a #050510 #050510 #2a2a3a;
            opacity: 0.6;
        }
        
        .element-slot.filled {
            background: #2a2a4e;
            border-color: #5a5a8e #1a1a2e #1a1a2e #5a5a8e;
        }
        
        .element-slot.tail-element {
            border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold);
            background: #383800;
            animation: pixelPulse 1s steps(2) infinite;
        }
        
        @keyframes pixelPulse {
            0%, 100% { 
                background: #383800;
                box-shadow: inset 0 0 0 2px var(--snes-gold);
            }
            50% { 
                background: #585800;
                box-shadow: inset 0 0 0 4px var(--snes-gold);
            }
        }
        
        /* Combination animation styles */
        @keyframes combinationGlow {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                           inset 0 0 10px rgba(255, 215, 0, 0.2);
            }
            25% {
                transform: scale(1.1);
                box-shadow: 0 0 30px rgba(255, 100, 255, 0.8),
                           inset 0 0 20px rgba(255, 100, 255, 0.4);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 40px rgba(100, 200, 255, 1),
                           inset 0 0 30px rgba(100, 200, 255, 0.6);
            }
            75% {
                transform: scale(1.1);
                box-shadow: 0 0 30px rgba(255, 100, 255, 0.8),
                           inset 0 0 20px rgba(255, 100, 255, 0.4);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                           inset 0 0 10px rgba(255, 215, 0, 0.2);
            }
        }
        
        .element-slot.combining {
            animation: combinationGlow 0.6s ease-in-out;
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 100, 255, 0.3) 0%,
                rgba(100, 200, 255, 0.2) 100%
            );
        }
        
        @keyframes elementMerge {
            0% {
                opacity: 1;
                transform: scale(1) translateX(0);
            }
            50% {
                opacity: 0.8;
                transform: scale(0.8) translateX(-10px);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translateX(-20px);
            }
        }
        
        .element-slot.merging {
            animation: elementMerge 0.5s ease-out forwards;
        }
        
        @keyframes newElementAppear {
            0% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(360deg);
            }
        }
        
        .element-slot.new-element {
            animation: newElementAppear 0.6s ease-out;
        }
        
        /* Particle effect container */
        .combination-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Screen flash effect for combinations */
        @keyframes combinationFlash {
            0% {
                opacity: 0;
            }
            20% {
                opacity: 0.3;
            }
            100% {
                opacity: 0;
            }
        }
        
        .combination-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 215, 0, 0.2), rgba(100, 200, 255, 0.1));
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            animation: combinationFlash 0.5s ease-out;
        }
        
        @keyframes particleFly {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(calc(-50% + var(--tx) * 2), calc(-50% + var(--ty) * 2)) scale(0.5);
            }
        }
        
        .combination-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(255, 215, 0, 1) 0%, rgba(255, 100, 255, 0) 70%);
            border-radius: 50%;
            animation: particleFly 0.6s ease-out forwards;
        }
        
        .element-slot.highlighted-element {
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                       inset 0 0 10px rgba(255, 215, 0, 0.2);
            animation: tailPulse 2s ease-in-out infinite;
        }
        
        .element-slot:hover:not(.empty) {
            transform: translate(1px, 1px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        
        /* New glow and wobble animations for element combinations */
        @keyframes elementGlow {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.6),
                           0 0 20px rgba(255, 100, 255, 0.4),
                           inset 0 0 10px rgba(255, 215, 0, 0.3);
            }
            50% { 
                box-shadow: 0 0 20px rgba(255, 215, 0, 1),
                           0 0 40px rgba(255, 100, 255, 0.8),
                           inset 0 0 20px rgba(255, 215, 0, 0.5);
            }
        }
        
        @keyframes elementWobble {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-3deg) scale(1.05); }
            75% { transform: rotate(3deg) scale(1.05); }
        }
        
        .element-slot.glow-wobble {
            animation: elementGlow 1s ease-in-out infinite,
                      elementWobble 0.8s ease-in-out infinite;
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.3) 0%,
                rgba(255, 100, 255, 0.2) 100%
            );
        }
        
        /* Enhanced combining animation */
        .element-slot.combining-enhanced {
            animation: elementGlow 0.6s ease-in-out,
                      elementWobble 0.4s ease-in-out;
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 100, 255, 0.4) 0%,
                rgba(100, 200, 255, 0.3) 100%
            );
        }
        
        .element-slot .emoji {
            font-size: 32px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
            margin-bottom: 2px;
        }
        
        .element-slot .element-name {
            font-size: 7px;
            color: var(--snes-white);
            text-align: center;
            font-family: 'Press Start 2P';
            line-height: 1.1;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.8);
            letter-spacing: -0.5px;
            word-wrap: break-word;
            width: 100%;
            padding: 0 2px;
            margin-top: 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Boost Bar (Mana Bar Style) */
        .boost-bar-container {
            width: 60%;
            max-width: 800px;
            margin: 0 auto 15px;
            padding: 0 20px;
        }
        
        .boost-bar-frame {
            height: 24px;
            background: #1a1a1a;
            border: 2px solid #333;
            position: relative;
            overflow: hidden;
        }
        
        .boost-bar-fill {
            height: 100%;
            background: #00a8ff;
            position: relative;
        }
        
        @keyframes boostShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .boost-bar-fill.low {
            background: #ff4444;
        }
        
        .boost-bar-fill.boosting {
            background: #44ff44;
        }
        
        .boost-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            color: white;
        }
        
        #elementQueue {
            display: none; /* Hidden - replaced by bottom element bar */
        }
        
        .element-square {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            padding: 2px;
        }
        
        .element-square .element-name {
            font-size: 7px;
            color: #AAA;
            text-align: center;
            margin-top: 2px;
            line-height: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 46px;
        }
        
        .element-square.empty {
            background: rgba(255,255,255,0.05);
            border: 1px dashed rgba(255,255,255,0.1);
        }
        
        .element-square.filled {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .element-square.tail-element {
            border: 2px solid #FFD700;
            background: rgba(255,215,0,0.1);
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
            animation: tailGlow 2s ease-in-out infinite;
        }
        
        @keyframes tailGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255,215,0,0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(255,215,0,0.8);
            }
        }
        
        .element-square:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        /* Message Popups (Over Element Bar) - SNES Style */
        #recentDiscovery {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.95); /* Dark purple background for discoveries */
            color: var(--snes-cosmic-teal);
            font-size: 12px;
            font-weight: normal;
            text-shadow: none;
            padding: 16px 32px;
            border-radius: 0;
            border: 4px solid var(--snes-cosmic-teal);
            border-color: var(--snes-cosmic-teal) #0090A0 #0090A0 var(--snes-cosmic-teal);
            text-align: center;
            pointer-events: none;
            box-shadow: 6px 6px 0 rgba(0,0,0,0.8);
            opacity: 0;
            transition: none;
            animation: none;
            z-index: 25;
            font-family: 'Press Start 2P';
            text-transform: uppercase;
            outline: 2px solid var(--snes-white);
            outline-offset: -6px;
        }
        
        #recentDiscovery.show {
            animation: popupBounce 0.3s steps(4);
        }
        
        /* Mobile popup adjustments */
        body.mobile #recentDiscovery {
            bottom: 80px;
            font-size: 10px;
            padding: 12px 20px;
            max-width: 80%;
        }
        
        @keyframes popupBounce {
            0% {
                transform: translateX(-50%) translateY(20px);
                opacity: 0;
            }
            25% {
                transform: translateX(-50%) translateY(15px);
                opacity: 0.5;
            }
            50% {
                transform: translateX(-50%) translateY(10px);
                opacity: 0.75;
            }
            75% {
                transform: translateX(-50%) translateY(5px);
                opacity: 0.9;
            }
            100% {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        #recentDiscovery.combo {
            background: rgba(0, 0, 0, 0.95);
            color: var(--snes-gold);
            border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold);
            animation: comboFlash 0.2s steps(2) 3;
            outline-color: var(--snes-gold);
        }
        
        @keyframes comboFlash {
            0%, 100% { 
                border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold);
                color: var(--snes-gold);
            }
            50% { 
                border-color: var(--snes-white) var(--snes-gray) var(--snes-gray) var(--snes-white);
                color: var(--snes-white);
            }
        }
        
        #recentDiscovery small {
            display: block;
            margin-top: 8px;
            font-size: 16px;
            font-weight: normal;
            font-style: normal;
            opacity: 1;
            letter-spacing: 0;
            filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.8));
        }
        
        /* Additional message styles */
        #recentDiscovery.gold {
            background: rgba(40, 40, 0, 0.95);
            color: var(--snes-gold);
            border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold);
            outline-color: var(--snes-gold);
        }
        
        #recentDiscovery.red {
            background: rgba(40, 0, 0, 0.95);
            color: var(--snes-red);
            border-color: var(--snes-red) #A80000 #A80000 var(--snes-red);
            outline-color: var(--snes-red);
        }
        
        #recentDiscovery.cyan {
            background: rgba(0, 40, 40, 0.95);
            color: var(--snes-cosmic-teal);
            border-color: var(--snes-cosmic-teal) #008888 #008888 var(--snes-cosmic-teal);
            outline-color: var(--snes-cosmic-teal);
        }
        
        #recentDiscovery.purple {
            background: rgba(40, 0, 40, 0.95);
            color: var(--snes-cosmic-purple);
            border-color: var(--snes-cosmic-purple) var(--snes-dark-purple) var(--snes-dark-purple) var(--snes-cosmic-purple);
            outline-color: var(--snes-cosmic-purple);
        }
        
        #recentDiscovery.orange {
            background: rgba(40, 20, 0, 0.95);
            color: #ff8c00;
            border-color: #ff8c00 #cc6600 #cc6600 #ff8c00;
            outline-color: #ff8c00;
        }
        
        /* Boss Victory Message - Epic announcement */
        #bossVictoryMessage {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 0, 30, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: var(--snes-gold);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.8);
            padding: 24px 48px;
            border-radius: 0;
            border: 6px solid var(--snes-gold);
            border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold);
            text-align: center;
            pointer-events: none;
            box-shadow: 8px 8px 0 rgba(0,0,0,0.9), 
                        0 0 30px rgba(255, 215, 0, 0.3),
                        inset 0 0 20px rgba(255, 215, 0, 0.1);
            opacity: 0;
            transition: none;
            animation: none;
            z-index: 30;
            min-width: 400px;
            display: none;
        }
        
        #bossVictoryMessage.show {
            display: block;
            opacity: 1;
            animation: epicBossVictory 0.8s steps(12);
        }
        
        #bossVictoryMessage h2 {
            margin: 0 0 16px 0;
            font-size: 24px;
            color: var(--snes-gold);
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: victoryPulse 1s steps(2) infinite;
        }
        
        #bossVictoryMessage .boss-name {
            font-size: 18px;
            color: var(--snes-white);
            margin-bottom: 12px;
        }
        
        #bossVictoryMessage .defeat-text {
            font-size: 14px;
            color: var(--snes-cosmic-teal);
            margin-bottom: 20px;
            font-style: italic;
        }
        
        #bossVictoryMessage .rewards {
            border-top: 2px solid var(--snes-gold);
            padding-top: 16px;
            margin-top: 16px;
        }
        
        #bossVictoryMessage .reward-item {
            font-size: 13px;
            color: var(--snes-white);
            margin: 8px 0;
            text-align: left;
            padding-left: 20px;
        }
        
        #bossVictoryMessage .reward-item.highlight {
            color: var(--snes-gold);
            font-size: 14px;
        }
        
        @keyframes epicBossVictory {
            0% {
                transform: translateX(-50%) scale(0.1);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) scale(1.1);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes victoryPulse {
            0%, 50% {
                transform: scale(1);
            }
            51%, 100% {
                transform: scale(1.05);
            }
        }
        
        /* Mobile responsive for boss victory */
        @media screen and (max-width: 600px) {
            #bossVictoryMessage {
                min-width: 300px;
                padding: 16px 24px;
                font-size: 12px;
            }
            
            #bossVictoryMessage h2 {
                font-size: 18px;
            }
            
            #bossVictoryMessage .boss-name {
                font-size: 14px;
            }
            
            #bossVictoryMessage .reward-item {
                font-size: 11px;
            }
        }
        
        /* Player Info Box (Bottom Left for Desktop, Top for Mobile) - SNES Style */
        .player-info-box {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 240px;
            background: var(--snes-dark-blue);
            border: 4px solid;
            border-color: var(--snes-light-blue) var(--snes-black) var(--snes-black) var(--snes-light-blue);
            border-radius: 0;
            padding: 8px;
            pointer-events: auto;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
            font-family: 'Press Start 2P';
            font-size: 7px;
        }
        
        .player-info-header {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .player-portrait {
            width: 48px;
            height: 48px;
            background: var(--snes-black);
            border: 2px solid var(--snes-gold);
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: inset 2px 2px 0 #585800;
        }
        
        .player-portrait img {
            width: 44px;
            height: 44px;
            image-rendering: pixelated;
        }
        
        .player-stats {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
            margin-left: 8px;
            overflow: hidden;
        }
        
        .stat-line {
            display: flex;
            justify-content: space-between;
            font-size: 7px;
            margin: 2px 0;
        }
        
        .stat-label {
            color: var(--snes-gray);
            text-transform: uppercase;
            letter-spacing: 0;
            font-size: 7px;
        }
        
        .stat-value {
            color: var(--snes-gold);
            font-weight: normal;
            text-shadow: 1px 1px 0 var(--snes-black);
            font-size: 7px;
        }
        
        /* Leaderboard (Bottom Right for Desktop, Top for Mobile) - SNES Style */
        .leaderboard-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            background: var(--snes-black);
            border: 4px solid;
            border-color: var(--snes-white) #505050 #505050 var(--snes-white);
            border-radius: 0;
            padding: 0;
            pointer-events: auto;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
        }
        
        .leaderboard-header {
            background: var(--snes-primary-blue);
            color: var(--snes-white);
            text-transform: uppercase;
            font-size: 12px;
            padding: 8px;
            text-align: center;
            border-bottom: 2px solid var(--snes-black);
            font-family: 'Press Start 2P';
            letter-spacing: 0;
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 10px;
            margin: 0;
            background: #181850;
            border-bottom: 1px solid var(--snes-black);
            font-size: 10px;
            transition: none;
            font-family: 'Press Start 2P';
            line-height: 1.4;
        }
        
        .leaderboard-entry:hover {
            background: #282890;
            transform: none;
        }
        
        .leaderboard-entry.leader {
            background: #383800;
            border-left: 4px solid var(--snes-gold);
            color: var(--snes-gold);
        }
        
        .leaderboard-entry.player {
            background: #003838;
            border-left: 4px solid var(--snes-cosmic-teal);
            color: var(--snes-cosmic-teal);
        }
        
        .leaderboard-name {
            flex: 1;
            font-weight: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 8px;
        }
        
        .leaderboard-stats {
            text-align: right;
            font-size: 9px;
            color: var(--snes-gray);
            line-height: 1.4;
        }
        
        /* Discovery Feed (Left Side Chat-style) - SNES Style */
        .discovery-feed {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 300px;
            max-height: 30vh;
            pointer-events: none;
            display: flex !important;
            flex-direction: column;
            justify-content: flex-end;
            overflow: hidden;
            z-index: 50;
            opacity: 1 !important;
            visibility: visible !important;
            font-family: 'Press Start 2P';
        }
        
        /* Force discovery feed to be visible */
        #gameContainer .discovery-feed {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        .discovery-feed-inner {
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(138, 43, 226, 0.3) transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar {
            width: 4px;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.3);
            border-radius: 2px;
        }
        
        .discovery-message {
            background: var(--snes-dark-blue);
            border: 4px solid;
            border-color: var(--snes-gold) var(--snes-black) var(--snes-black) var(--snes-gold);
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 0;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            font-size: 14px;
            animation: slideInLeft 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .discovery-message .emoji {
            font-size: 20px;
        }
        
        .discovery-message .discovery-text {
            flex: 1;
        }
        
        .discovery-message .discovery-name {
            color: var(--snes-gold);
            font-weight: normal;
            font-size: 10px;
            font-family: 'Press Start 2P';
            text-shadow: 1px 1px 0 rgba(0,0,0,0.8);
        }
        
        .discovery-message .discovery-combo {
            font-size: 8px;
            color: var(--snes-white);
            margin-top: 4px;
            font-family: 'Press Start 2P';
            line-height: 1.4;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.8);
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 50;
        }
        
        body.mobile .mobile-controls {
            display: block;
        }
        
        .virtual-joystick {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: none;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
        }
        
        .boost-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(78, 205, 196, 0.15);
            border: 3px solid rgba(78, 205, 196, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .boost-button.active {
            background: rgba(78, 205, 196, 0.4);
            transform: scale(0.95);
        }
        
        .pause-button-mobile {
            position: absolute;
            top: 20px; /* Moved to top of screen */
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.4); /* Reduced opacity from 0.7 */
            border: 2px solid rgba(255, 255, 255, 0.2); /* Reduced opacity from 0.4 */
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.6); /* Reduced opacity */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .mute-button-mobile {
            position: absolute;
            top: 20px; /* Moved to top of screen */
            right: 80px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.4); /* Reduced opacity from 0.7 */
            border: 2px solid rgba(255, 255, 255, 0.2); /* Reduced opacity from 0.4 */
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.6); /* Reduced opacity */
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Fix pause/mute button positions in landscape - move to bottom center */
        @media (orientation: landscape) {
            .pause-button-mobile {
                top: auto !important;
                bottom: 20px !important;
                right: auto !important;
                left: 50% !important;
                transform: translateX(-50%) translateX(30px) !important;
            }
            
            .mute-button-mobile {
                top: auto !important;
                bottom: 20px !important;
                right: auto !important;
                left: 50% !important;
                transform: translateX(-50%) translateX(-30px) !important;
            }
        }
        
        /* Alchemy Vision Timer */
        .alchemy-vision-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 280px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.2) 100%);
            border: 2px solid #FFD700;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            z-index: 100;
        }
        
        /* Mobile UI Inversions */
        body.mobile .bottom-ui {
            top: 0;
            bottom: auto;
            padding-bottom: 20px;
            padding-top: 20px;
            border-top: none;
            border-bottom: none;
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.2);
            background: linear-gradient(to top, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.4) 10%, /* Reduced from 0.7 */
                rgba(10, 10, 26, 0.6) 30%, /* Reduced from 0.95 */
                rgba(10, 10, 26, 0.7) 100% /* Reduced from 0.98 */
            );
        }
        
        /* Professional mobile UI with orientation-aware positioning */
        
        /* Portrait mode mobile */
        @media (max-width: 800px) and (orientation: portrait) {
            body.mobile .player-info-box {
                position: fixed !important;
                top: 20px !important;
                bottom: unset !important;
                left: 10px !important;
                width: 45%;
                font-size: 7px !important;
                padding: 6px;
            }
            
            body.mobile .leaderboard-box {
                position: fixed !important;
                top: 20px !important;
                bottom: unset !important;
                right: 10px !important;
                left: auto !important;
                width: 45%;
                font-size: 9px !important;
            }
            
            body.mobile .boost-bar-container {
                bottom: 160px;
                width: 70%;
            }
        }
        
        /* Landscape mode mobile */
        @media (max-width: 800px) and (orientation: landscape) {
            body.mobile .player-info-box {
                position: fixed !important;
                top: 60px !important;
                bottom: unset !important;
                left: 10px !important;
                right: auto !important;
                width: 180px !important;
                font-size: 6px !important;
                padding: 4px !important;
                z-index: 20 !important;
            }
            
            body.mobile .leaderboard-box {
                position: fixed !important;
                top: 60px !important;
                bottom: unset !important;
                right: 10px !important;
                left: auto !important;
                width: 200px !important;
                font-size: 8px !important;
                z-index: 20 !important;
            }
            
            body.mobile .boost-bar-container {
                bottom: 110px !important;
                width: 50% !important;
                max-width: 300px !important;
            }
            
            body.mobile .boost-bar-frame {
                height: 14px !important;
                border: 2px solid #333;
                border-bottom: none;
            }
            
            body.mobile .element-collection-bar {
                padding: 0 10px;
                margin-bottom: 5px;
            }
            
            body.mobile .element-slot {
                width: 48px;
                height: 48px;
            }
            
            body.mobile .bottom-ui {
                padding-top: 10px;
                padding-bottom: 10px;
            }
            
            /* Adjust element sizes for landscape */
            body.mobile .player-portrait {
                width: 40px !important;
                height: 40px !important;
            }
            
            body.mobile .player-portrait img {
                width: 36px !important;
                height: 36px !important;
            }
            
            body.mobile .stat-line {
                font-size: 6px !important;
                margin: 1px 0 !important;
            }
            
            body.mobile .leaderboard-header {
                font-size: 10px !important;
                padding: 4px !important;
            }
            
            body.mobile .leaderboard-entry {
                padding: 3px 4px !important;
                font-size: 8px !important;
            }
        }
        
        /* Alchemy Vision Timer on Mobile - Bottom Center */
        body.mobile .alchemy-vision-timer {
            top: auto;
            bottom: 80px; /* Above boost bar */
            left: 50%;
            transform: translateX(-50%);
            width: 240px;
            font-size: 16px;
            padding: 8px;
        }
        
        /* Commented out - replaced by professional mobile UI with orientation-aware positioning
        body.mobile .leaderboard-box {
            top: 150px; /* Moved down more to avoid top bar overlap */
            bottom: auto;
            right: 10px;
            width: 180px;
            background: rgba(20, 20, 40, 0.6);
            padding: 8px;
            font-size: 10px;
            cursor: pointer; /* Make it clickable */
            transition: all 0.3s ease;
        } */
        
        body.mobile .leaderboard-box.collapsed {
            width: auto;
            min-width: 40px;
            height: 40px;
            overflow: hidden;
        }
        
        body.mobile .leaderboard-box.collapsed .leaderboard-entry,
        body.mobile .leaderboard-box.collapsed .leaderboard-divider {
            display: none;
        }
        
        body.mobile .leaderboard-box.collapsed .leaderboard-header {
            margin: 0;
            font-size: 12px;
        }
        
        body.mobile .leaderboard-header {
            font-size: 12px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        body.mobile .leaderboard-header::after {
            content: '▼';
            font-size: 10px;
            margin-left: 5px;
            transition: transform 0.3s ease;
        }
        
        body.mobile .leaderboard-box.collapsed .leaderboard-header::after {
            transform: rotate(-90deg);
        }
        
        body.mobile .leaderboard-entry {
            padding: 4px 6px;
            margin: 2px 0;
            font-size: 10px;
        }
        
        body.mobile .leaderboard-stats {
            font-size: 9px;
        }
        
        /* Commented out - replaced by professional mobile UI with orientation-aware positioning
        body.mobile .discovery-feed {
            top: 50%;
            transform: translateY(-50%);
        } */
        
        body.mobile .message-popup {
            top: auto;
            bottom: 50px; /* Positioned just above pause/mute buttons */
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            border-width: 2px;
        }
        
        /* Commented out - replaced by professional mobile UI
        body.mobile #pauseText,
        body.mobile #fpsCounter {
            top: 170px;
        } */
        
        /* Touch-specific optimizations */
        body.mobile {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* GPU acceleration for mobile UI elements */
        body.mobile .bottom-ui,
        body.mobile .player-info-box,
        body.mobile .leaderboard-box,
        body.mobile .boost-bar-container,
        body.mobile .virtual-joystick,
        body.mobile .boost-button {
            will-change: transform;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        
        body.mobile .desktop-only {
            display: none;
        }
        
        /* Mobile splash screen adjustments */
        @media (max-width: 800px) and (orientation: landscape) {
            #splashScreen {
                display: flex;
                align-items: center;
                justify-content: center;
                overflow-y: auto;
            }
            
            #splashContent {
                padding: 10px 20px;
                max-height: 90vh;
                overflow: visible;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                width: 100%;
            }
            
            #splashLogo {
                width: 120px !important;
                max-width: 120px !important;
                height: auto !important;
                margin-bottom: 5px !important;
            }
            
            #splashTitle {
                font-size: 16px !important;
                margin-bottom: 5px !important;
                display: none !important; /* Hide title in landscape */
            }
            
            #splashScreen p {
                font-size: 10px !important;
                margin: 2px !important;
                line-height: 1.2 !important;
                max-height: none;
                overflow: visible;
                text-align: center;
                display: none !important; /* Hide text in extreme landscape */
            }
            
            #startButton {
                margin-top: 10px !important;
                margin-bottom: 10px !important;
                padding: 15px 50px !important;
                font-size: 20px !important;
                position: relative !important;
                bottom: unset !important;
                display: block !important;
                visibility: visible !important;
            }
            
            /* Keep controls consistent in landscape */
            .virtual-joystick {
                width: 100px !important;
                height: 100px !important;
                bottom: 20px !important;
                left: 20px !important;
            }
            
            .boost-button {
                width: 100px !important;
                height: 100px !important;
                bottom: 20px !important;
                right: 20px !important;
            }
        }
        
        /* Portrait mobile adjustments */
        @media (max-width: 600px) and (orientation: portrait) {
            #splashScreen img {
                width: 300px !important;
            }
            
            #splashScreen p {
                font-size: 16px;
            }
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .player-info-box,
            .leaderboard-box {
                width: 240px;
                font-size: 10px;
            }
            
            .element-slot {
                width: 48px;
                height: 48px;
            }
            
            .element-slot .emoji {
                font-size: 24px;
            }
            
            .discovery-feed {
                width: 250px;
            }
        }
        
        @media (max-width: 800px) {
            .player-info-box,
            .leaderboard-box {
                /* Removed bottom positioning - will use orientation-specific rules */
                width: 200px;
            }
            
            body.mobile .player-info-box,
            body.mobile .leaderboard-box {
                /* Default mobile position - will be overridden by orientation-specific rules */
                bottom: unset !important; /* Ensure desktop bottom positioning is removed */
            }
            
            .discovery-feed {
                display: none; /* Hide on mobile */
            }
            
            #discoveryLog {
                width: 200px;
                font-size: 12px;
                padding: 15px;
            }
            
            #discoveryLog h3 {
                font-size: 16px;
            }
            
            .element-slot {
                width: 42px;
                height: 42px;
            }
            
            .boost-bar-container {
                width: 80%;
            }
            
            .virtual-joystick {
                width: 100px;
                height: 100px;
                left: 20px;
                bottom: 20px;
            }
            
            .boost-button {
                width: 100px; /* Match joystick size */
                height: 100px; /* Match joystick size */
                right: 20px; /* Mirror joystick position */
                bottom: 20px; /* Match joystick position */
                font-size: 14px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        /* Force boost button size in landscape on mobile */
        @media (max-width: 800px) and (orientation: landscape) {
            body.mobile .boost-button {
                width: 100px !important;
                height: 100px !important;
            }
            
            body.mobile .virtual-joystick {
                width: 100px !important;
                height: 100px !important;
            }
        }
        
        /* Ensure consistent controls in landscape after other media queries */
        @media (orientation: landscape) {
            .virtual-joystick {
                width: 100px !important;
                height: 100px !important;
            }
            
            .boost-button {
                width: 100px !important;
                height: 100px !important;
            }
        }
        
        /* Additional landscape fixes for all screens */
        @media (max-height: 500px) {
            /* Splash screen in extreme landscape */
            #splashContent {
                padding: 5px 20px !important;
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                gap: 20px;
                max-height: 100vh !important;
            }
            
            #splashLogo {
                width: 100px !important;
                height: auto !important;
                flex-shrink: 0;
            }
            
            #splashScreen p {
                display: none !important; /* Hide all text in extreme landscape */
            }
            
            #splashTitle {
                display: none !important;
            }
            
            #startButton {
                flex-shrink: 0;
                padding: 12px 40px !important;
                font-size: 18px !important;
                visibility: visible !important;
                display: block !important;
            }
            
            /* Game mode selection in extreme landscape */
            #gameModeContent {
                padding: 5px 20px !important;
                max-height: 95vh !important;
            }
            
            #gameModeSelect h3 {
                font-size: 16px !important;
                margin: 5px 0 !important;
            }
            
            #victoryButtons {
                gap: 10px !important;
                margin-bottom: 10px !important;
            }
            
            .victory-column h5 {
                font-size: 14px !important;
                margin: 0 0 5px 0 !important;
            }
            
            .modeSection {
                margin-bottom: 5px !important;
            }
            
            .modeSection h4 {
                font-size: 12px !important;
                margin: 5px 0 !important;
            }
            
            #gameModeSelect button {
                padding: 6px 15px !important;
                font-size: 12px !important;
                min-width: 140px !important;
                margin: 2px !important;
            }
            
            .btn-infinite {
                min-width: 200px !important;
                font-size: 14px !important;
                padding: 8px 20px !important;
            }
        }
        
        /* Game mode selection landscape adjustments */
        @media (max-width: 800px) and (orientation: landscape) {
            #gameModeContent {
                padding: 10px;
                max-height: 85vh;
                overflow-y: auto;
                margin-top: 5px;
            }
            
            #gameModeSelect {
                padding: 5px;
            }
            
            #gameModeSelect h3 {
                font-size: 18px;
                margin-bottom: 5px;
                margin-top: 5px;
            }
            
            .modeSection {
                margin-bottom: 8px;
            }
            
            .modeSection h4 {
                font-size: 14px;
                margin-bottom: 5px;
            }
            
            .victoryButton {
                padding: 6px 12px;
                margin: 2px;
                font-size: 12px;
            }
            
            .controlOption {
                padding: 8px 15px;
                margin: 3px;
                font-size: 14px;
            }
            
            #startGameButton {
                padding: 10px 30px;
                font-size: 18px;
                margin-top: 5px;
                margin-bottom: 10px;
            }
        }
        
        /* Victory Overlay */
        #victoryOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #victoryPopup {
            position: relative;
            background: rgba(0, 0, 128, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 48px;
            border-radius: 0;
            text-align: center;
            max-width: 600px;
            width: 90%;
            border: 8px solid;
            border-color: var(--snes-gold) #805800 #805800 var(--snes-gold);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.5);
            animation: flash 0.5s steps(2) infinite alternate;
            font-family: 'Press Start 2P';
        }
        
        @keyframes flash {
            0% { outline: 4px solid var(--snes-gold); }
            100% { outline: 4px solid var(--snes-white); }
        }
        
        .victory-glow {
            display: none;
        }
        
        .victory-title {
            font-size: 24px;
            color: var(--snes-gold);
            margin-bottom: 24px;
            text-shadow: 2px 2px 0 var(--snes-red), 4px 4px 0 var(--snes-black);
            animation: blink 1s steps(2) infinite;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        .victory-lore {
            font-size: 10px;
            color: var(--snes-cosmic-teal);
            margin: 24px 0 32px;
            line-height: 2;
            font-style: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .victory-stats {
            background: var(--snes-black);
            border-radius: 0;
            padding: 16px;
            margin: 24px 0;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 4px solid;
            border-color: var(--snes-dark-blue) var(--snes-light-blue) var(--snes-light-blue) var(--snes-dark-blue);
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 2px solid var(--snes-dark-blue);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #AAA;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .victory-button {
            margin-top: 24px;
            padding: 16px 32px;
            font-size: 12px;
            background: var(--snes-cosmic-purple);
            border: 4px solid var(--snes-white);
            border-radius: 0;
            color: var(--snes-white);
            cursor: pointer;
            transition: none;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            font-family: 'Press Start 2P';
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .victory-button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        
        .victory-button:active {
            transform: translate(4px, 4px);
            box-shadow: none;
        }
        
        /* Mobile adjustments for victory popup */
        @media (max-width: 600px) {
            #victoryPopup {
                padding: 30px;
            }
            
            .victory-title {
                font-size: 16px;
            }
            
            .victory-lore {
                font-size: 8px;
            }
            
            .stat-label {
                font-size: 8px;
            }
            
            .stat-value {
                font-size: 10px;
            }
        }
        
        /* Pause Menu */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #pauseMenu {
            background: #181850;
            padding: 32px;
            border-radius: 0;
            text-align: center;
            width: 900px;
            height: 700px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 8px solid;
            border-color: var(--snes-white) var(--snes-black) var(--snes-black) var(--snes-white);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.8);
            outline: 2px solid var(--snes-gold);
            outline-offset: -12px;
            font-family: 'Press Start 2P';
        }
        
        /* Tab Navigation - SNES Style */
        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 16px 0;
            border-bottom: 4px solid var(--snes-dark-purple);
            padding-bottom: 12px;
        }
        
        .tab-button {
            padding: 12px 24px;
            background: var(--snes-primary-blue);
            border: 2px solid;
            border-color: var(--snes-light-blue) var(--snes-dark-blue) var(--snes-dark-blue) var(--snes-light-blue);
            border-radius: 0;
            color: var(--snes-white);
            cursor: pointer;
            transition: none;
            font-size: 10px;
            text-transform: uppercase;
            font-family: 'Press Start 2P';
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
        }
        
        .tab-button:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        
        .tab-button.active {
            background: var(--snes-gold);
            color: var(--snes-black);
            border-color: var(--snes-white) #A88800 #A88800 var(--snes-white);
            transform: translate(4px, 4px);
            box-shadow: none;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Discovery Journal - SNES Style */
        #discoveryJournal {
            padding: 16px;
            padding-right: 12px;
            background: var(--snes-black);
            border-radius: 0;
            flex: 1;
            overflow: hidden;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            min-height: 0;
            border: 4px solid;
            border-color: var(--snes-dark-blue) var(--snes-light-blue) var(--snes-light-blue) var(--snes-dark-blue);
        }
        
        
        .discovery-grid {
            display: grid;
            grid-template-columns: repeat(8, minmax(90px, 1fr));
            gap: 10px;
            margin-top: 20px;
            flex: 1;
            padding-right: 15px;
            box-sizing: border-box;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
            max-width: 100%;
            min-height: 0;
        }
        
        /* Custom scrollbar for discovery grid */
        .discovery-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .discovery-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .discovery-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 4px;
        }
        
        .discovery-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.7);
        }
        
        .discovery-item {
            background: var(--snes-dark-blue);
            border: 2px solid;
            border-color: var(--snes-cosmic-purple) var(--snes-dark-purple) var(--snes-dark-purple) var(--snes-cosmic-purple);
            border-radius: 0;
            padding: 4px;
            text-align: center;
            transition: none;
            cursor: pointer;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            image-rendering: pixelated;
        }
        
        .discovery-item:hover {
            background: var(--snes-cosmic-purple);
            transform: translate(1px, 1px);
            box-shadow: 1px 1px 0 rgba(0,0,0,0.5);
        }
        
        
        .discovery-item .element-symbol {
            font-size: 24px;
            margin-bottom: 4px;
            filter: drop-shadow(1px 1px 0 rgba(0,0,0,0.5));
        }
        
        .discovery-item .element-name {
            font-size: 8px;
            color: var(--snes-gold);
            word-break: break-word;
            line-height: 1.2;
            font-family: 'Press Start 2P';
            text-transform: uppercase;
        }
        
        .discovery-item .recipe {
            font-size: 6px;
            color: var(--snes-gray);
            margin-top: 4px;
            line-height: 1;
            font-family: 'Press Start 2P';
            text-transform: none;
            letter-spacing: -0.5px;
        }
        
        
        /* How to Play Section - SNES Style */
        .howToPlay {
            margin-top: 16px;
            padding: 16px;
            background: var(--snes-dark-blue);
            border-radius: 0;
            text-align: left;
            font-size: 8px;
            color: var(--snes-gray);
            line-height: 2;
            border: 4px solid;
            border-color: var(--snes-cosmic-teal) var(--snes-black) var(--snes-black) var(--snes-cosmic-teal);
        }
        
        .howToPlay h5 {
            color: var(--snes-gold);
            margin-bottom: 12px;
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .howToPlay ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .howToPlay li {
            margin-bottom: 5px;
        }
        
        .howToPlay strong {
            color: var(--snes-cosmic-teal);
            text-shadow: 1px 1px 0 var(--snes-black);
        }
        
        /* Skin Selection */
        #skinSelection {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        #skinSelection h4 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #availableUnlocks {
            text-align: center;
            color: #4ecdc4;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        #skinGrid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex: 1;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 10px;
        }
        
        .skin-item {
            position: relative;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .skin-item:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .skin-item.current {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .skin-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .skin-item.locked:hover {
            transform: none;
        }
        
        .skin-item.unlockable {
            border-color: #4ecdc4;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #4ecdc4; }
            50% { box-shadow: 0 0 20px #4ecdc4, 0 0 30px #4ecdc4; }
        }
        
        .skin-image {
            width: 100%;
            height: 100%;
            max-width: 60px;
            max-height: 60px;
            margin: 0 auto 3px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            object-fit: contain;
        }
        
        .skin-name {
            font-size: 10px;
            color: #CCC;
            margin-top: 3px;
            line-height: 1.2;
        }
        
        .skin-unlock-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }
        /* Mobile pause menu fixes */
        @media (max-width: 800px) {
            #pauseMenu {
                width: 95%;
                max-width: 95%;
                padding: 10px;
                margin: 10px;
            }
            
            #skinGrid {
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                padding-right: 0;
                overflow-x: hidden;
            }
            
            .skin-item {
                padding: 6px;
            }
            
            .skin-image {
                max-width: 50px;
                max-height: 50px;
            }
            
            .skin-name {
                font-size: 8px;
            }
            
            .discovery-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                padding-right: 0;
                overflow-x: hidden;
            }
            
            .discovery-item {
                padding: 4px;
            }
            
            .discovery-item .element-symbol {
                font-size: 20px;
            }
            
            .discovery-item .element-name {
                font-size: 7px;
            }
            
            .tab-button {
                font-size: 8px;
                padding: 8px 5px;
            }
        }
        
        /* Portrait mobile specific - fix discovery journal cutoff */
        @media (max-width: 600px) and (orientation: portrait) {
            .discovery-grid {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 4px;
            }
            
            .discovery-item {
                padding: 2px !important;
                aspect-ratio: 1;
            }
            
            .discovery-item .element-symbol {
                font-size: 16px !important;
                margin-bottom: 2px;
            }
            
            .discovery-item .element-name {
                font-size: 5px !important;
                line-height: 1;
            }
            
            .discovery-item .recipe {
                font-size: 4px !important;
            }
        }
        
        /* Landscape mobile specific */
        @media (max-width: 800px) and (orientation: landscape) {
            #pauseMenu {
                max-height: 85vh;
            }
            
            #skinGrid,
            .discovery-grid {
                grid-template-columns: repeat(5, 1fr);
                max-height: 200px;
            }
        }
    </style>

    <!-- UI Fixes CSS - Added to improve readability and visual appeal -->
    <style>
        /* ===== PLAYER INFO BOX FIXES ===== */
        .player-info-box {
            width: 280px !important; /* Increased from 240px */
            font-size: 8px !important; /* Base font size */
        }
        
        /* Mobile positioning fix - ensure top positioning takes precedence */
        body.mobile .player-info-box {
            bottom: unset !important;
        }
        
        body.mobile .leaderboard-box {
            bottom: unset !important;
        }

        .player-portrait {
            width: 64px !important; /* Increased from 48px */
            height: 64px !important; /* Increased from 48px */
        }

        .player-portrait img {
            width: 60px !important; /* Increased from 44px */
            height: 60px !important; /* Increased from 44px */
        }

        .stat-label {
            font-size: 8px !important; /* Increased from 7px */
            letter-spacing: -0.5px !important; /* Tighten spacing to prevent overflow */
        }

        .stat-value {
            font-size: 10px !important; /* Increased from 7px but not too large */
            letter-spacing: -0.5px !important; /* Tighten spacing */
        }

        .stat-line {
            font-size: 8px !important; /* Ensure consistency */
            margin: 3px 0 !important; /* Slightly more spacing */
        }

        /* ===== LEADERBOARD BOX FIXES ===== */
        .leaderboard-box {
            width: 320px !important; /* Increased from 240px */
            cursor: pointer !important;
            transition: all 0.3s ease !important;
        }

        .leaderboard-header {
            font-size: 14px !important; /* Increased from 12px */
            position: relative !important;
        }

        /* Add collapse indicator */
        .leaderboard-header::after {
            content: '▼' !important;
            position: absolute !important;
            right: 12px !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            font-size: 10px !important;
            transition: transform 0.3s ease !important;
        }

        .leaderboard-box.collapsed .leaderboard-header::after {
            transform: translateY(-50%) rotate(-90deg) !important;
        }

        /* Collapsed state */
        .leaderboard-box.collapsed {
            width: auto !important;
            min-width: 120px !important;
        }

        .leaderboard-box.collapsed #leaderboardList {
            display: none !important;
        }

        /* Restructure leaderboard entries */
        .leaderboard-entry {
            display: block !important; /* Change from flex to block */
            padding: 10px 12px !important;
            position: relative !important;
            min-height: 45px !important; /* Ensure enough height for two lines */
        }

        /* Two-line layout for names */
        .leaderboard-name {
            display: block !important;
            font-size: 11px !important;
            line-height: 1.3 !important;
            margin-bottom: 4px !important;
            white-space: normal !important; /* Allow wrapping */
            word-wrap: break-word !important;
            width: 60% !important; /* Leave space for stats */
        }

        /* Style personality type differently */
        .leaderboard-name span[style*="color"] {
            display: block !important; /* Put personality on its own line */
            font-size: 10px !important;
            margin-bottom: 2px !important;
        }

        /* Stats on the right side */
        .leaderboard-stats {
            position: absolute !important;
            right: 12px !important;
            top: 50% !important;
            transform: translateY(-50%) !important;
            text-align: right !important;
            font-size: 11px !important;
            line-height: 1.3 !important;
        }

        .leaderboard-stats div {
            white-space: nowrap !important;
            margin-bottom: 2px !important;
        }

        /* ===== DISCOVERY MENU TAB FIXES ===== */
        .discovery-item .recipe {
            font-size: 8px !important; /* Increased from 6px */
            letter-spacing: 0 !important; /* Normal spacing for readability */
            line-height: 1.3 !important; /* Better line height */
        }

        .discovery-item .element-name {
            font-size: 9px !important; /* Increased from 8px */
        }

        /* ===== FONT UNIFORMITY FIXES ===== */
        /* Fix all buttons to use Press Start 2P */
        button {
            font-family: 'Press Start 2P', monospace !important;
        }

        /* Specifically target problem buttons */
        .btn-leaderboard,
        .mini-lb-tab,
        .leaderboard-tab,
        #submitScoreBtn,
        #skipScoreBtn,
        button[onclick*="resumeGame"],
        button[onclick*="reload"],
        button[onclick*="showLeaderboard"] {
            font-family: 'Press Start 2P', monospace !important;
        }

        /* Fix pause menu buttons */
        #pauseMenu button {
            font-family: 'Press Start 2P', monospace !important;
        }

        /* ===== DISCOVERY POPUP ENHANCEMENTS ===== */
        #recentDiscovery {
            background: linear-gradient(135deg, 
                rgba(120, 40, 248, 0.95) 0%, 
                rgba(248, 40, 248, 0.95) 50%, 
                rgba(0, 248, 248, 0.95) 100%) !important;
            color: var(--snes-white) !important;
            border: 4px solid var(--snes-gold) !important;
            border-color: var(--snes-gold) #A88800 #A88800 var(--snes-gold) !important;
            outline: 3px solid var(--snes-white) !important;
            outline-offset: -8px !important;
            box-shadow: 
                0 0 20px rgba(248, 216, 0, 0.6),
                8px 8px 0 rgba(0,0,0,0.8) !important;
            animation: none !important; /* Remove default animation */
        }

        #recentDiscovery.show {
            animation: epicDiscoveryPulse 0.5s steps(8) !important;
        }

        @keyframes epicDiscoveryPulse {
            0%, 100% {
                transform: translateX(-50%) translateY(0) scale(1);
                filter: hue-rotate(0deg);
            }
            25% {
                transform: translateX(-50%) translateY(-5px) scale(1.1);
                filter: hue-rotate(90deg);
            }
            50% {
                transform: translateX(-50%) translateY(0) scale(1.15);
                filter: hue-rotate(180deg);
            }
            75% {
                transform: translateX(-50%) translateY(-3px) scale(1.05);
                filter: hue-rotate(270deg);
            }
        }

        #recentDiscovery.combo {
            background: rgba(0, 0, 0, 0.95) !important; /* Solid black background */
            animation: epicComboFlash 0.3s steps(4) 3 !important;
        }

        @keyframes epicComboFlash {
            0%, 100% { 
                filter: brightness(1);
                transform: translateX(-50%) scale(1);
            }
            50% { 
                filter: brightness(1.5);
                transform: translateX(-50%) scale(1.1);
            }
        }

        /* ===== RESPONSIVE ADJUSTMENTS ===== */
        @media (max-width: 1200px) {
            .player-info-box {
                width: 260px !important; /* Still wider than original */
            }
            .leaderboard-box {
                width: 300px !important; /* Keep leaderboard wider */
            }
        }

        @media (max-width: 800px) {
            .player-info-box {
                width: 220px !important; /* Compromise for mobile */
            }
            .leaderboard-box {
                width: 280px !important; /* Keep leaderboard wider on mobile */
            }
            
            .stat-label,
            .stat-value {
                font-size: 9px !important; /* Slightly smaller on mobile */
            }
            
            .leaderboard-entry {
                font-size: 11px !important;
            }
        }

        /* ===== ADDITIONAL FIXES ===== */
        /* Ensure discovery feed messages are readable */
        .discovery-message .discovery-name {
            font-size: 11px !important; /* Increased from 10px */
        }

        .discovery-message .discovery-combo {
            font-size: 9px !important; /* Increased from 8px */
        }

        /* Fix any overflow issues */
        .player-stats {
            min-width: 0 !important; /* Allow flex shrinking */
        }

        .stat-line {
            min-width: 0 !important; /* Prevent overflow */
        }
        
        /* Loading Screen Styles */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000011;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', monospace;
        }
        
        .loading-content {
            width: 90%;
            max-width: 600px;
            text-align: center;
            position: relative;
        }
        
        .loading-stars-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }
        
        /* Logo Section */
        .loading-logo-section {
            margin-bottom: 40px;
            position: relative;
        }
        
        .loading-logo-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 100px;
            background: radial-gradient(ellipse at center, var(--snes-cosmic-purple) 0%, transparent 70%);
            opacity: 0.5;
            animation: loadingGlowPulse 2s ease-in-out infinite;
        }
        
        .loading-title {
            font-size: 24px;
            color: var(--snes-gold);
            text-shadow: 2px 2px 0 var(--snes-red), 4px 4px 0 var(--snes-black);
            margin: 0;
            letter-spacing: 2px;
            animation: loadingTitlePulse 1s steps(2) infinite;
        }
        
        .loading-subtitle {
            font-size: 10px;
            color: var(--snes-cosmic-teal);
            margin-top: 10px;
            opacity: 0.8;
        }
        
        /* Progress Section */
        .loading-progress-section {
            margin-bottom: 30px;
        }
        
        .loading-progress-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .loading-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--snes-dark-purple);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }
        
        .loading-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                var(--snes-cosmic-purple) 0%, 
                var(--snes-cosmic-pink) 50%, 
                var(--snes-cosmic-purple) 100%);
            background-size: 200% 100%;
            animation: loadingProgressShine 2s linear infinite;
            transition: width 0.3s ease;
        }
        
        .loading-progress-glow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.3) 50%, 
                transparent 100%);
            transform: translateX(-100%);
            animation: loadingProgressGlow 2s linear infinite;
        }
        
        .loading-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--snes-gold);
            font-size: 10px;
            text-shadow: 1px 1px 0 var(--snes-black);
        }
        
        .loading-phase-text {
            font-size: 9px;
            color: var(--snes-gray);
            animation: loadingTextBlink 1s steps(2) infinite;
        }
        
        /* Tips Section */
        .loading-tips-section {
            margin-bottom: 30px;
            min-height: 40px;
        }
        
        .loading-tip-container {
            background: rgba(20, 20, 40, 0.8);
            border: 2px solid var(--snes-cosmic-teal);
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .loading-tip-text {
            font-size: 9px;
            color: var(--snes-cosmic-teal);
            line-height: 1.5;
        }
        
        /* Element Preview */
        .loading-elements-preview {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .loading-element-orb {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: radial-gradient(circle at 30% 30%, 
                rgba(255, 255, 255, 0.2) 0%, 
                rgba(0, 0, 0, 0.4) 100%);
            border: 2px solid var(--snes-dark-purple);
            border-radius: 50%;
            animation: loadingOrbFloat 3s ease-in-out infinite;
            animation-delay: calc(var(--orb-index, 0) * 0.2s);
        }
        
        .loading-element-orb:nth-child(1) { --orb-index: 0; }
        .loading-element-orb:nth-child(2) { --orb-index: 1; }
        .loading-element-orb:nth-child(3) { --orb-index: 2; }
        .loading-element-orb:nth-child(4) { --orb-index: 3; }
        
        /* Animations */
        @keyframes loadingGlowPulse {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
        }
        
        @keyframes loadingTitlePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        @keyframes loadingProgressShine {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        
        @keyframes loadingProgressGlow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }
        
        @keyframes loadingTextBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes loadingOrbFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* Mobile-specific adjustments */
        @media (max-width: 600px) {
            .loading-title {
                font-size: 16px;
            }
            
            .loading-subtitle {
                font-size: 8px;
            }
            
            .loading-progress-bar {
                height: 16px;
            }
            
            .loading-tip-text {
                font-size: 8px;
            }
            
            .loading-element-orb {
                width: 32px;
                height: 32px;
                font-size: 16px;
            }
        }
    </style>

    <!-- JavaScript for collapsible leaderboard -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Make leaderboard collapsible
        const leaderboardBox = document.querySelector('.leaderboard-box');
        const leaderboardHeader = document.querySelector('.leaderboard-header');
        
        if (leaderboardBox && leaderboardHeader) {
            // Add click handler to header
            leaderboardHeader.addEventListener('click', function(e) {
                e.stopPropagation();
                leaderboardBox.classList.toggle('collapsed');
                
                // Save collapsed state to localStorage
                const isCollapsed = leaderboardBox.classList.contains('collapsed');
                localStorage.setItem('leaderboardCollapsed', isCollapsed);
            });
            
            // Restore collapsed state from localStorage
            const savedState = localStorage.getItem('leaderboardCollapsed');
            if (savedState === 'true') {
                leaderboardBox.classList.add('collapsed');
            }
        }
    });

    // Also update the leaderboard rendering function to better handle the two-line layout
    // This should be added to your existing game code where updateLeaderboard() is called
    function enhanceLeaderboardDisplay() {
        const leaderboardEntries = document.querySelectorAll('.leaderboard-entry');
        
        leaderboardEntries.forEach(entry => {
            const nameSpan = entry.querySelector('.leaderboard-name');
            if (nameSpan) {
                // Check if it has personality spans (colored text)
                const coloredSpans = nameSpan.querySelectorAll('span[style*="color"]');
                if (coloredSpans.length > 0) {
                    // Already has the split personality/name structure, just ensure block display
                    coloredSpans.forEach(span => {
                        span.style.display = 'block';
                    });
                }
            }
        });
    }

    // Call this after the leaderboard updates
    // You'll need to add this call in your existing updateLeaderboard() function
    if (typeof updateLeaderboard !== 'undefined') {
        const originalUpdateLeaderboard = updateLeaderboard;
        updateLeaderboard = function() {
            originalUpdateLeaderboard.apply(this, arguments);
            setTimeout(enhanceLeaderboardDisplay, 10);
        };
    }
    </script>
    
    <!-- New Element System Scripts -->
    <script src="elements/data/loader.js"></script>
    <!-- Supabase Integration -->
    <script type="module" src="js/supabase.js"></script>
    
    <!-- Mobile Optimization Scripts -->
    <script src="js/asset-preloader.js"></script>
    <script src="js/mobile-star-renderer.js"></script>
    <script src="js/mobile-background-optimizer.js"></script>
    <script src="js/mobile-background-integration.js"></script>
</head>
<body>
    <!-- Persistent Star Background -->
    <canvas id="persistentStarsCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none;"></canvas>
    
    <!-- Splash Screen -->
    <div id="splashScreen">
        <div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
            <a href="https://discord.gg/a6X4W7QbkG" target="_blank" style="color: #4ecdc4; text-decoration: none; font-family: monospace; font-size: 16px;">💬 Join the Discord Server</a>
        </div>
        <div style="position: absolute; top: 20px; right: 20px; z-index: 10;">
            <a href="/how-to-play.html" style="color: #4ecdc4; text-decoration: none; font-family: monospace; font-size: 16px; margin-right: 20px;">📖 How to Play</a>
            <a href="/leaderboard.html" style="color: #4ecdc4; text-decoration: none; font-family: monospace; font-size: 16px;">🏆 Leaderboard</a>
        </div>
        <div id="splashContent">
            <img src="assets/word-logo.webp" alt="Infinite Snake" id="splashLogo" style="width: 400px; max-width: 80%; margin-bottom: 30px;" onerror="this.style.display='none'; document.getElementById('splashTitle').style.display='block';">
            <h1 id="splashTitle">Infinite Snake</h1>
            <p>Welcome to what's left.<br><br>
            The Universe collapsed, scattered its contents across infinite coils of nothing. You're the Infinite Snake - part cleanup crew, part living library.<br><br>
            Collect fragments of reality. Merge them. See what happens. Rebuild the Cosmos one combination at a time. Maybe you'll figure out what we forgot.<br><br>
            Just remember: you're not the only thing moving in the dark…</p>
            <div style="margin: 20px 0;">
                <input type="text" id="playerNameInput" placeholder="Enter your name" 
                       style="width: 300px; max-width: 80%; padding: 12px 20px; 
                              font-family: monospace; font-size: 16px; 
                              background: rgba(0, 0, 0, 0.8); 
                              border: 2px solid #4ecdc4; 
                              color: #4ecdc4; text-align: center; 
                              border-radius: 25px; outline: none;
                              transition: all 0.3s ease;"
                       maxlength="30">
            </div>
            <button id="startButton">Begin Your Journey</button>
        </div>
    </div>
    
    <!-- Game Mode Selection -->
    <div id="gameModeSelect">
        <div id="gameModeContent">
            <h3>Game Setup</h3>
        
        <div class="modeSection">
            <h4>Victory Condition</h4>
            <div id="victoryButtons">
                <div class="victory-column">
                    <h5>🧪 Discovery Race</h5>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 50)">Discover 50 Elements</button>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 250)">Discover 250 Elements</button>
                </div>
                <div class="victory-column">
                    <h5>⭐ Points Race</h5>
                    <button class="btn-points" onclick="selectVictoryMode('points', 50000)">Score 50,000 Points</button>
                    <button class="btn-points" onclick="selectVictoryMode('points', 250000)">Score 250,000 Points</button>
                </div>
                <div class="victory-infinite">
                    <button class="btn-infinite" onclick="selectVictoryMode('infinite', 0)">∞ Infinite Mode</button>
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <!-- Loading Screen (Mobile Only) -->
    <div id="loadingScreen" style="display: none;">
        <div class="loading-content">
            <div class="loading-stars-bg"></div>
            
            <!-- Logo Section -->
            <div class="loading-logo-section">
                <div class="loading-logo-glow"></div>
                <h1 class="loading-title">INFINITE SNAKE</h1>
                <div class="loading-subtitle">Preparing the Cosmos...</div>
            </div>
            
            <!-- Progress Section -->
            <div class="loading-progress-section">
                <div class="loading-progress-container">
                    <div class="loading-progress-bar">
                        <div class="loading-progress-fill"></div>
                        <div class="loading-progress-glow"></div>
                    </div>
                    <div class="loading-progress-text">0%</div>
                </div>
                <div class="loading-phase-text">Initializing...</div>
            </div>
            
            <!-- Tips Section -->
            <div class="loading-tips-section">
                <div class="loading-tip-container">
                    <div class="loading-tip-icon"></div>
                    <div class="loading-tip-text">Tip: Combine Fire 🔥 + Water 💧 to create Steam!</div>
                </div>
            </div>
            
            <!-- Element Preview -->
            <div class="loading-elements-preview">
                <div class="loading-element-orb" data-element="fire">🔥</div>
                <div class="loading-element-orb" data-element="water">💧</div>
                <div class="loading-element-orb" data-element="earth">🌍</div>
                <div class="loading-element-orb" data-element="air">💨</div>
            </div>
        </div>
    </div>
    
    <!-- Discovery Sidebar -->
    <div id="discoveryLog">
        <h3>Discoveries (0)</h3>
        <div id="discoveryList"></div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div id="recentDiscovery"></div>
        <div id="bossVictoryMessage"></div>
        <div id="score">Score: 0</div>
        <div id="discoveries">Discoveries: 0</div>
        <div id="elementQueue"></div>
        
        <!-- Discovery Feed (Left Side) -->
        <div class="discovery-feed">
            <div class="discovery-feed-inner" id="discoveryFeed"></div>
        </div>
        
        <!-- Bottom UI Container -->
        <div class="bottom-ui">
            <!-- Element Collection Bar -->
            <div class="element-collection-bar" id="elementBar"></div>
            
            <!-- Boost Bar -->
            <div class="boost-bar-container">
                <div class="boost-bar-frame">
                    <div class="boost-bar-fill" id="boostBarFill" style="width: 100%"></div>
                    <div class="boost-bar-text">BOOST</div>
                </div>
            </div>
        </div>
        
        <!-- Alchemy Vision Timer -->
        <div id="alchemyVisionTimer" class="alchemy-vision-timer" style="display: none;">
            🔮 Alchemy Vision: <span id="alchemyTime">60</span>s
        </div>
        
        <!-- Player Info Box -->
        <div class="player-info-box">
            <div class="player-info-header">
                <div class="player-portrait">
                    <img id="playerPortrait" src="skins/snake-default-green.png" alt="Player">
                </div>
                <div class="player-stats">
                    <div class="stat-line">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="playerScore">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Discoveries</span>
                        <span class="stat-value" id="playerDiscoveries">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Best Rank</span>
                        <span class="stat-value" id="playerBestRank">-</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Kills</span>
                        <span class="stat-value" id="playerKills">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Time</span>
                        <span class="stat-value" id="playerTime">0:00</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Leaderboard Box -->
        <div class="leaderboard-box">
            <div class="leaderboard-header">Leaderboard</div>
            <div id="leaderboardList"></div>
        </div>
        
        <!-- UI Info (Top Right) -->
        <div id="pauseText" style="position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; color: rgba(255, 255, 255, 0.4); pointer-events: none;">
            <div style="margin-bottom: 5px;" class="desktop-only">Press P for Pause Menu</div>
            <div style="margin-bottom: 5px;" class="desktop-only" id="muteText">M to Mute</div>
            <div id="fpsCounter">FPS: --</div>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="virtual-joystick" id="virtualJoystick">
            <div class="joystick-base">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
        <div class="boost-button" id="boostButton">BOOST</div>
        <div class="pause-button-mobile" id="pauseButtonMobile" onclick="togglePause()">⏸</div>
        <div class="mute-button-mobile" id="muteButtonMobile" onclick="toggleMusic()">🔇</div>
    </div>
    
    <!-- Victory Overlay -->
    <div id="victoryOverlay" style="display: none;">
        <div id="victoryPopup">
            <div class="victory-glow"></div>
            <h1 class="victory-title">🏆 Victory! 🏆</h1>
            <div class="victory-lore" id="victoryLore"></div>
            <div class="victory-stats">
                <div class="stat-item">
                    <span class="stat-label">Final Score</span>
                    <span class="stat-value" id="victoryScore">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Elements Discovered</span>
                    <span class="stat-value" id="victoryDiscoveries">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time to Complete</span>
                    <span class="stat-value" id="victoryTime">0:00</span>
                </div>
            </div>
            <button class="victory-button" onclick="location.reload()">Play Again</button>
        </div>
    </div>
    
    <!-- Respawn Overlay -->
    <div id="respawnOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 60; pointer-events: auto;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: auto;">
            <div style="background: linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(30, 30, 50, 0.9) 100%); 
                        border: 2px solid rgba(255, 68, 68, 0.5); 
                        border-radius: 15px; 
                        padding: 30px 40px;
                        box-shadow: 0 0 30px rgba(255, 68, 68, 0.3);
                        pointer-events: auto;">
                <h2 id="deathMessage" style="color: #ff4444; margin: 0 0 20px 0; font-size: 32px; text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);">Your Form Dissolves Into The Void!</h2>
                
                <!-- Stats Summary - Two Column Layout -->
                <div style="margin-bottom: 25px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- This Game Column -->
                    <div>
                        <div style="color: #4ecdc4; font-size: 18px; margin-bottom: 10px; text-align: center;">THIS GAME</div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 8px;">
                            <div style="margin-bottom: 10px;">
                                <div style="color: #AAA; font-size: 14px;">Score</div>
                                <div id="respawnScore" style="color: #4ecdc4; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <div style="color: #AAA; font-size: 14px;">Discoveries</div>
                                <div id="respawnDiscoveries" style="color: #FFD700; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                            <div>
                                <div style="color: #AAA; font-size: 14px;">Kills</div>
                                <div id="respawnKills" style="color: #ff6b6b; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- All Time Best Column -->
                    <div>
                        <div style="color: #9c88ff; font-size: 18px; margin-bottom: 10px; text-align: center;">ALL TIME BEST</div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 8px;">
                            <div style="margin-bottom: 10px;">
                                <div style="color: #AAA; font-size: 14px;">Score</div>
                                <div id="bestScore" style="color: #4ecdc4; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                            <div style="margin-bottom: 10px;">
                                <div style="color: #AAA; font-size: 14px;">Discoveries</div>
                                <div id="bestDiscoveries" style="color: #FFD700; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                            <div>
                                <div style="color: #AAA; font-size: 14px;">Kills</div>
                                <div id="bestKills" style="color: #ff6b6b; font-size: 24px; font-weight: bold;">0</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Global Rank Display -->
                <div style="margin-bottom: 20px; text-align: center;">
                    <div style="color: #AAA; font-size: 14px;">Today's Global Rank</div>
                    <div id="globalRank" style="color: #9c88ff; font-size: 28px; font-weight: bold;">#--</div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
                    <button id="newGameBtn" onclick="returnToMainMenu()" 
                            style="background: transparent; 
                                   color: #AAA; 
                                   border: 2px solid #666; 
                                   padding: 12px 25px; 
                                   font-size: 16px; 
                                   font-family: monospace;
                                   cursor: pointer;
                                   border-radius: 5px;
                                   transition: all 0.3s ease;">
                        NEW GAME
                    </button>
                    <button id="reviveBtn" onclick="handleReviveOrRespawn()" 
                            style="background: #4ecdc4; 
                                   color: #000; 
                                   border: 2px solid #4ecdc4; 
                                   padding: 12px 25px; 
                                   font-size: 16px; 
                                   font-family: monospace;
                                   cursor: pointer;
                                   border-radius: 5px;
                                   font-weight: bold;
                                   transition: all 0.3s ease;
                                   box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);">
                        REVIVE (<span id="revivesLeft">3</span>)
                    </button>
                </div>
                
                <div style="margin-top: 10px; font-size: 12px; color: #AAA; text-align: center;">
                    Press SPACE / tap screen to <span id="actionText">revive</span>
                </div>
                
                <div id="respawnPenaltyText" style="margin-top: 8px; font-size: 12px; color: #ff9999; text-align: center; display: none;">
                    You will keep 75% of your score
                </div>
            </div>
        </div>
    </div>
    
    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <p style="color: #AAA; font-size: 14px; margin: 10px 0;">High Score: <span style="color: #FFD700;" id="highScoreDisplay">0</span></p>
            
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('skins')">Skins</button>
                <button class="tab-button" onclick="switchTab('journal')">Discovery Journal</button>
                <button class="tab-button" onclick="switchTab('howto')">How to Play</button>
                <button class="tab-button" onclick="switchTab('leaderboard')">Leaderboard</button>
            </div>
            
            <!-- Skins Tab -->
            <div id="skinsTab" class="tab-content active">
                <div id="skinSelection">
                    <h4>Snake Skins</h4>
                    <div id="availableUnlocks">Available Unlocks: 0</div>
                    
                    <!-- Rarity Tabs -->
                    <div class="rarity-tabs">
                        <button class="rarity-tab active" data-rarity="common">Common</button>
                        <button class="rarity-tab" data-rarity="uncommon">Uncommon</button>
                        <button class="rarity-tab" data-rarity="rare">Rare</button>
                        <button class="rarity-tab" data-rarity="legendary">Legendary</button>
                        <button class="rarity-tab" data-rarity="exotic">Exotic</button>
                        <button class="rarity-tab" data-rarity="secret">Secret</button>
                    </div>
                    
                    <!-- Skin Grid Container -->
                    <div id="skinGrid" class="skin-grid-new"></div>
                </div>
            </div>
            
            <!-- Discovery Journal Tab -->
            <div id="journalTab" class="tab-content">
                <div id="discoveryJournal">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">Discovery Journal</h4>
                    <p id="discoveryCount" style="color: #4ecdc4; margin-bottom: 10px; text-align: center;">Loading discoveries...</p>
                    <div class="discovery-grid" id="discoveryGrid">
                        <!-- Discoveries will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- How to Play Tab -->
            <div id="howtoTab" class="tab-content">
                <div style="padding: 20px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #FFD700; margin-bottom: 15px; text-align: center;">How to Play Infinite Snake</h4>
                    
                    <div style="color: #ddd; font-size: 14px; line-height: 1.6;">
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🎮 Controls</h5>
                            <p><strong>Desktop:</strong> Mouse to steer OR WASD keys</p>
                            <p><strong>WASD:</strong> A/D to turn, W to boost</p>
                            <p><strong>Mobile:</strong> Virtual joystick to steer, Boost button to accelerate</p>
                            <p><strong>Boost:</strong> Click/W (Desktop) or Boost button (Mobile)</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🎯 Goal</h5>
                            <p>Grow your snake by collecting elements and discovering new combinations! Climb the global leaderboard in Infinite Mode, unlock new skins, and build your Discovery Journal.</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🔬 Element System</h5>
                            <p>• Collect basic elements: Earth 🌍, Air 💨, Fire 🔥, Water 💧</p>
                            <p>• Your snake can hold up to 6 elements</p>
                            <p>• Elements automatically combine when compatible!</p>
                            <p>• Example: Fire + Water = Steam ☁️</p>
                            <p>• New elements and combinations are added regularly!</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">📖 Discovery Journal</h5>
                            <p>• Build your personal collection of discovered elements</p>
                            <p>• Your discoveries persist between sessions</p>
                            <p>• Track your progress and unlock achievements</p>
                            <p>• Compare your collection with other players</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">✨ Power-ups</h5>
                            <p><strong>🌀 Void Orb:</strong> Clear your element inventory and convert to points (may produce a random element!)</p>
                            <p><strong>💎 Catalyst Gem:</strong> Summons 3 rare undiscovered elements not in the current spawn pool</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">⚔️ Combat</h5>
                            <p>• Collide head-on with smaller snakes to eliminate them</p>
                            <p>• Collect their dropped elements for points</p>
                            <p>• Avoid head-on collisions with larger snakes!</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">🏆 Competitive Play</h5>
                            <p>• Play Infinite Mode to compete on the global leaderboard</p>
                            <p>• Daily, Weekly, Monthly, and All-Time rankings</p>
                            <p>• Submit your best scores and climb the ranks</p>
                            <p>• Track your personal best and improvement</p>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <h5 style="color: #4ecdc4; margin-bottom: 5px;">💡 Tips</h5>
                            <p>• Use boost strategically - it drains stamina!</p>
                            <p>• Experiment with different element combinations</p>
                            <p>• Stay away from the map borders!</p>
                            <p>• Check back regularly for new elements and features</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Leaderboard Tab -->
            <div id="leaderboardTab" class="tab-content">
                <div style="padding: 20px; max-height: 400px; overflow-y: auto;">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px; text-align: center;">Global Leaderboard - Infinite Mode</h4>
                    
                    <!-- Mini leaderboard tabs -->
                    <div style="display: flex; margin-bottom: 15px; border-bottom: 2px solid #333;">
                        <button class="mini-lb-tab active" onclick="loadPauseLeaderboard('daily')" 
                                style="flex: 1; padding: 10px; background: transparent; border: none; 
                                       color: #4ecdc4; font-size: 14px; cursor: pointer; font-family: monospace;">
                            Daily
                        </button>
                        <button class="mini-lb-tab" onclick="loadPauseLeaderboard('weekly')" 
                                style="flex: 1; padding: 10px; background: transparent; border: none; 
                                       color: #888; font-size: 14px; cursor: pointer; font-family: monospace;">
                            Weekly
                        </button>
                        <button class="mini-lb-tab" onclick="loadPauseLeaderboard('all')" 
                                style="flex: 1; padding: 10px; background: transparent; border: none; 
                                       color: #888; font-size: 14px; cursor: pointer; font-family: monospace;">
                            All Time
                        </button>
                    </div>
                    
                    <!-- Leaderboard entries -->
                    <div id="pauseLeaderboardEntries" style="font-family: monospace;">
                        <div style="color: #888; text-align: center; padding: 20px;">Loading...</div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(138, 43, 226, 0.3);">
                <button onclick="resumeGame()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #4ecdc4; color: white; border: none; border-radius: 10px; cursor: pointer;">Resume</button>
                <button onclick="playUISound(); location.reload()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer;">New Game</button>
            </div>
        </div>
    </div>
    
    <!-- Skin Preview Modal -->
    <div id="skinPreviewModal" class="skin-preview-modal" style="display: none;">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <div class="preview-container">
                <canvas id="skinPreviewCanvas" width="300" height="300"></canvas>
                <div class="preview-info">
                    <h2 id="previewSkinName">Skin Name</h2>
                    <div class="rarity-badge" id="previewRarity">
                        <span class="rarity-stars"></span>
                        <span class="rarity-text">Common</span>
                    </div>
                    <p id="previewBio" class="skin-bio">Skin description goes here...</p>
                    <div class="unlock-criteria" id="previewUnlockCriteria">
                        <h3>How to Unlock:</h3>
                        <p id="unlockText">Complete specific challenge</p>
                        <div class="progress-bar">
                            <div class="progress-fill" id="unlockProgress"></div>
                        </div>
                        <p class="progress-text" id="progressText">0/100</p>
                    </div>
                    <button id="equipButton" class="equip-button">Equip</button>
                    <button id="unlockButton" class="unlock-button" style="display: none;">Unlock (1 Token)</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Unlock Notification Container -->
    <div id="unlockNotificationContainer" class="unlock-notification-container"></div>
    
    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 100;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                    width: 90%; max-width: 800px; max-height: 90vh; 
                    background: linear-gradient(135deg, rgba(20, 20, 40, 0.98) 0%, rgba(30, 30, 50, 0.95) 100%);
                    border: 3px solid #4ecdc4;
                    box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
                    overflow: hidden;
                    image-rendering: pixelated;">
            
            <!-- Header -->
            <div style="background: rgba(0, 0, 0, 0.5); padding: 20px; border-bottom: 2px solid #4ecdc4;">
                <h2 style="color: #4ecdc4; margin: 0; font-family: monospace; font-size: 28px; text-align: center;">
                    GLOBAL LEADERBOARD
                </h2>
                <button onclick="closeLeaderboard()" 
                        style="position: absolute; top: 15px; right: 15px; 
                               background: transparent; border: 2px solid #ff4444; 
                               color: #ff4444; width: 40px; height: 40px; 
                               font-size: 20px; cursor: pointer; font-family: monospace;">
                    X
                </button>
            </div>
            
            <!-- Time Period Tabs -->
            <div style="display: flex; background: rgba(0, 0, 0, 0.3); border-bottom: 2px solid #333;">
                <button class="leaderboard-tab active" onclick="switchLeaderboardPeriod('daily')" 
                        style="flex: 1; padding: 15px; background: transparent; border: none; 
                               color: #4ecdc4; font-size: 16px; cursor: pointer; 
                               font-family: monospace; border-right: 2px solid #333;">
                    DAILY
                </button>
                <button class="leaderboard-tab" onclick="switchLeaderboardPeriod('weekly')" 
                        style="flex: 1; padding: 15px; background: transparent; border: none; 
                               color: #888; font-size: 16px; cursor: pointer; 
                               font-family: monospace; border-right: 2px solid #333;">
                    WEEKLY
                </button>
                <button class="leaderboard-tab" onclick="switchLeaderboardPeriod('monthly')" 
                        style="flex: 1; padding: 15px; background: transparent; border: none; 
                               color: #888; font-size: 16px; cursor: pointer; 
                               font-family: monospace; border-right: 2px solid #333;">
                    MONTHLY
                </button>
                <button class="leaderboard-tab" onclick="switchLeaderboardPeriod('all')" 
                        style="flex: 1; padding: 15px; background: transparent; border: none; 
                               color: #888; font-size: 16px; cursor: pointer; 
                               font-family: monospace;">
                    ALL TIME
                </button>
            </div>
            
            <!-- Leaderboard Content -->
            <div id="leaderboardContent" style="padding: 20px; overflow-y: auto; max-height: calc(90vh - 180px);">
                <!-- Table Header -->
                <div style="display: grid; grid-template-columns: 80px 80px 200px 150px 120px 120px 100px; 
                            gap: 10px; padding: 8px 12px; background: rgba(0, 0, 0, 0.5); 
                            border: 2px solid #555; margin-bottom: 10px; font-family: monospace;
                            font-weight: bold; color: #AAA; font-size: 12px; align-items: center;">
                    <div>RANK</div>
                    <div>COUNTRY</div>
                    <div>NAME</div>
                    <div style="text-align: right;">SCORE</div>
                    <div style="text-align: right;">ELEMENTS</div>
                    <div style="text-align: right;">TIME</div>
                    <div style="text-align: right;">KILLS</div>
                </div>
                
                <!-- Leaderboard Entries -->
                <div id="leaderboardEntries">
                    <div style="color: #888; text-align: center; padding: 40px; font-family: monospace;">
                        Loading leaderboard...
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <style>
        .leaderboard-tab.active {
            color: #4ecdc4 !important;
            border-bottom: 2px solid #4ecdc4 !important;
        }
        
        .leaderboard-entry {
            display: grid;
            grid-template-columns: 80px 80px 200px 150px 120px 120px 100px;
            gap: 10px;
            padding: 8px 12px;
            margin-bottom: 3px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid transparent;
            font-family: monospace;
            font-size: 14px;
            transition: all 0.2s;
            align-items: center;
        }
        
        .leaderboard-entry:hover {
            background: rgba(78, 205, 196, 0.1);
            border-color: rgba(78, 205, 196, 0.3);
        }
        
        .leaderboard-entry.player-entry {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            animation: pixelPulse 2s steps(2) infinite;
        }
        
        .rank-1 { color: #FFD700; font-size: 16px !important; }
        .rank-2 { color: #C0C0C0; font-size: 16px !important; }
        .rank-3 { color: #CD7F32; font-size: 16px !important; }
        
        /* ===== PROFESSIONAL MOBILE UI ENHANCEMENTS ===== */
        /* ===== MOBILE DETECTION & BASE SETUP ===== */
        @media (max-width: 1024px), (pointer: coarse) {
            /* Hide player portrait on mobile as per mockup */
            .player-portrait {
                display: none !important;
            }
            
            /* Adjust player info box for mobile without portrait */
            body.mobile .player-info-box {
                width: 200px !important;
                padding: 6px !important;
            }
            
            body.mobile .player-stats {
                margin-left: 0 !important;
                gap: 1px !important;
            }
            
            /* Ensure joystick and boost are same size */
            .virtual-joystick,
            .boost-button {
                width: 120px !important;
                height: 120px !important;
            }
        }

        /* ===== LANDSCAPE ORIENTATION (iPad Mini and larger tablets) ===== */
        @media screen and (orientation: landscape) and (max-width: 1024px) {
            /* Player Card - Top Left */
            body.mobile .player-info-box {
                position: fixed !important;
                top: var(--mobile-scorecard-top) !important;
                left: var(--mobile-scorecard-left) !important;
                bottom: var(--mobile-scorecard-bottom) !important;
                right: var(--mobile-scorecard-right) !important;
                width: 200px;
            }
            
            /* Leaderboard - Top Right */
            body.mobile .leaderboard-box {
                position: fixed !important;
                top: var(--mobile-leaderboard-top) !important;
                right: var(--mobile-leaderboard-right) !important;
                bottom: var(--mobile-leaderboard-bottom) !important;
                left: var(--mobile-leaderboard-left) !important;
                width: 240px;
            }
            
            /* Discovery Feed - Left Middle - Smaller and translucent */
            body.mobile .discovery-feed {
                left: 20px;
                top: 50%;
                transform: translateY(-50%) scale(var(--mobile-discovery-scale));
                bottom: auto;
                width: 200px;
                max-height: 30vh;
                opacity: var(--mobile-discovery-opacity);
                backdrop-filter: blur(5px);
            }
            
            /* Boost Bar & Element Bank - Top Center (compact) */
            body.mobile .bottom-ui {
                top: 5px;
                bottom: auto;
                padding: 5px 15px;
                left: 220px; /* Clear player card */
                right: 250px; /* Clear leaderboard */
                width: auto;
            }
            
            /* Compact boost bar for landscape */
            body.mobile .boost-bar-container {
                height: var(--mobile-boost-bar-height);
                margin-bottom: 5px;
            }
            
            body.mobile .boost-bar-frame {
                height: var(--mobile-boost-bar-height);
            }
            
            /* Joystick - Bottom Left Corner */
            body.mobile .virtual-joystick {
                bottom: 40px !important;
                left: 40px !important;
            }
            
            /* Boost Button - Bottom Right Corner */
            body.mobile .boost-button {
                bottom: 40px !important;
                right: 40px !important;
                left: auto !important;
            }
            
            /* Pause & Mute - Bottom center - OVERRIDE DEFAULT POSITIONS */
            body.mobile .pause-button-mobile {
                position: fixed !important;
                bottom: 20px !important;
                top: auto !important;
                left: 50% !important;
                right: auto !important;
                transform: translateX(-60px) !important; /* Offset left from center */
            }
            
            body.mobile .mute-button-mobile {
                position: fixed !important;
                bottom: 20px !important;
                top: auto !important;
                left: 50% !important;
                right: auto !important;
                transform: translateX(10px) !important; /* Offset right from center */
            }
            
            /* Pop-up messages area - Bottom of screen */
            body.mobile #recentDiscovery {
                bottom: 20% !important; /* Bottom 20% of screen */
                left: 50% !important;
                transform: translateX(-50%) !important;
            }
        }

        /* ===== PORTRAIT ORIENTATION ===== */
        @media (orientation: portrait) and (max-width: 1024px) {
            /* Player Card - Top Left */
            body.mobile .player-info-box {
                position: fixed !important;
                top: 60px !important;
                left: 10px !important;
                bottom: unset !important;
                right: auto !important;
                width: 160px;
                font-size: 7px;
            }
            
            /* Leaderboard - Top Right */
            body.mobile .leaderboard-box {
                position: fixed !important;
                top: 60px !important;
                right: 10px !important;
                left: auto !important;
                bottom: unset !important;
                width: 180px;
                font-size: 9px;
            }
            
            /* Discovery Feed - Left side, smaller and translucent */
            body.mobile .discovery-feed {
                left: 10px;
                top: 180px;
                transform: scale(var(--mobile-discovery-scale));
                transform-origin: top left;
                bottom: auto;
                width: 180px;
                max-height: 25vh;
                opacity: var(--mobile-discovery-opacity);
                backdrop-filter: blur(5px);
                /* Mobile gradient - lighter for better visibility */
                background: linear-gradient(
                    to right,
                    rgba(0, 0, 0, 0.4) 0%,
                    rgba(0, 0, 0, 0.2) 70%,
                    rgba(0, 0, 0, 0) 100%
                );
                backdrop-filter: blur(3px); /* Lighter blur on mobile */
            }
            
            /* Add top fade mask for mobile discovery feed */
            body.mobile .discovery-feed-inner {
                mask-image: linear-gradient(
                    to bottom,
                    transparent 0%,
                    black 15%,
                    black 85%,
                    transparent 100%
                );
                -webkit-mask-image: linear-gradient(
                    to bottom,
                    transparent 0%,
                    black 15%,
                    black 85%,
                    transparent 100%
                );
            }
            
            /* Disable hover effects on mobile */
            body.mobile .discovery-message:hover {
                transform: none;
                background: linear-gradient(
                    135deg,
                    var(--snes-dark-blue) 0%,
                    rgba(16, 32, 64, 0.95) 50%,
                    rgba(16, 32, 64, 0.85) 100%
                );
            }
            
            /* Boost Bar & Element Bank - Top */
            body.mobile .bottom-ui {
                top: 0;
                bottom: auto;
                padding: 5px 10px;
            }
            
            /* Compact boost bar for portrait */
            body.mobile .boost-bar-container {
                height: var(--mobile-boost-bar-height);
                margin-bottom: 5px;
            }
            
            body.mobile .boost-bar-frame {
                height: var(--mobile-boost-bar-height);
            }
            
            body.mobile .element-collection-bar {
                justify-content: center !important;
                margin: 0 auto !important;
            }
            
            /* Joystick - Bottom Left */
            body.mobile .virtual-joystick {
                bottom: 30px !important;
                left: 30px !important;
            }
            
            /* Boost Button - Bottom Right */
            body.mobile .boost-button {
                bottom: 30px !important;
                right: 30px !important;
                left: auto !important;
            }
            
            /* Pause & Mute - Bottom center */
            body.mobile .pause-button-mobile,
            body.mobile .mute-button-mobile {
                bottom: 20px !important;
                top: auto !important;
                left: 50% !important;
                right: auto !important;
            }
            
            body.mobile .pause-button-mobile {
                transform: translateX(-80px) !important; /* Offset left from center */
            }
            
            body.mobile .mute-button-mobile {
                transform: translateX(20px) !important; /* Offset right from center */
            }
            
            /* Pop-up messages - Bottom of screen */
            body.mobile #recentDiscovery {
                bottom: 25% !important; /* Bottom 25% of screen */
                left: 50% !important;
                top: auto !important;
                transform: translateX(-50%) !important;
            }
            
            /* Smaller stat text for portrait */
            body.mobile .stat-label {
                font-size: 7px !important;
            }
            
            body.mobile .stat-value {
                font-size: 8px !important;
            }
            
            body.mobile .leaderboard-entry {
                font-size: 9px !important;
                padding: 4px 6px !important;
                min-height: 32px !important;
            }
        }

        /* ===== MOBILE FONT SIZE REDUCTIONS ===== */
        /* Reduce game element font sizes on mobile */
        body.mobile canvas {
            /* This will be handled in the drawing code */
        }
        
        /* ===== ENHANCED MOBILE CONTROLS ===== */
        .virtual-joystick {
            background: rgba(0, 0, 0, var(--mobile-joystick-opacity));
            border: 3px solid rgba(78, 205, 196, 0.4);
            backdrop-filter: blur(5px);
        }

        .joystick-base {
            background: radial-gradient(circle, rgba(78, 205, 196, 0.15) 0%, transparent 70%);
        }

        .joystick-knob {
            background: radial-gradient(circle, rgba(78, 205, 196, 0.6) 0%, rgba(42, 117, 113, 0.6) 100%);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }

        .boost-button {
            background: radial-gradient(circle, rgba(248, 56, 248, var(--mobile-boost-opacity)) 0%, rgba(120, 40, 248, var(--mobile-boost-opacity)) 100%);
            border: 3px solid rgba(248, 216, 0, 0.6);
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            color: var(--snes-white);
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .boost-button:active {
            transform: scale(0.95) !important;
            box-shadow: 0 0 30px rgba(248, 216, 0, 1) !important;
        }

        /* ===== RESPONSIVE ELEMENT SLOTS ===== */
        @media (max-width: 768px) {
            .element-slot {
                width: 36px !important;
                height: 36px !important;
            }
            
            .element-slot .emoji {
                font-size: 20px !important;
            }
        }

        /* ===== COLLAPSIBLE LEADERBOARD ENHANCEMENT ===== */
        body.mobile .leaderboard-box {
            transition: all 0.3s ease !important;
        }

        body.mobile .leaderboard-box.collapsed {
            width: 100px !important;
            min-height: 40px !important;
        }

        body.mobile .leaderboard-box.collapsed .leaderboard-header {
            font-size: 10px !important;
            padding: 8px !important;
        }

        /* ===== IPAD MINI SPECIFIC OPTIMIZATIONS ===== */
        @media (min-width: 768px) and (max-width: 1024px) {
            /* Slightly larger controls for iPad Mini */
            .virtual-joystick,
            .boost-button {
                width: 140px !important;
                height: 140px !important;
            }
            
            body.mobile .player-info-box {
                width: 240px !important;
            }
            
            body.mobile .leaderboard-box {
                width: 260px !important;
            }
            
            .element-slot {
                width: 44px !important;
                height: 44px !important;
            }
        }

        /* ===== FPS COUNTER POSITION FIX ===== */
        body.mobile #pauseText {
            display: none !important; /* Hide keyboard shortcuts on mobile */
        }

        body.mobile #fpsCounter {
            position: fixed !important;
            top: 5px !important;
            right: 110px !important;
            font-size: 10px !important;
            color: rgba(255, 255, 255, 0.5) !important;
        }
        
        /* ===== UNIFIED LANDSCAPE POSITIONING ===== */
        @media screen and (orientation: landscape) and (max-width: 1024px) {
            /* Ensure consistent positioning without conflicts */
            body.mobile .player-info-box,
            body.mobile .leaderboard-box {
                z-index: 21; /* Above game elements but below controls */
            }
            
            /* Adjust element collection slots for landscape */
            body.mobile .element-slot {
                width: 32px;
                height: 32px;
            }
            
            body.mobile .element-slot .emoji {
                font-size: 18px;
            }
        }
        
        /* ===== MOBILE PAUSE MENU FIXES ===== */
        @media (max-width: 768px) {
            #pauseMenu {
                width: 95vw !important;
                height: 95vh !important;
                max-width: 95vw !important;
                max-height: 95vh !important;
                padding: 16px !important;
            }
            
            /* Smaller tab buttons for mobile */
            .tab-button {
                padding: 8px 12px !important;
                font-size: 8px !important;
                box-shadow: 2px 2px 0 rgba(0,0,0,0.5) !important;
            }
            
            .tab-navigation {
                gap: 4px !important;
                margin: 8px 0 !important;
                padding-bottom: 8px !important;
            }
            
            /* Fix skin grid for mobile */
            #skinGrid {
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 8px !important;
                padding-right: 5px !important;
                overflow-x: hidden !important;
            }
            
            .skin-item {
                padding: 6px !important;
            }
            
            .skin-item h5 {
                font-size: 8px !important;
                margin-top: 4px !important;
            }
            
            .skin-preview {
                width: 40px !important;
                height: 40px !important;
            }
            
            /* Fix discovery grid for mobile */
            .discovery-grid {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 8px !important;
                padding-right: 5px !important;
            }
            
            .discovery-item {
                padding: 2px !important;
            }
            
            .discovery-item .emoji {
                font-size: 24px !important;
            }
            
            .discovery-item .discovery-item-name {
                font-size: 7px !important;
            }
            
            /* Headers in pause menu */
            #pauseMenu h3 {
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }
            
            #pauseMenu h4 {
                font-size: 12px !important;
                margin-bottom: 8px !important;
            }
            
            /* Available unlocks text */
            #availableUnlocks {
                font-size: 12px !important;
                margin-bottom: 8px !important;
            }
            
            /* Discovery count text */
            #discoveryCount {
                font-size: 10px !important;
                margin-bottom: 8px !important;
            }
            
            /* Tab content adjustments */
            .tab-content {
                padding: 8px !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            /* Ensure proper scrolling */
            #skinSelection,
            #discoveryJournal {
                height: 100% !important;
                display: flex !important;
                flex-direction: column !important;
            }
            
            /* Fix button spacing in pause menu */
            #pauseMenu button {
                margin: 4px !important;
            }
            
            /* Fix leaderboard content on mobile */
            #leaderboardContent {
                padding: 10px !important;
                max-height: calc(90vh - 140px) !important;
            }
            
            /* Make leaderboard grid responsive */
            #leaderboardContent > div[style*="grid-template-columns"] {
                grid-template-columns: 40px 1fr 60px 60px 60px 50px !important;
                gap: 5px !important;
                font-size: 10px !important;
            }
            
            /* How to play content */
            #howToPlayTab {
                font-size: 10px !important;
                line-height: 1.4 !important;
            }
            
            #howToPlayTab h4 {
                font-size: 11px !important;
            }
            
            #howToPlayTab ul {
                padding-left: 15px !important;
            }
            
            /* Resume and New Game buttons */
            button[onclick*="resumeGame"],
            button[onclick*="reload"] {
                padding: 8px 20px !important;
                font-size: 12px !important;
                margin: 5px !important;
            }
            
            /* Fix the bottom button container */
            #pauseMenu > div > div[style*="margin-top: 20px"] {
                margin-top: 10px !important;
                padding-top: 10px !important;
            }
        }
        
        /* Landscape mobile specific */
        @media screen and (orientation: landscape) and (max-width: 812px) {
            #pauseMenu {
                padding: 12px !important;
            }
            
            .tab-button {
                padding: 6px 10px !important;
                font-size: 7px !important;
            }
            
            /* Even smaller grids in landscape */
            #skinGrid,
            .discovery-grid {
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 6px !important;
                overflow-x: hidden !important;
            }
            
            .skin-preview {
                width: 35px !important;
                height: 35px !important;
            }
            
            .discovery-item .emoji {
                font-size: 20px !important;
            }
            
            #pauseMenu h3 {
                font-size: 12px !important;
            }
            
            #pauseMenu h4 {
                font-size: 10px !important;
            }
        }
        
        /* Small mobile portrait (iPhone SE, etc) */
        @media (max-width: 375px) and (orientation: portrait) {
            #skinGrid,
            .discovery-grid {
                grid-template-columns: repeat(2, 1fr) !important;
            }
            
            .tab-button {
                padding: 6px 8px !important;
                font-size: 7px !important;
            }
        }
        
        /* ===== CRITICAL MOBILE POSITIONING FIX ===== */
        /* Ensure scorecard and leaderboard ALWAYS appear at TOP on mobile */
        @media (max-width: 1024px) {
            body.mobile .player-info-box {
                position: fixed !important;
                top: 20px !important;
                bottom: unset !important;
                left: 10px !important;
                right: auto !important;
            }
            
            body.mobile .leaderboard-box {
                position: fixed !important;
                top: 20px !important;
                bottom: unset !important;
                right: 10px !important;
                left: auto !important;
            }
        }
        
        /* Landscape adjustments - removed hardcoded positions that were overriding CSS variables */
    </style>
    
    <script>
        // Mobile detection (needs to be before canvas setup)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                        || ('ontouchstart' in window && navigator.maxTouchPoints > 0);
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Pixel perfect rendering
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;
        ctx.imageSmoothingQuality = 'low';
        
        // Set canvas to pixelated rendering
        canvas.style.imageRendering = 'pixelated';
        canvas.style.imageRendering = '-moz-crisp-edges';
        canvas.style.imageRendering = 'crisp-edges';
        
        // Emoji cache for performance
        const emojiCache = new Map();
        const MAX_CACHE_SIZE = 200; // Limit cache size
        
        // Performance optimization: Reusable objects to reduce allocations
        const reusableObjects = {
            vector: { x: 0, y: 0 },
            point: { x: 0, y: 0 },
            distance: { dx: 0, dy: 0, dist: 0 },
            gradient: null
        };
        
        // Performance optimization: Pre-calculated math tables
        const mathTables = {
            sin: new Float32Array(360),
            cos: new Float32Array(360)
        };
        
        // Initialize math lookup tables
        for (let i = 0; i < 360; i++) {
            const rad = (i * Math.PI) / 180;
            mathTables.sin[i] = Math.sin(rad);
            mathTables.cos[i] = Math.cos(rad);
        }
        
        // Fast math approximations
        const fastMath = {
            // Fast square root approximation (good enough for distance comparisons)
            fastSqrt: function(n) {
                if (n < 0) return NaN;
                if (n === 0) return 0;
                let x = n;
                let y = (x + n / x) / 2;
                if (Math.abs(y - x) < 0.01) return y;
                x = y;
                y = (x + n / x) / 2;
                return y;
            },
            
            // Convert angle to table index
            angleToIndex: function(angle) {
                let degrees = (angle * 180 / Math.PI) % 360;
                if (degrees < 0) degrees += 360;
                return Math.floor(degrees);
            },
            
            // Fast sin using lookup table
            sin: function(angle) {
                return mathTables.sin[this.angleToIndex(angle)];
            },
            
            // Fast cos using lookup table
            cos: function(angle) {
                return mathTables.cos[this.angleToIndex(angle)];
            }
        };
        
        function getCachedEmoji(emoji, size) {
            // Ensure size is valid
            const validSize = Math.max(1, Math.round(size) || 20);
            const key = `${emoji}_${validSize}`;
            
            if (emojiCache.has(key)) {
                return emojiCache.get(key);
            }
            
            // Check if we have pre-rendered emoji (mobile optimization)
            if (isMobile && window.getCachedEmojiTexture) {
                const preRendered = window.getCachedEmojiTexture(emoji, validSize);
                if (preRendered) {
                    emojiCache.set(key, preRendered);
                    return preRendered;
                }
            }
            
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const padding = 4; // Small padding for emoji rendering
            offscreenCanvas.width = validSize + padding * 2;
            offscreenCanvas.height = validSize + padding * 2;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            
            // Configure for crisp rendering on mobile
            if (isMobile) {
                offscreenCtx.imageSmoothingEnabled = false;
            }
            
            // Draw emoji to offscreen canvas
            offscreenCtx.font = `${validSize}px Arial`;
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.fillStyle = 'black';
            offscreenCtx.fillText(emoji, offscreenCanvas.width / 2, offscreenCanvas.height / 2);
            
            // Store in cache
            emojiCache.set(key, offscreenCanvas);
            
            // Clean up old entries if cache is too large
            if (emojiCache.size > MAX_CACHE_SIZE) {
                const firstKey = emojiCache.keys().next().value;
                emojiCache.delete(firstKey);
            }
            
            return offscreenCanvas;
        }
        
        // Make canvas fit full window
        function resizeCanvas() {
            // Mobile performance optimizations
            if (isMobile) {
                // Use optimized scale from mobile background optimizer
                let mobileScale = 0.75; // Default improved scale
                
                if (window.updateMobileCanvasScale) {
                    // Use dynamic scale based on performance
                    mobileScale = window.updateMobileCanvasScale();
                } else {
                    // Fallback to improved default
                    const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
                    mobileScale = 0.75; // Improved from 0.5 for sharper rendering
                }
                
                canvas.width = window.innerWidth * mobileScale;
                canvas.height = window.innerHeight * mobileScale;
                
                // Scale canvas to full size with CSS
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                
                // Disable image smoothing for sharper pixel art
                ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = 'high';
            } else {
                // Desktop keeps full resolution
                const scale = 1;
                canvas.width = window.innerWidth * scale;
                canvas.height = window.innerHeight * scale;
            }
            
            // Clear emoji cache on resize as sizes might change
            emojiCache.clear();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game constants
        const WORLD_SIZE = 4000;
        const SEGMENT_SIZE = 15;
        const SNAKE_SPEED = 4.761; // Increased by 15% from 4.14 (total 55.37% increase from original 3.0)
        const TURN_SPEED = 0.08;
        const ELEMENT_SIZE = 20;
        
        // Convert world coordinates to screen coordinates with zoom
        function worldToScreen(x, y) {
            return {
                x: (x - camera.x) * cameraZoom + canvas.width / 2,
                y: (y - camera.y) * cameraZoom + canvas.height / 2
            };
        }
        
        // Viewport culling helper
        function isInViewport(x, y, margin = 100) {
            const screen = worldToScreen(x, y);
            
            return screen.x >= -margin && 
                   screen.x <= canvas.width + margin && 
                   screen.y >= -margin && 
                   screen.y <= canvas.height + margin;
        }
        
        // Game state
        let gameStarted = false;
        let paused = false;
        let controlScheme = 'arrows';
        let gameMode = 'infinite'; // 'discovery', 'points', or 'infinite'
        let gameWon = false; // Track if victory has been achieved
        let gameTarget = 0; // Target value for victory
        let camera = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
        let cameraZoom = isMobile ? 0.5 : 1.0; // 0.5 = zoom out by 100% (double visible area) for mobile
        
        // Game loop timing variables
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 0;
        let accumulator = 0;
        let playerSnake = null;
        let snakes = [];
        let lastDiscoveredElement = null;
        let highScore = parseInt(localStorage.getItem('highScore') || '0');
        let gameStartTime = Date.now();
        let bestRank = 0;
        let playerRespawnTimer = 0; // Player respawn countdown
        let revivesRemaining = 3; // Number of revives left in current game
        let savedSnakeLength = 0; // Store snake length for revive
        let savedSnakeScore = 0; // Store snake score for revive
        let comboStreak = 0; // Track consecutive combinations
        let animationFrameId = null; // Track the animation frame to prevent multiple loops
        
        // Enhanced mobile detection including iPads
        function isTabletOrMobile() {
            return window.matchMedia("(max-width: 1024px)").matches || 
                   window.matchMedia("(pointer: coarse)").matches ||
                   /iPad|iPhone|iPod|Android/i.test(navigator.userAgent);
        }
        
        // Show rotate device message for mobile users
        function showRotateDeviceMessage() {
            // Check if message already exists
            if (document.getElementById('rotate-device-message')) return;
            
            const rotateMsg = document.createElement('div');
            rotateMsg.id = 'rotate-device-message';
            rotateMsg.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.95);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                font-family: 'Press Start 2P', monospace;
                color: #fff;
                text-align: center;
                padding: 20px;
            `;
            rotateMsg.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 30px; animation: rotate 2s ease-in-out infinite;">📱</div>
                <div style="font-size: 14px; line-height: 1.8; margin-bottom: 10px;">Please rotate your device</div>
                <div style="font-size: 11px; margin-top: 10px; color: #4ecdc4;">Infinite Snake is best in landscape</div>
            `;
            
            // Add rotation animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes rotate {
                    0% { transform: rotate(0deg); }
                    25% { transform: rotate(-90deg); }
                    50% { transform: rotate(-90deg); }
                    75% { transform: rotate(0deg); }
                    100% { transform: rotate(0deg); }
                }
            `;
            rotateMsg.appendChild(style);
            
            document.body.appendChild(rotateMsg);
            
            // Remove message when device is rotated
            const checkOrientation = () => {
                if (window.innerWidth > window.innerHeight) {
                    const msg = document.getElementById('rotate-device-message');
                    if (msg) msg.remove();
                    window.removeEventListener('orientationchange', checkOrientation);
                    window.removeEventListener('resize', checkOrientation);
                }
            };
            window.addEventListener('orientationchange', checkOrientation);
            window.addEventListener('resize', checkOrientation);
        }
        
        // Force landscape orientation for mobile devices
        function lockToLandscape() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').then(() => {
                    console.log('Successfully locked to landscape mode');
                }).catch((err) => {
                    console.log('Could not lock orientation:', err);
                    // Still check and show rotate message if needed
                    checkAndShowRotateMessage();
                });
            } else {
                // Fallback for browsers without orientation API
                console.log('Screen orientation API not supported');
                checkAndShowRotateMessage();
            }
        }
        
        // Check orientation and show rotate message if needed
        function checkAndShowRotateMessage() {
            if (window.innerHeight > window.innerWidth) {
                showRotateDeviceMessage();
            }
        }
        
        // Alchemy Vision power-up
        let alchemyVisionPowerUps = [];
        let alchemyVisionActive = false;
        let alchemyVisionTimer = 0;
        let lastAlchemyVisionSpawn = 0;
        const ALCHEMY_VISION_DURATION = 30000; // 30 seconds
        const ALCHEMY_VISION_SPAWN_INTERVAL = 120000; // 2 minutes
        const ALCHEMY_VISION_SPAWN_COUNT = 3; // Number of power-ups to spawn at once
        
        // Void Orb mechanic
        let voidOrbs = [];
        let lastVoidOrbSpawn = 0;
        const VOID_ORB_SPAWN_INTERVAL = 75000; // 75 seconds (25% less common)
        const VOID_ORB_SPAWN_COUNT = 4; // Number of void orbs to maintain on map
        
        // Catalyst Gem mechanic
        let catalystGems = [];
        let lastCatalystGemSpawn = 0;
        const CATALYST_GEM_SPAWN_INTERVAL = 45000; // 45 seconds (doubled spawn rate)
        const CATALYST_GEM_SPAWN_COUNT = 3; // Number of catalyst gems to maintain on map
        let catalystSpawnedElements = []; // Track elements spawned by catalyst for visual effect
        
        // AI Personality Types
        const AI_PERSONALITIES = {
            AGGRESSIVE: {
                name: 'Aggressive',
                huntingPriority: 0.95,      // Almost always hunts
                comboPriority: 0.05,        // Rarely cares about combos
                riskTolerance: 0.95,        // Very high risk tolerance
                boostThreshold: 0.2,        // Boosts frequently
                chaseDistance: 500,         // Long chase range
                fleeThreshold: 2.0,         // Only flee if enemy is 2x larger
                preyRatioMax: 1.2,          // Hunt snakes up to 1.2x their size
                collisionAvoidanceRadius: 120, // Increased from 60
                dangerZoneRadius: 200,      // Early warning radius
                aggressionMultiplier: 2.0,  // How much to prioritize hunting
                elementIgnoreChance: 0.7,   // 70% chance to ignore elements when hunting
                avoidanceStrength: 0.4,     // How strongly to avoid collisions
                predictiveLookAhead: 0.5,   // Look 0.5 seconds ahead
                bodyAvoidanceMultiplier: 0.7 // Reduced body avoidance for aggressive play
            },
            COMBO_FOCUSED: {
                name: 'Combo Master',
                huntingPriority: 0.05,      // Almost never hunts
                comboPriority: 0.95,        // Always seeks combos
                riskTolerance: 0.2,         // Low risk tolerance
                boostThreshold: 0.7,        // Rarely boosts
                chaseDistance: 50,          // Very short chase range
                fleeThreshold: 0.9,         // Flee from 90% size snakes
                preyRatioMax: 0.5,          // Only hunt snakes half their size
                collisionAvoidanceRadius: 250, // Increased from 150
                dangerZoneRadius: 350,      // Large early warning
                aggressionMultiplier: 0.2,
                elementIgnoreChance: 0.0,   // Never ignores elements
                avoidanceStrength: 0.8,     // Strong avoidance
                predictiveLookAhead: 1.0,   // Look 1 second ahead
                bodyAvoidanceMultiplier: 1.5 // Extra careful around bodies
            },
            BALANCED: {
                name: 'Balanced',
                huntingPriority: 0.5,
                comboPriority: 0.5,
                riskTolerance: 0.5,
                boostThreshold: 0.5,
                chaseDistance: 250,
                fleeThreshold: 1.3,
                preyRatioMax: 0.8,          // Hunt snakes up to 0.8x their size
                collisionAvoidanceRadius: 180, // Increased from 100
                dangerZoneRadius: 280,      // Moderate early warning
                aggressionMultiplier: 1.0,
                elementIgnoreChance: 0.3,
                avoidanceStrength: 0.6,     // Moderate avoidance
                predictiveLookAhead: 0.7,   // Look 0.7 seconds ahead
                bodyAvoidanceMultiplier: 1.0 // Standard body avoidance
            },
            CAUTIOUS: {
                name: 'Cautious',
                huntingPriority: 0.0,       // Never hunts
                comboPriority: 1.0,         // Only focuses on elements
                riskTolerance: 0.1,         // Very low risk
                boostThreshold: 0.85,       // Almost never boosts
                chaseDistance: 0,           // Never chases
                fleeThreshold: 0.8,         // Flee from 80% size snakes
                preyRatioMax: 0.0,          // Never considers hunting
                collisionAvoidanceRadius: 300, // Increased from 200
                dangerZoneRadius: 400,      // Very large early warning
                aggressionMultiplier: 0.0,  // No aggression
                elementIgnoreChance: 0.0,
                avoidanceStrength: 1.0,     // Maximum avoidance
                predictiveLookAhead: 1.2,   // Look 1.2 seconds ahead
                bodyAvoidanceMultiplier: 2.0, // Very cautious around bodies
                playerAvoidanceRadius: 600  // Stay far away from player
            },
            OPPORTUNIST: {
                name: 'Opportunist',
                huntingPriority: 0.8,       // High hunting when safe
                comboPriority: 0.2,
                riskTolerance: 0.6,
                boostThreshold: 0.3,
                chaseDistance: 350,
                fleeThreshold: 1.1,         // Careful about size matchups
                preyRatioMax: 0.7,          // Hunt snakes up to 0.7x their size
                collisionAvoidanceRadius: 150, // Increased from 80
                dangerZoneRadius: 250,      // Moderate early warning
                aggressionMultiplier: 1.5,
                elementIgnoreChance: 0.5,
                preferWeakTargets: true,    // Specifically targets smaller/wounded snakes
                avoidanceStrength: 0.5,     // Moderate avoidance
                predictiveLookAhead: 0.6,   // Look 0.6 seconds ahead
                bodyAvoidanceMultiplier: 0.8 // Slightly reduced for opportunistic strikes
            }
        };
        
        // AI respawn cooldown tracking
        let aiRespawnQueue = [];
        const AI_RESPAWN_COOLDOWN = 5000; // 5 seconds
        const MAX_AI_SNAKES = 6; // Increased from 5 to 6
        
        // Track used AI skins to prevent duplicates
        let usedAISkins = new Set();
        
        // Track AI snake data for respawning with scores
        let aiSnakeDataMap = new Map();
        
        // Personality colors for name display
        const PERSONALITY_COLORS = {
            'Aggressive': '#ff4444',      // Red
            'Combo Master': '#44ff44',    // Green
            'Cautious': '#ffff44',        // Yellow
            'Balanced': '#4444ff',        // Blue
            'Opportunist': '#ff8844'      // Orange
        };
        
        // Space effects
        let staticStars = [];
        let shootingStars = [];
        let lastShootingStarTime = 0;
        
        // Pixel art star layers for parallax
        const pixelStarLayers = [
            { stars: [], speed: 0.05, size: 1, color: '#666', count: 100 },  // Far
            { stars: [], speed: 0.1, size: 1, color: '#999', count: 80 },   // Mid
            { stars: [], speed: 0.15, size: 2, color: '#CCC', count: 60 },   // Near
            { stars: [], speed: 0.2, size: 2, color: '#FFF', count: 40 }    // Close
        ];
        
        // Pixel nebulae - many smaller, organic shapes
        const pixelNebulae = [];
        const nebulaCanvases = new Map(); // Cache for pre-rendered nebulae
        
        // Generate many smaller nebulae across the world
        for (let i = 0; i < 25; i++) {
            const size = 250 + Math.random() * 350; // Use same size for width and height for circular nebulae
            pixelNebulae.push({
                x: Math.random() * WORLD_SIZE,
                y: Math.random() * WORLD_SIZE,
                width: size,
                height: size,
                color: ['#4B0082', '#8B008B', '#191970', '#483D8B', '#6A0DAD', '#9400D3'][Math.floor(Math.random() * 6)],
                density: 0.25 + Math.random() * 0.25, // Increased density for better visibility
                clusters: [] // Will store random pixel clusters for organic shape
            });
        }
        
        // Pixel planets - many smaller planets with grid-based distribution
        const pixelPlanets = [];
        // Generate planets in a 5x4 grid for uniform distribution
        const gridCols = 5;
        const gridRows = 4;
        const cellWidth = WORLD_SIZE / gridCols;
        const cellHeight = WORLD_SIZE / gridRows;
        
        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const planetColors = [
                    { color1: '#5A3A0D', color2: '#704020' }, // Darker browns
                    { color1: '#2E5A74', color2: '#3F6E80' }, // Darker blues
                    { color1: '#B24430', color2: '#B23000' }, // Darker reds
                    { color1: '#165916', color2: '#004400' }, // Darker greens
                    { color1: '#9A7016', color2: '#856008' }, // Darker golds
                    { color1: '#4A5A6A', color2: '#1F2F2F' }, // Darker grays
                    { color1: '#B2497F', color2: '#B21066' }, // Darker pinks
                    { color1: '#009091', color2: '#005B5B' }, // Darker cyans
                    { color1: '#654E92', color2: '#4A0D7A' }, // Darker purples
                    { color1: '#B26200', color2: '#B24430' }, // Darker oranges
                    { color1: '#229022', color2: '#165916' }  // Darker lime greens
                ];
                const colors = planetColors[Math.floor(Math.random() * planetColors.length)];
                
                // Place planet randomly within its grid cell
                const x = col * cellWidth + (cellWidth * 0.2) + (Math.random() * cellWidth * 0.6);
                const y = row * cellHeight + (cellHeight * 0.2) + (Math.random() * cellHeight * 0.6);
                
                pixelPlanets.push({
                    x: x,
                    y: y,
                    radius: 20 + Math.random() * 40, // Varied planet sizes (20-60)
                    color1: colors.color1,
                    color2: colors.color2,
                    rings: Math.random() > 0.7, // 30% chance of rings
                    opacity: 0.6 // 40% transparency
                });
            }
        }
        
        // Pixel asteroids - will be populated dynamically
        const pixelAsteroids = [];
        
        // Asteroid clusters for more interesting space fields
        const asteroidClusters = [];
        // Generate 8-10 asteroid clusters
        const numClusters = 8 + Math.floor(Math.random() * 3);
        for (let i = 0; i < numClusters; i++) {
            const clusterX = Math.random() * WORLD_SIZE;
            const clusterY = Math.random() * WORLD_SIZE;
            const clusterRadius = 200 + Math.random() * 100; // 200-300 pixel radius
            const numAsteroids = 15 + Math.floor(Math.random() * 11); // 15-25 asteroids per cluster
            
            const cluster = {
                x: clusterX,
                y: clusterY,
                radius: clusterRadius,
                asteroids: []
            };
            
            for (let j = 0; j < numAsteroids; j++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * clusterRadius;
                const asteroidX = clusterX + Math.cos(angle) * distance;
                const asteroidY = clusterY + Math.sin(angle) * distance;
                
                cluster.asteroids.push({
                    x: asteroidX,
                    y: asteroidY,
                    size: 2 + Math.random() * 6, // Smaller asteroids in clusters (2-8 pixels)
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    driftX: (Math.random() - 0.5) * 0.1,
                    driftY: (Math.random() - 0.5) * 0.1
                });
            }
            
            asteroidClusters.push(cluster);
        }
        
        // Nebula border effect variables
        let borderParticles = [];
        let animationTime = 0;
        const MAX_BORDER_PARTICLES = isMobile ? 50 : 150; // Reduced for mobile
        
        // Element database
        let elementDatabase = {}; // Keep for compatibility
        let combinations = {}; // Keep for compatibility
        let discoveredElements = new Set(); // Start with no discoveries - global pool of all discovered elements
        let playerDiscoveredElements = new Set(); // Player-only discoveries for UI and progression
        
        // All-time discoveries (persistent across sessions)
        let allTimeDiscoveries = new Map(); // Map of element -> recipe
        
        // Element progression system
        let recentlySpawnedElements = []; // Track last spawned elements to prevent clustering
        const MAX_SPAWN_HISTORY = 20; // Remember last 20 spawned elements
        let recentlyDiscoveredElements = new Map(); // Track recently discovered elements with timestamp
        const DISCOVERY_ECHO_DURATION = 30000; // 30 seconds of boosted spawn rate
        
        // Grid-based spawning for even distribution
        const ELEMENT_GRID_SIZE = 400; // Divide world into 400x400 cells (10x10 grid)
        let elementGrid = new Map(); // Track elements per grid cell
        const MIN_ELEMENTS_PER_CELL = 2; // Minimum elements per grid cell
        const MAX_ELEMENTS_PER_CELL = 5; // Maximum elements per grid cell
        const TARGET_ELEMENT_COUNT = isMobile ? 100 : 200; // Further reduced for mobile performance
        
        // Snake names data
        let snakeNameData = null;
        
        // Boss System
        const BOSS_TYPES = {
            PYRAXIS: {
                name: "Pyraxis the Molten",
                element: "fire",
                elementId: 3, // Fire element ID
                emoji: "🔥",
                color: "#ff4444",
                maxHealth: 5,
                attackCooldown: 4000,
                defeated: false,
                skin: 'pyraxis',
                attackSound: 'sounds/magma-roar.mp3',
                laughSound: 'sounds/pyraxis-laugh.mp3'
            },
            ABYSSOS: {
                name: "Abyssos the Deep One",
                element: "water",
                elementId: 1, // Water element ID
                emoji: "🌊",
                color: "#4444ff",
                maxHealth: 5,
                attackCooldown: 6000,
                defeated: false,
                skin: 'abyssos',
                attackSound: 'sounds/negative-low-pitch.mp3',
                laughSound: 'sounds/abyssos-laugh.mp3'
            },
            OSSEUS: {
                name: "Osseus the Bone Sovereign",
                element: "earth",
                elementId: 0, // Earth element ID
                emoji: "🗿",
                color: "#8b4513",
                maxHealth: 5,
                attackCooldown: 5000,
                defeated: false,
                skin: 'osseus',
                attackSound: 'sounds/boom-explosion.mp3',
                laughSound: 'sounds/osseus-laugh.mp3'
            },
            ZEPHYRUS: {
                name: "Zephyrus the Storm Caller",
                element: "air",
                elementId: 2, // Air element ID
                emoji: "💨",
                color: "#87ceeb",
                maxHealth: 5,
                attackCooldown: 8000, // Increased to allow element repopulation after vacuum
                defeated: false,
                skin: 'zephyrus',
                attackSound: 'sounds/power-surge.mp3',
                laughSound: 'sounds/zephyrus-laugh.mp3'
            }
        };
        
        // Boss state management
        let currentBoss = null;
        let bossEncounterActive = false;
        let bossSpawnRanges = [
            { min: 50000, max: 75000 },
            { min: 125000, max: 175000 },
            { min: 225000, max: 300000 },
            { min: 500000, max: 600000 }
        ];
        let nextBossSpawnIndex = 0;
        let defeatedBosses = new Set();
        let bossesDefeatedThisCycle = 0;
        let bossIsUndead = false;
        let bossIntroMusic = null;
        let bossBattleMusic = null;
        let bossHealthBar = null;
        let bossHealthBarContainer = null;
        let bossNameDisplay = null;
        let elementBankSlots = 6; // Start with 6 slots, expandable to 12
        let bossDamageFlashTimer = 0;
        let bossStunTimer = 0;
        let bossProjectiles = [];
        let bossDamageCooldown = 0;
        let shockwaves = [];
        let bossScreenShakeTimer = 0;
        let bossScreenShakeIntensity = 0;
        let elementVacuumActive = false;
        let elementVacuumTimer = 0;
        let vacuumedElements = []; // Store elements being sucked into void
        let damageNumbers = []; // Floating damage numbers
        let bossFissures = []; // Ground fissures for Osseus
        
        // Skin system - merge old system with new data from skinData.js
        let skinMetadata = {
            'snake-default-green': { name: 'Basic Boy', unlocked: true, colors: ['#75d18e', '#6abf81'] },
            'neko': { name: 'Lil Beans (Beta Perk)', unlocked: true, colors: ['#c6c6cb', '#c3c3e7'] },
            '35mm': { name: 'Ansel 35', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'Frank': { name: 'Franklin', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'af-one': { name: "Scuffy", unlocked: false, colors: ['#e74c3c', '#e23b28'] },
            'barbi': { name: 'Margot', unlocked: false, colors: ['#ff69b4', '#ff1493'] },
            'boat-mcboatface': { name: 'Boaty McBoatface', unlocked: false, colors: ['#3498db', '#2980b9'] },
            'camera-guy': { name: 'The Resistance', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'coffee': { name: 'Caffeine Fiend', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'controller': { name: 'Little Bro', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'diet-cola': { name: 'Cola Crusader', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'dog': { name: 'Good Boy', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'donut': { name: 'Sprinkles', unlocked: false, colors: ['#daa520', '#ff69b4'] },
            'flame': { name: 'Hot Head', unlocked: false, colors: ['#ff8c00', '#ffd700'] },
            'football': { name: 'MVP', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'fries': { name: 'Sir Dips-a-lot', unlocked: false, colors: ['#e74c3c', '#ffd700'] },
            'green-dragon': { name: 'World Muncher', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'handheld-game': { name: 'The Pocketeer', unlocked: false, colors: ['#393b32', '#6a7473'] },
            'hotdog': { name: 'Big Dawg', unlocked: false, colors: ['#f8c83f', '#f8c83f'] },
            'infinity-glove': { name: 'Snappy', unlocked: false, colors: ['#6c7dcd', '#6c7dcd'] },
            'kid-car': { name: 'Speed Demon Jr.', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'lovecraft': { name: 'Eldritch Horror', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'nyan': { name: 'Pastry Cat', unlocked: false, colors: ['#e74c3c', '#ff8c00', '#ffd700', '#2ecc71', '#3498db', '#9b59b6'] },
            'pizza': { name: 'Tony Pep', unlocked: false, colors: ['#f5bf48', '#f39c12'] },
            'potato': { name: 'Spud Bud', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'racer': { name: 'Speed Demon', unlocked: false, colors: ['#1f2d35', '#e1e7ea'] },
            'ramen': { name: 'Noodle Master', unlocked: false, colors: ['#f3c33e', '#f3c33e'] },
            'red-dragon': { name: 'Ralph', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'robot': { name: 'Metal Boi', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'santa': { name: 'Ho Ho Hose', unlocked: false, colors: ['#e34c4a', '#f2ede1'] },
            'saturn': { name: 'Ring Leader', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'skibidi': { name: 'Mr. Swirley', unlocked: false, colors: ['#ecf0f1', '#bdc3c7'] },
            'snake-2': { name: 'Snek II', unlocked: false, colors: ['#78a060', '#5f804c'] },
            'space-cadet': { name: 'Cosmic Ray', unlocked: false, colors: ['#34495e', '#2c3e50'] },
            'tornado': { name: 'Whirlwind', unlocked: false, colors: ['#1790ff', '#3b9cf6'] },
            'tv': { name: 'CRT Surfer', unlocked: false, colors: ['#89b6c7', '#bedeeb'] },
            'unicorn': { name: 'Tres Commas', unlocked: false, colors: ['#ff69b4', '#ffd700'] },
            'brick-man': { name: 'The Special', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'buffalo': { name: "Billy Blue", unlocked: false, colors: ['#3498db', '#2980b9'] },
            'clock': { name: 'Time-Out', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'floral': { name: 'Bo Kay', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'gnome': { name: 'World Traveler', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'mac': { name: 'Woz', unlocked: false, colors: ['#f5deb3', '#e6d7c3'] },
            'murica': { name: "'Murica", unlocked: false, colors: ['#ecf0f1', '#f2eeed'] },
            'pod-player': { name: 'Poddington', unlocked: false, colors: ['#87ceeb', '#5f9ea0'] },
            'whale': { name: 'Spout', unlocked: false, colors: ['#3498db', '#2980b9'] },
            // Boss skins (not available for players or AI)
            'pyraxis': { name: 'Pyraxis the Molten', unlocked: false, colors: ['#ff4444', '#cc0000'], isBoss: true },
            'abyssos': { name: 'Abyssos the Deep One', unlocked: false, colors: ['#4444ff', '#0000cc'], isBoss: true },
            'osseus': { name: 'Osseus the Bone Sovereign', unlocked: false, colors: ['#8b4513', '#654321'], isBoss: true },
            'zephyrus': { name: 'Zephyrus the Storm Caller', unlocked: false, colors: ['#87ceeb', '#5f9ea0'], isBoss: true }
        };
        
        // Merge with new skin data if available
        if (window.SKIN_DATA && window.skinIdConverter) {
            // Create a merged metadata object
            const mergedMetadata = {};
            
            // First, convert all old IDs to maintain compatibility
            Object.keys(skinMetadata).forEach(oldId => {
                mergedMetadata[oldId] = { ...skinMetadata[oldId] };
                
                // Try to find corresponding new data
                const newId = window.skinIdConverter.toNewId(oldId);
                if (newId && window.SKIN_DATA[newId]) {
                    // Merge in new properties while keeping old ones
                    mergedMetadata[oldId] = {
                        ...mergedMetadata[oldId],
                        ...window.SKIN_DATA[newId],
                        // Keep the original colors as they're used for rendering
                        colors: skinMetadata[oldId].colors,
                        // Keep the original unlocked state
                        unlocked: skinMetadata[oldId].unlocked
                    };
                }
            });
            
            // Add any skins that only exist in the new system (like boss skins with new IDs)
            Object.keys(window.SKIN_DATA).forEach(newId => {
                const oldId = window.skinIdConverter.toOldId(newId);
                if (!oldId || !mergedMetadata[oldId]) {
                    // This is a new skin not in the old system
                    mergedMetadata[newId] = {
                        ...window.SKIN_DATA[newId],
                        unlocked: false,
                        // Generate default colors if not provided
                        colors: window.SKIN_DATA[newId].colors || ['#888888', '#666666']
                    };
                }
            });
            
            skinMetadata = mergedMetadata;
        }
        
        const aiSkins = Object.keys(skinMetadata).filter(skin => skinMetadata[skin] && !skinMetadata[skin].isBoss); // All non-boss skins available for AI
        let currentPlayerSkin = 'snake-default-green';
        let unlockedSkins = new Set(['snake-default-green']);
        let availableUnlocks = 0;
        let skinImages = {}; // Cache for loaded skin images
        
        // Load skin system from localStorage
        function loadSkinData() {
            const saved = localStorage.getItem('unlockedSkins');
            if (saved) {
                unlockedSkins = new Set(JSON.parse(saved));
            }
            
            const savedCurrent = localStorage.getItem('currentSkin');
            if (savedCurrent && unlockedSkins.has(savedCurrent)) {
                currentPlayerSkin = savedCurrent;
                // Update player portrait on load
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    // Boss skins are in a different directory
                    if (skinMetadata[currentPlayerSkin] && skinMetadata[currentPlayerSkin].isBoss) {
                        portrait.src = `assets/boss-skins/${currentPlayerSkin}.png`;
                    } else {
                        portrait.src = `skins/${currentPlayerSkin}.png`;
                    }
                }
            }
            
            // Update metadata with ID conversion support
            for (const skin of unlockedSkins) {
                // Try direct match first
                if (skinMetadata[skin]) {
                    skinMetadata[skin].unlocked = true;
                } else if (window.skinIdConverter) {
                    // Try converting from new ID to old ID
                    const oldId = window.skinIdConverter.toOldId(skin);
                    if (oldId && skinMetadata[oldId]) {
                        skinMetadata[oldId].unlocked = true;
                    }
                    // Also try converting from old ID to new ID
                    const newId = window.skinIdConverter.toNewId(skin);
                    if (newId && skinMetadata[newId]) {
                        skinMetadata[newId].unlocked = true;
                    }
                }
            }
        }
        
        // Save skin data
        function saveSkinData() {
            localStorage.setItem('unlockedSkins', JSON.stringify(Array.from(unlockedSkins)));
            localStorage.setItem('currentSkin', currentPlayerSkin);
        }
        
        // Preload skin images
        function preloadSkins() {
            const allSkins = Object.keys(skinMetadata); // Load all skins including boss skins
            allSkins.forEach(skin => {
                const img = new Image();
                img.onerror = function() {
                    console.warn(`Failed to load skin: ${skin}.png`);
                    this.error = true;
                };
                // Boss skins are in a different directory
                if (skinMetadata[skin].isBoss) {
                    img.src = `assets/boss-skins/${skin}.png`;
                } else {
                    img.src = `skins/${skin}.png`;
                }
                skinImages[skin] = img;
            });
        }
        
        // Calculate available unlocks based on high score
        function calculateAvailableUnlocks() {
            let unlocks = 0;
            if (highScore >= 50000) unlocks++;
            if (highScore >= 100000) unlocks++;
            if (highScore >= 150000) unlocks++;
            if (highScore > 150000) {
                unlocks += Math.floor((highScore - 150000) / 250000);
            }
            
            // Subtract already unlocked skins (minus the default)
            const alreadyUnlocked = unlockedSkins.size - 1;
            availableUnlocks = Math.max(0, unlocks - alreadyUnlocked);
            return availableUnlocks;
        }
        
        // Load all-time discoveries from localStorage
        function loadAllTimeDiscoveries() {
            const saved = localStorage.getItem('allTimeDiscoveries');
            if (saved) {
                const data = JSON.parse(saved);
                allTimeDiscoveries = new Map(data);
            } else {
                // Initialize with base elements using numeric IDs
                allTimeDiscoveries.set(0, 'Base Element');  // Earth
                allTimeDiscoveries.set(1, 'Base Element');  // Water
                allTimeDiscoveries.set(2, 'Base Element');  // Air
                allTimeDiscoveries.set(3, 'Base Element');  // Fire
                saveAllTimeDiscoveries();
            }
        }
        
        // Save all-time discoveries to localStorage
        function saveAllTimeDiscoveries() {
            const data = Array.from(allTimeDiscoveries.entries());
            localStorage.setItem('allTimeDiscoveries', JSON.stringify(data));
        }
        
        // Music system
        // Background music tracks - see CREDITS.md for full attribution
        // All tracks produced by ZapSplat under Standard License
        let currentTrack = null;
        let musicVolume = 0.3;
        let musicMuted = false;
        let musicShouldBePlaying = false; // Track whether music is intended to play
        const musicTracks = [
            'bright-white-lights.mp3',
            'last-ones-standing.mp3', 
            'good-times.mp3',
            'summer-haze.mp3',
            'on-the-up.mp3',
            'headliner.mp3'
        ];
        let availableTracks = [];
        
        
        // Input handling
        const keys = {};
        let mouseAngle = 0;
        let mouseDown = false;
        let mouseMovedRecently = false;
        let mouseMovedTimer = null;
        
        // Combination animation state
        let combinationAnimationState = {
            isAnimating: false,
            combiningIndices: [],
            animationStartTime: 0,
            newElementIndex: -1
        };
        
        // Mobile detection removed - using global definition
        
        // Mobile controls state
        let joystickActive = false;
        let joystickBase = { x: 0, y: 0 };
        let joystickKnob = { x: 0, y: 0 };
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleMusic();
            }
            
            // Quick respawn/revive with Space key
            if (e.key === ' ' && playerSnake && !playerSnake.alive && playerRespawnTimer > 0) {
                const respawnOverlay = document.getElementById('respawnOverlay');
                if (respawnOverlay && respawnOverlay.style.display !== 'none') {
                    e.preventDefault(); // Prevent page scroll
                    handleReviveOrRespawn();
                }
            }
            
            // Resume pending music on first interaction
            if (window.pendingMusicTrack && !musicMuted) {
                window.pendingMusicTrack.play().then(() => {
                }).catch(err => {
                    console.error('Failed to resume music:', err);
                });
                window.pendingMusicTrack = null;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        window.addEventListener('mousemove', (e) => {
            if (controlScheme === 'mouse' && playerSnake) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
                
                // Track that mouse has moved recently
                mouseMovedRecently = true;
                
                // Clear existing timer
                if (mouseMovedTimer) {
                    clearTimeout(mouseMovedTimer);
                }
                
                // Set timer to reset mouseMovedRecently after inactivity
                mouseMovedTimer = setTimeout(() => {
                    mouseMovedRecently = false;
                }, 1000); // Reset after 1 second of no mouse movement
            }
        });
        
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = true;
                
                // Spawn shooting star on click (like in demo)
                if (gameStarted) {
                    shootingStars.push(new ShootingStar());
                }
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = false;
            }
        });
        
        // Touch event for mobile audio resume
        window.addEventListener('touchstart', (e) => {
            // Resume pending music on first touch interaction
            if (window.pendingMusicTrack && !musicMuted) {
                console.log('[AUDIO] Attempting to resume pending music on touch');
                window.pendingMusicTrack.play().then(() => {
                    console.log('[AUDIO] Pending music resumed on touch');
                    currentTrack = window.pendingMusicTrack;
                    window.pendingMusicTrack = null;
                }).catch(err => {
                    console.error('[AUDIO] Failed to resume music on touch:', err);
                });
            }
            
            // Also try to resume if music should be playing but isn't
            if (musicShouldBePlaying && !musicMuted && gameStarted && !currentTrack) {
                console.log('[AUDIO] Music should be playing but no current track, starting new track on touch');
                playRandomTrack();
            }
        }, { passive: true });
        
        // Initialize player name input when DOM is ready
        function initializePlayerNameInput() {
            const playerNameInput = document.getElementById('playerNameInput');
            let playerName = localStorage.getItem('playerName');
            let isGeneratedName = false;
            
            // Generate random name if none exists
            if (!playerName) {
                if (window.nameGenerator) {
                    playerName = window.nameGenerator.generateRandomName();
                    isGeneratedName = true;
                } else {
                    // Fallback if nameGenerator not loaded yet
                    playerName = 'Player' + Math.floor(Math.random() * 10000);
                    isGeneratedName = true;
                }
            }
            
            // Set the input value
            if (playerNameInput && playerName) {
                playerNameInput.value = playerName;
            }
            
            // Clear input on focus if it's a generated name
            if (playerNameInput) {
                playerNameInput.addEventListener('focus', function() {
                    if (isGeneratedName && this.value === playerName) {
                        this.value = '';
                    }
                });
                
                // Save name on blur
                playerNameInput.addEventListener('blur', function() {
                    if (this.value.trim()) {
                        localStorage.setItem('playerName', this.value.trim());
                        isGeneratedName = false;
                    }
                });
            }
        }
        
        // Call initialization after a small delay to ensure nameGenerator is loaded
        setTimeout(initializePlayerNameInput, 100);
        
        // Splash screen
        document.getElementById('startButton').addEventListener('click', async () => {
            playUISound();
            
            // Save player name
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                const name = nameInput.value.trim() || window.nameGenerator.generateRandomName();
                localStorage.setItem('playerName', name);
                window.currentPlayerName = name;
            }
            
            // Check if mobile and initialize renderers
            if (isTabletOrMobile()) {
                try {
                    await initializeMobileRenderers();
                } catch (error) {
                    console.error('Failed to initialize mobile renderers:', error);
                }
            } else {
                // Desktop: Just hide splash screen
                document.getElementById('splashScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('splashScreen').style.display = 'none';
                    document.getElementById('gameModeSelect').style.display = 'block';
                    // Fade in game mode select
                    setTimeout(() => {
                        document.getElementById('gameModeSelect').style.opacity = '1';
                    }, 50);
                }, 300);
            }
        });
        
        // Game mode selection
        function selectVictoryMode(mode, target) {
            playUISound();
            gameMode = mode;
            gameTarget = target;
            
            // Set default control scheme to mouse
            controlScheme = 'mouse';
            
            // Start the game immediately
            startGameTransition();
        }
        
        function startGameTransition() {
            const gameModeSelect = document.getElementById('gameModeSelect');
            const gameCanvas = document.getElementById('gameCanvas');
            
            // Add transition styles
            gameCanvas.style.transition = 'opacity 0.3s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Fade out game mode select
            gameModeSelect.style.opacity = '0';
            
            setTimeout(() => {
                gameModeSelect.style.display = 'none';
                stopGame(); // Ensure clean state before starting
                startGame();
                
                // Show canvas and UI
                setTimeout(() => {
                    gameCanvas.style.opacity = '1';
                    document.getElementById('ui').style.opacity = '1';
                }, 100);
            }, 300);
        }
        
        function selectControls(scheme) {
            controlScheme = scheme;
            // Use the same simplified transition
            startGameTransition();
        }
        
        // Load snake names
        async function loadSnakeNames() {
            try {
                const response = await fetch('snake-names.json');
                const data = await response.json();
                snakeNameData = data;
            } catch (error) {
                console.error('Failed to load snake names:', error);
                // Fallback data
                snakeNameData = {
                    firstParts: ['Sir', 'Lord', 'Captain', 'Master', 'Swift', 'Mighty', 'Sneaky'],
                    secondParts: ['Slithers', 'McSlitherface', 'the Magnificent', 'Noodle', 'Supreme']
                };
            }
        }
        
        // Generate random snake name
        function generateSnakeName() {
            if (!snakeNameData) {
                return `Snake${Math.floor(Math.random() * 1000)}`;
            }
            const first = snakeNameData.firstParts[Math.floor(Math.random() * snakeNameData.firstParts.length)];
            const second = snakeNameData.secondParts[Math.floor(Math.random() * snakeNameData.secondParts.length)];
            return `${first} ${second}`;
        }
        
        // Load element database
        async function loadElements() {
            try {
                // Wait for the new element system to load
                if (!window.elementLoader || !window.elementLoader.isLoaded || !window.elementLoader.isLoaded()) {
                    // Wait for elementsLoaded event
                    await new Promise((resolve) => {
                        window.addEventListener('elementsLoaded', resolve, { once: true });
                    });
                }
                
                
                // Create minimal elementDatabase for compatibility
                elementDatabase = {
                    fire: { emoji: '🔥', name: 'Fire', tier: 0, base: true },
                    water: { emoji: '💧', name: 'Water', tier: 0, base: true },
                    earth: { emoji: '🌍', name: 'Earth', tier: 0, base: true },
                    air: { emoji: '💨', name: 'Air', tier: 0, base: true }
                };
            } catch (error) {
                console.error('Failed to load elements:', error);
                // Fallback to basic elements
                elementDatabase = {
                    fire: { emoji: '🔥', name: 'Fire', tier: 0, base: true },
                    water: { emoji: '💧', name: 'Water', tier: 0, base: true },
                    earth: { emoji: '🌍', name: 'Earth', tier: 0, base: true },
                    air: { emoji: '💨', name: 'Air', tier: 0, base: true }
                };
            }
        }
        
        // Sound effects
        const eatSounds = [];
        const explosionSounds = [];
        let soundIndex = 0;
        let lastExplosionSoundTime = 0;
        const EXPLOSION_SOUND_COOLDOWN = 100; // 100ms cooldown between explosion sounds
        
        function initSoundEffects() {
            // Create multiple audio instances for overlapping sounds
            for (let i = 0; i < 5; i++) {
                const eatSound = new Audio('sounds/blip.mp3');
                eatSound.volume = 0.3125; // 31.25% volume (increased by 25%)
                eatSounds.push(eatSound);
                
                const explosionSound = new Audio('sounds/fire-impact.mp3');
                explosionSound.volume = 0.75; // 75% volume
                explosionSounds.push(explosionSound);
            }
        }
        
        function playEatSound() {
            if (!musicMuted && eatSounds.length > 0) {
                // Use round-robin to cycle through sound instances
                const sound = eatSounds[soundIndex % eatSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                sound.volume = 0.25; // Reduced by 50% from 0.5
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        function playExplosionSound(isPlayerInvolved = true) {
            if (!musicMuted && explosionSounds.length > 0) {
                // Check cooldown - only apply to AI-only explosions
                const currentTime = Date.now();
                if (!isPlayerInvolved && currentTime - lastExplosionSoundTime < EXPLOSION_SOUND_COOLDOWN) {
                    return; // Skip this sound due to cooldown
                }
                
                // Update last explosion time
                lastExplosionSoundTime = currentTime;
                
                // Use round-robin to cycle through sound instances
                const sound = explosionSounds[soundIndex % explosionSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.75 : 0.1; // 75% for player, 10% for AI only
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        // Power-up sound pools
        const voidOrbSounds = [];
        const alchemyVisionSounds = [];
        const catalystGemSounds = [];
        const boostSounds = [];
        
        function initPowerUpSounds() {
            // Create multiple instances for overlapping sounds
            for (let i = 0; i < 3; i++) {
                // Void Orb sound
                const voidSound = new Audio('sounds/magic-energy-whoosh.mp3');
                voidSound.volume = 0.6;
                voidOrbSounds.push(voidSound);
                
                // Alchemy Vision sound
                const alchemySound = new Audio('sounds/magma-roar.mp3');
                alchemySound.volume = 0.7;
                alchemyVisionSounds.push(alchemySound);
                
                // Catalyst Gem sound
                const catalystSound = new Audio('sounds/power-surge.mp3');
                catalystSound.volume = 0.6;
                catalystGemSounds.push(catalystSound);
                
                // Boost sound
                const boostSound = new Audio('sounds/whoosh-burst.mp3');
                boostSound.volume = 0.5;
                boostSounds.push(boostSound);
            }
        }
        
        function playVoidOrbSound(isPlayerInvolved = true) {
            if (!musicMuted && voidOrbSounds.length > 0) {
                const sound = voidOrbSounds[soundIndex % voidOrbSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.6 : 0.15; // 60% for player, 15% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        function playAlchemyVisionSound(isPlayerInvolved = true) {
            if (!musicMuted && alchemyVisionSounds.length > 0) {
                const sound = alchemyVisionSounds[soundIndex % alchemyVisionSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.7 : 0.2; // 70% for player, 20% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        function playCatalystGemSound(isPlayerInvolved = true) {
            if (!musicMuted && catalystGemSounds.length > 0) {
                const sound = catalystGemSounds[soundIndex % catalystGemSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.6 : 0.15; // 60% for player, 15% for AI
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        function playBoostSound(isPlayerInvolved = true) {
            // Only play sound for player, not AI
            if (!musicMuted && boostSounds.length > 0 && isPlayerInvolved) {
                const sound = boostSounds[soundIndex % boostSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                // Reduced volume by 25% (from 0.5 to 0.375)
                sound.volume = 0.375;
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        // Combination sound array
        let combinationSounds = [];
        
        function initCombinationSounds() {
            // Use the 8-bit blip sound for combinations
            for (let i = 0; i < 3; i++) {
                const sound = new Audio('sounds/8-bit-blip.mp3');
                sound.volume = 0.5;
                combinationSounds.push(sound);
            }
        }
        
        function playCombinationSound() {
            if (!musicMuted && combinationSounds.length > 0) {
                const sound = combinationSounds[soundIndex % combinationSounds.length];
                soundIndex++;
                sound.currentTime = 0;
                sound.volume = 0.7; // Always play at good volume for player combinations
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => {});
                }
            }
        }
        
        function createCombinationFlash() {
            // Create flash overlay
            const flash = document.createElement('div');
            flash.className = 'combination-flash';
            document.body.appendChild(flash);
            
            // Remove after animation completes
            setTimeout(() => {
                flash.remove();
            }, 500);
        }
        
        // Music functions
        function initMusic() {
            // Check which tracks are available
            checkAvailableTracks().then(() => {
                if (availableTracks.length > 0) {
                    playRandomTrack();
                }
            });
        }
        
        async function checkAvailableTracks() {
            // For now, assume all tracks are available
            availableTracks = [...musicTracks];
            return true;
        }
        
        let isPlayingNext = false; // Prevent multiple simultaneous calls
        
        function playRandomTrack() {
            // Prevent multiple simultaneous calls
            if (isPlayingNext) {
                return;
            }
            isPlayingNext = true;
            
            // Set flag that music should be playing
            musicShouldBePlaying = true;
            
            // Refill available tracks if empty
            if (availableTracks.length === 0) {
                availableTracks = [...musicTracks];
            }
            
            // Stop current track if playing
            let oldTrack = null;
            if (currentTrack && currentTrack.stopRequested !== true) {
                // Mark that we're stopping this track intentionally
                currentTrack.stopRequested = true;
                // Remove all event listeners to prevent them from firing
                currentTrack.removeEventListener('ended', currentTrack.endedHandler);
                currentTrack.removeEventListener('error', currentTrack.errorHandler);
                currentTrack.pause();
                // Don't clear src as it can trigger ended event
                oldTrack = currentTrack; // Keep reference to old track
            }
            
            // Pick random track
            const randomIndex = Math.floor(Math.random() * availableTracks.length);
            const trackName = availableTracks[randomIndex];
            
            // Remove the selected track from available tracks
            availableTracks.splice(randomIndex, 1);
            
            // Create audio element
            currentTrack = new Audio(`music/${trackName}`);
            currentTrack.volume = musicMuted ? 0 : musicVolume;
            
            // Create event handlers that we can reference later for removal
            currentTrack.endedHandler = function() {
                // Reset the playing flag first
                isPlayingNext = false;
                
                // Only play next if the track wasn't stopped intentionally and actually ended
                if (!this.stopRequested && this.currentTime > 0 && this.duration > 0 && this.currentTime >= this.duration - 0.5) {
                    setTimeout(() => {
                        try {
                            playRandomTrack();
                        } catch (error) {
                            console.error('Error playing next track:', error);
                            // Try again in a few seconds
                            setTimeout(playRandomTrack, 3000);
                        }
                    }, 1000); // Wait 1 second before next track
                } else {
                }
            };
            
            currentTrack.errorHandler = (e) => {
                console.error('Error loading track:', trackName, e);
                // Reset the playing flag
                isPlayingNext = false;
                // Try next track after a short delay
                setTimeout(() => {
                    playRandomTrack();
                }, 1000);
            };
            
            // Add event listeners
            currentTrack.addEventListener('ended', currentTrack.endedHandler);
            currentTrack.addEventListener('error', currentTrack.errorHandler);
            
            // Try to play
            const playPromise = currentTrack.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    isPlayingNext = false; // Reset flag on success
                    // Clear old track reference now that new one is playing
                    if (oldTrack) {
                        oldTrack = null;
                    }
                }).catch(e => {
                    console.error('[AUDIO] Failed to play track:', trackName, e);
                    // Store track to retry on user interaction
                    window.pendingMusicTrack = currentTrack;
                    isPlayingNext = false; // Reset flag on error
                });
            } else {
                isPlayingNext = false; // Reset flag if no promise
                // Clear old track reference
                if (oldTrack) {
                    oldTrack = null;
                }
            }
        }
        
        window.toggleMusic = function() {
            musicMuted = !musicMuted;
            
            // Update desktop mute text
            const muteText = document.getElementById('muteText');
            if (muteText) {
                muteText.textContent = musicMuted ? 'M to Unmute' : 'M to Mute';
            }
            
            // Update mobile mute button
            const mobileMuteButton = document.getElementById('muteButtonMobile');
            if (mobileMuteButton) {
                mobileMuteButton.textContent = musicMuted ? '🔊' : '🔇';
            }
            
            if (musicMuted) {
                // Clear music should be playing flag when muting
                musicShouldBePlaying = false;
                if (currentTrack) {
                    currentTrack.pause();
                }
                // Also pause boss music
                if (bossIntroMusic) {
                    bossIntroMusic.pause();
                }
                if (bossBattleMusic) {
                    bossBattleMusic.pause();
                }
            } else {
                // Set music should be playing flag when unmuting
                musicShouldBePlaying = true;
                if (currentTrack && gameStarted) {
                    currentTrack.volume = musicVolume;
                    currentTrack.play().catch(() => {});
                }
                // Resume boss music if boss encounter is active
                if (bossEncounterActive) {
                    if (bossIntroMusic && !bossIntroMusic.ended) {
                        bossIntroMusic.volume = 0.7 * musicVolume;
                        bossIntroMusic.play().catch(() => {});
                    } else if (bossBattleMusic && currentBoss && currentBoss.alive) {
                        bossBattleMusic.volume = 0.6 * musicVolume;
                        bossBattleMusic.play().catch(() => {});
                    }
                }
            }
        };
        
        window.changeVolume = function(value) {
            musicVolume = value / 100;
            document.getElementById('volumeDisplay').textContent = value + '%';
            
            if (!musicMuted) {
                if (currentTrack) {
                    currentTrack.volume = musicVolume;
                }
                // Also update boss music volume
                if (bossIntroMusic) {
                    bossIntroMusic.volume = 0.7 * musicVolume;
                }
                if (bossBattleMusic) {
                    bossBattleMusic.volume = 0.6 * musicVolume;
                }
            }
        };
        
        // Audio Lifecycle Management - Fix iOS background audio issue
        let audioWasPlaying = {
            music: false,
            bossIntro: false,
            bossBattle: false
        };
        
        // Pause all audio sources
        function pauseAllAudio() {
            console.log('[AUDIO] Pausing all audio');
            
            // Track what was playing
            audioWasPlaying.music = currentTrack && !currentTrack.paused;
            audioWasPlaying.bossIntro = bossIntroMusic && !bossIntroMusic.paused;
            audioWasPlaying.bossBattle = bossBattleMusic && !bossBattleMusic.paused;
            
            console.log('[AUDIO] Audio state before pause:', {
                music: audioWasPlaying.music,
                bossIntro: audioWasPlaying.bossIntro,
                bossBattle: audioWasPlaying.bossBattle,
                currentTrack: currentTrack ? 'exists' : 'null',
                gameStarted,
                musicMuted
            });
            
            // Pause everything
            if (currentTrack) {
                currentTrack.pause();
                console.log('[AUDIO] Paused background music');
            }
            if (bossIntroMusic) {
                bossIntroMusic.pause();
                console.log('[AUDIO] Paused boss intro music');
            }
            if (bossBattleMusic) {
                bossBattleMusic.pause();
                console.log('[AUDIO] Paused boss battle music');
            }
            
            // Also pause any sound effects
            if (window.eatSounds) {
                eatSounds.forEach(sound => {
                    if (sound && !sound.paused) {
                        sound.pause();
                    }
                });
            }
        }
        
        // Resume audio that was playing before
        let resumeAttempts = 0;
        const MAX_RESUME_ATTEMPTS = 3;
        
        function resumeAudio() {
            console.log('[AUDIO] Resume audio called', {
                audioWasPlaying,
                musicShouldBePlaying,
                currentTrack: currentTrack ? 'exists' : 'null',
                musicMuted,
                gameStarted,
                pendingMusicTrack: window.pendingMusicTrack ? 'exists' : 'null'
            });
            
            // Check if music should be playing even if it wasn't actively playing
            const shouldAttemptResume = (audioWasPlaying.music || musicShouldBePlaying) || 
                                       audioWasPlaying.bossIntro || 
                                       audioWasPlaying.bossBattle;
            
            if (!shouldAttemptResume) {
                console.log('[AUDIO] No audio needs to be resumed');
                return;
            }
            
            // Resume background music if it should be playing and audio is not muted
            if ((audioWasPlaying.music || musicShouldBePlaying) && !musicMuted && gameStarted) {
                if (currentTrack) {
                    console.log('[AUDIO] Attempting to resume background music');
                    const playPromise = currentTrack.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('[AUDIO] Background music resumed successfully');
                            audioWasPlaying.music = false;
                            resumeAttempts = 0;
                        }).catch(error => {
                            console.error('[AUDIO] Failed to resume background music:', error);
                            
                            // Retry with exponential backoff
                            if (resumeAttempts < MAX_RESUME_ATTEMPTS) {
                                resumeAttempts++;
                                const delay = Math.pow(2, resumeAttempts) * 500; // 500ms, 1s, 2s
                                console.log(`[AUDIO] Retrying resume in ${delay}ms (attempt ${resumeAttempts}/${MAX_RESUME_ATTEMPTS})`);
                                
                                setTimeout(() => {
                                    // Check if conditions still valid before retry
                                    if (audioWasPlaying.music && currentTrack && !musicMuted && gameStarted) {
                                        resumeAudio();
                                    }
                                }, delay);
                            } else {
                                console.log('[AUDIO] Max resume attempts reached, giving up');
                                audioWasPlaying.music = false;
                                resumeAttempts = 0;
                            }
                        });
                    }
                } else if (window.pendingMusicTrack && !musicMuted) {
                    console.log('[AUDIO] Found pending music track, attempting to play');
                    // Try to play the pending track
                    const playPromise = window.pendingMusicTrack.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('[AUDIO] Pending music track started successfully');
                            currentTrack = window.pendingMusicTrack;
                            window.pendingMusicTrack = null;
                        }).catch(error => {
                            console.error('[AUDIO] Failed to play pending music track:', error);
                            // Try starting a new track instead
                            if (gameStarted && !musicMuted) {
                                playRandomTrack();
                            }
                        });
                    }
                    audioWasPlaying.music = false;
                } else {
                    console.log('[AUDIO] No current track to resume, attempting to start new track');
                    // If no current track but music should be playing, start a new one
                    if (gameStarted && !musicMuted && musicShouldBePlaying) {
                        playRandomTrack();
                    }
                    audioWasPlaying.music = false;
                }
            }
            
            // Resume boss music if in boss encounter and audio is not muted
            if (bossEncounterActive && !musicMuted) {
                if (audioWasPlaying.bossIntro && bossIntroMusic && !bossIntroMusic.ended) {
                    console.log('[AUDIO] Attempting to resume boss intro music');
                    bossIntroMusic.play().then(() => {
                        console.log('[AUDIO] Boss intro music resumed successfully');
                        audioWasPlaying.bossIntro = false;
                    }).catch(error => {
                        console.error('[AUDIO] Failed to resume boss intro music:', error);
                        audioWasPlaying.bossIntro = false;
                    });
                } else if (audioWasPlaying.bossBattle && bossBattleMusic) {
                    console.log('[AUDIO] Attempting to resume boss battle music');
                    bossBattleMusic.play().then(() => {
                        console.log('[AUDIO] Boss battle music resumed successfully');
                        audioWasPlaying.bossBattle = false;
                    }).catch(error => {
                        console.error('[AUDIO] Failed to resume boss battle music:', error);
                        audioWasPlaying.bossBattle = false;
                    });
                }
            }
        }
        
        // Stop all audio completely
        function stopAllAudio() {
            // Clear music should be playing flag
            musicShouldBePlaying = false;
            
            // Stop and clear current track
            if (currentTrack) {
                currentTrack.pause();
                currentTrack.currentTime = 0;
                if (currentTrack.endedHandler) {
                    currentTrack.removeEventListener('ended', currentTrack.endedHandler);
                }
                if (currentTrack.errorHandler) {
                    currentTrack.removeEventListener('error', currentTrack.errorHandler);
                }
                currentTrack = null;
            }
            
            // Stop boss music
            if (bossIntroMusic) {
                bossIntroMusic.pause();
                bossIntroMusic.currentTime = 0;
                bossIntroMusic = null;
            }
            if (bossBattleMusic) {
                bossBattleMusic.pause();
                bossBattleMusic.currentTime = 0;
                bossBattleMusic = null;
            }
            
            // Stop all sound effects
            if (window.eatSounds) {
                eatSounds.forEach(sound => {
                    if (sound) {
                        sound.pause();
                        sound.currentTime = 0;
                    }
                });
            }
        }
        
        // Debounce mechanism for visibility changes
        let visibilityChangeTimeout = null;
        let lastVisibilityState = document.hidden;
        
        function handleVisibilityChange() {
            // Clear any pending visibility change
            if (visibilityChangeTimeout) {
                clearTimeout(visibilityChangeTimeout);
            }
            
            const isHidden = document.hidden;
            
            // Only act if state actually changed
            if (isHidden !== lastVisibilityState) {
                lastVisibilityState = isHidden;
                
                if (isHidden) {
                    console.log('[AUDIO] Tab becoming hidden, pausing audio');
                    pauseAllAudio();
                } else {
                    // Debounce the resume to avoid rapid pause/resume cycles
                    visibilityChangeTimeout = setTimeout(() => {
                        console.log('[AUDIO] Tab becoming visible, resuming audio');
                        resumeAudio();
                    }, 300);
                }
            }
        }
        
        // Visibility API handlers
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // iOS-specific handlers (fallback for Safari)
        let blurTimeout = null;
        
        window.addEventListener('blur', () => {
            console.log('[AUDIO] Window blur event');
            // Only pause if document is actually hidden
            // This prevents false positives from dev tools, etc
            blurTimeout = setTimeout(() => {
                if (document.hidden) {
                    console.log('[AUDIO] Window blurred and document hidden, pausing audio');
                    pauseAllAudio();
                }
            }, 200);
        });
        
        window.addEventListener('focus', () => {
            console.log('[AUDIO] Window focus event');
            // Clear any pending blur timeout
            if (blurTimeout) {
                clearTimeout(blurTimeout);
                blurTimeout = null;
            }
            
            // Small delay to ensure proper state
            setTimeout(() => {
                if (!document.hidden) {
                    console.log('[AUDIO] Window focused and document visible, resuming audio');
                    resumeAudio();
                }
            }, 300);
        });
        
        // Page hide/show events (iOS Safari specific)
        window.addEventListener('pagehide', () => {
            pauseAllAudio();
        });
        
        window.addEventListener('pageshow', (event) => {
            // Check if page is being restored from cache
            if (!event.persisted) {
                resumeAudio();
            }
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            stopAllAudio();
        });
        
        // Also handle unload event as fallback
        window.addEventListener('unload', () => {
            stopAllAudio();
        });
        
        // Debug function to reset discoveries
        window.resetDiscoveries = function() {
            // Clear from localStorage
            localStorage.removeItem('discoveredElements');
            localStorage.removeItem('allTimeDiscoveries');
            
            // Clear in-game discoveries
            discoveredElements = new Set([0, 1, 2, 3]); // Earth, Water, Air, Fire IDs
            playerDiscoveredElements = new Set([0, 1, 2, 3]); // Player starts with base elements
            allTimeDiscoveries = new Map();
            
            // Update UI
            updateDiscoveryLog();
            
            return 'Discoveries reset successfully';
        };
        
        // Border particle class
        class BorderParticle {
            constructor(x, y, edge) {
                this.x = x;
                this.y = y;
                this.edge = edge; // 'left', 'right', 'top', 'bottom'
                this.baseX = x;
                this.baseY = y;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 0.5 + 0.1;
                this.offset = Math.random() * Math.PI * 2;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = this.getRandomColor();
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(147, 51, 234, ', // purple
                    'rgba(236, 72, 153, ', // pink
                    'rgba(59, 130, 246, ', // blue
                    'rgba(168, 85, 247, ', // purple-pink
                    'rgba(99, 102, 241, '  // indigo
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(deltaTime) {
                const time = animationTime + this.offset;
                
                // Float in circular motion
                const radius = 15;
                const floatX = Math.cos(time * this.speed) * radius;
                const floatY = Math.sin(time * this.speed * 0.7) * radius;
                
                this.x = this.baseX + floatX;
                this.y = this.baseY + floatY;
                
                // Pulse opacity
                this.opacity = 0.3 + Math.sin(time * 2) * 0.2;
            }
            
            draw(ctx) {
                if (isMobile) {
                    // Simplified rendering for mobile - no shadows
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // Desktop keeps full effects
                    ctx.save();
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color + this.opacity + ')';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color + '0.8)';
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        // Snake class
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.prevX = x;
                this.prevY = y;
                this.angle = Math.random() * Math.PI * 2;
                this.prevAngle = this.angle;
                this.segments = [];
                
                this.elements = [];
                this.maxVisibleElements = 6; // Fixed max of 6 visible element slots
                this.elementsEaten = 0; // Track total elements eaten
                this.length = 10;
                this.score = 0;
                this.discoveries = 0; // Track discoveries for this snake
                this.kills = 0; // Track kills for this snake
                this.alive = true;
                this.isPlayer = isPlayer;
                this.speed = SNAKE_SPEED;
                this.baseSpeed = SNAKE_SPEED; // Store base speed for boost calculations
                this.name = isPlayer ? 'You' : generateSnakeName();
                this.invincibilityTimer = 0;
                this.size = 1; // Default size for normal snakes
                
                // Validate size to prevent invisibility
                if (!this.size || this.size <= 0) {
                    this.size = 1;
                    console.warn('Snake size was invalid, setting to 1');
                }
                
                // Debug logging for player snake creation
                if (isPlayer) {
                    console.log('[PLAYER CREATED] Size:', this.size);
                    console.trace(); // Show stack trace to see where it's being called from
                }
                this.discoveredElements = new Set(); // Each snake tracks its own discoveries - starts empty
                
                // Speed boost properties
                this.stamina = 100; // Max stamina
                this.maxStamina = 100;
                this.isBoosting = false;
                this.wasBoostingLastFrame = false; // Track boost state changes
                this.staminaRegenCooldown = 0; // Prevents regen immediately after boosting
                this.boostParticleTimer = 0;
                
                // Near-miss tracking
                this.nearMissTracking = new Map(); // Track distance to other snakes over time
                this.recentCollisions = new Set(); // Track recent collisions to prevent near-miss after collision
                
                // Assign skin
                if (isPlayer) {
                    this.skin = currentPlayerSkin;
                } else {
                    // Get available AI skins (exclude snake-default-green, boss skins, and already used skins)
                    const allSkins = Object.keys(skinMetadata).filter(skin => 
                        skin !== 'snake-default-green' && !skinMetadata[skin].isBoss && !usedAISkins.has(skin)
                    );
                    
                    // If all skins are used, reset the used skins set (but still exclude default green and boss skins)
                    if (allSkins.length === 0) {
                        usedAISkins.clear();
                        const resetSkins = Object.keys(skinMetadata).filter(skin => 
                            skin !== 'snake-default-green' && !skinMetadata[skin].isBoss
                        );
                        this.skin = resetSkins[Math.floor(Math.random() * resetSkins.length)];
                    } else {
                        this.skin = allSkins[Math.floor(Math.random() * allSkins.length)];
                    }
                    
                    // Mark this skin as used
                    usedAISkins.add(this.skin);
                    
                    // Assign random personality to AI snakes (but not bosses)
                    if (!this.isBoss) {
                        const personalities = Object.keys(AI_PERSONALITIES);
                        const personalityKey = personalities[Math.floor(Math.random() * personalities.length)];
                        this.personality = AI_PERSONALITIES[personalityKey];
                        this.name = this.personality.name + ' ' + this.name;
                        this.personalityColor = PERSONALITY_COLORS[this.personality.name];
                    }
                    
                    // AI-specific properties
                    this.targetMemory = null; // Remember targets for a few frames
                    this.targetMemoryTimer = 0;
                    this.lastCollisionCheck = 0; // Optimize collision checking
                    this.panicMode = false; // Emergency evasion state
                    this.panicTimer = 0;
                    this.lastDangerAngle = null; // Remember last danger direction
                    this.consecutiveDangerFrames = 0; // Track how long we've been in danger
                }
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    const segX = x - i * SEGMENT_SIZE * Math.cos(this.angle);
                    const segY = y - i * SEGMENT_SIZE * Math.sin(this.angle);
                    this.segments.push({
                        x: segX,
                        y: segY,
                        prevX: segX,
                        prevY: segY
                    });
                }
                
                // Start with NO elements - snakes must collect them from the map
                // This ensures players experience the discovery process from scratch
            }
            
            update(deltaTime = 1) {
                if (!this.alive) return;
                
                // Store previous positions for interpolation
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevAngle = this.angle;
                
                // Store previous segment positions
                if (this.segments) {
                    this.segments.forEach(segment => {
                        segment.prevX = segment.x;
                        segment.prevY = segment.y;
                    });
                }
                
                // Debug check
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    console.error('Snake position is NaN!', 'x:', this.x, 'y:', this.y, 'deltaTime:', deltaTime);
                }
                
                // Update invincibility
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= 16; // Fixed timestep
                }
                
                // Handle controls
                if (this.isPlayer) {
                    // Only apply controls if this is the main player snake
                    if (this !== playerSnake) {
                        // Count how many player snakes exist
                        const playerSnakeCount = snakes.filter(s => s.isPlayer && s.alive).length;
                        
                        // Only kill if there's actually more than one player snake
                        if (playerSnakeCount > 1) {
                            console.error('[CONTROLS] WARNING: Multiple player snakes detected! Killing duplicate:', this.name);
                            this.alive = false; // Kill duplicate player snake
                            return;
                        } else {
                            // If there's only one player snake, update the reference
                            console.warn('[CONTROLS] Player snake reference mismatch, updating reference');
                            playerSnake = this;
                        }
                    }
                    
                    // Handle turning
                    let turnMultiplier = 1;
                    if (this.isBoosting) {
                        turnMultiplier = 0.85; // Reduced turn speed while boosting
                    }
                    
                    if (isMobile && joystickActive) {
                        // Mobile controls - use joystick
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        const angleChange = angleDiff * 0.12 * turnMultiplier;
                        if (isFinite(angleChange)) {
                            this.angle += angleChange;
                        }
                        this.isBoosting = mouseDown && this.stamina > 0;
                    } else if (controlScheme === 'arrows') {
                        // Arrow keys
                        if (keys['ArrowLeft']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['ArrowRight']) this.angle += TURN_SPEED * turnMultiplier;
                        // WASD keys (always available alongside arrows)
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED * turnMultiplier;
                        // Handle boost (both ArrowUp and W)
                        this.isBoosting = (keys['ArrowUp'] || keys['w'] || keys['W']) && this.stamina > 0;
                    } else if (controlScheme === 'mouse') {
                        // WASD controls - standard tank controls that just turn the snake
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED * turnMultiplier;
                        
                        // Mouse steering only if mouse has moved recently and WASD not being used
                        const usingWASD = keys['a'] || keys['A'] || keys['d'] || keys['D'];
                        if (!usingWASD && mouseMovedRecently) {
                            // Smooth angle interpolation toward mouse
                            let angleDiff = mouseAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            const angleChange = angleDiff * 0.1 * turnMultiplier;
                            if (isFinite(angleChange)) {
                                this.angle += angleChange;
                            }
                        }
                        
                        // Handle boost (mouse click OR W key)
                        this.isBoosting = (mouseDown || keys['w'] || keys['W']) && this.stamina > 0;
                    }
                } else {
                    // Enhanced AI with personality system
                    this.updateAI(deltaTime);
                }
                
                // Update stamina and speed based on boost
                if (this.isBoosting && this.stamina > 0) {
                    // Play boost sound when starting to boost
                    if (!this.wasBoostingLastFrame) {
                        playBoostSound(this.isPlayer);
                    }
                    
                    // Deplete stamina (5 seconds of continuous use)
                    this.stamina -= (100 / (5 * 60)) * deltaTime; // 100 stamina over 5 seconds
                    this.stamina = Math.max(0, this.stamina);
                    this.staminaRegenCooldown = 30; // Half second cooldown before regen starts
                    
                    // Apply speed boost
                    this.speed = this.baseSpeed * 1.75;
                    
                    // Create boost particles
                    this.boostParticleTimer++;
                    const particleFrequency = isMobile ? 6 : 3; // Less frequent on mobile
                    if (this.boostParticleTimer % particleFrequency === 0) {
                        const particleAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                        const particleSpeed = 2 + Math.random() * 2;
                        const vx = Math.cos(particleAngle) * particleSpeed;
                        const vy = Math.sin(particleAngle) * particleSpeed;
                        const color = this.isPlayer ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                        particlePool.spawn(this.x, this.y, vx, vy, color);
                    }
                } else {
                    // Not boosting
                    this.isBoosting = false;
                    this.speed = this.baseSpeed;
                    
                    // Regenerate stamina
                    if (this.staminaRegenCooldown > 0) {
                        this.staminaRegenCooldown -= deltaTime;
                    } else if (this.stamina < this.maxStamina) {
                        // Regenerate stamina (2 seconds to full)
                        this.stamina += (100 / (2 * 60)) * deltaTime; // 100 stamina over 2 seconds
                        this.stamina = Math.min(this.maxStamina, this.stamina);
                    }
                }
                
                // Ensure angle is valid
                if (!isFinite(this.angle)) {
                    console.error('Angle is invalid!', this.angle, 'Resetting to 0');
                    this.angle = 0;
                }
                
                // Move head (apply deltaTime for proper movement)
                // Performance optimization: Use fast math for movement
                const moveX = fastMath.cos(this.angle) * this.speed * deltaTime;
                const moveY = fastMath.sin(this.angle) * this.speed * deltaTime;
                
                if (isFinite(moveX) && isFinite(moveY)) {
                    this.x += moveX;
                    this.y += moveY;
                } else {
                    console.error('Invalid movement!', 'angle:', this.angle, 'speed:', this.speed, 'deltaTime:', deltaTime);
                }
                
                // World boundaries - add small margin for floating point precision
                const boundaryMargin = 2; // Small margin to prevent edge case deaths
                if (this.x <= -boundaryMargin || this.x >= WORLD_SIZE + boundaryMargin || 
                    this.y <= -boundaryMargin || this.y >= WORLD_SIZE + boundaryMargin) {
                    this.die();
                    return;
                }
                
                // Update segments
                if (!this.segments) {
                    console.error('Segments array is undefined!');
                    this.segments = [];
                }
                this.segments.unshift({ 
                    x: this.x, 
                    y: this.y,
                    prevX: this.prevX || this.x,
                    prevY: this.prevY || this.y
                });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
                
                // Update boost state tracking
                this.wasBoostingLastFrame = this.isBoosting;
            }
            
            checkCombinations(depth = 0) {
                if (this.elements.length < 2) return;
                
                // Safety check - ensure we never exceed max elements
                if (this.elements.length > this.maxVisibleElements) {
                    console.error('[CRITICAL] Elements array exceeds max visible elements!', this.elements.length);
                    // Trim to max size
                    this.elements = this.elements.slice(0, this.maxVisibleElements);
                }
                
                // Limit chain reaction depth
                const MAX_CHAIN_DEPTH = 3;
                if (depth >= MAX_CHAIN_DEPTH) {
                    return;
                }
                
                // Log bank state periodically for player
                
                // Find all possible combinations
                let possibleCombos = [];
                
                for (let i = 0; i < this.elements.length; i++) {
                    for (let j = i + 1; j < this.elements.length; j++) {
                        const id1 = this.elements[i];
                        const id2 = this.elements[j];
                        
                        // Check if these can combine using numeric IDs
                        let resultId = null;
                        if (window.elementLoader && window.elementLoader.combinations) {
                            // Use min/max to ensure consistent key order
                            const key = `${Math.min(id1, id2)}+${Math.max(id1, id2)}`;
                            resultId = window.elementLoader.combinations[key];
                            
                            if (depth === 0 && this.isPlayer && possibleCombos.length === 0 && resultId !== undefined && resultId !== null) {
                            }
                        }
                        
                        if (resultId !== undefined && resultId !== null && window.elementLoader.elements.get(resultId)) {
                            const resultElem = window.elementLoader.elements.get(resultId);
                            const isNewDiscovery = !this.discoveredElements.has(resultId);
                            const resultTier = resultElem.t || 0;
                            
                            possibleCombos.push({
                                index1: i,
                                index2: j,
                                elem1: id1,
                                elem2: id2,
                                result: resultId,
                                isNewDiscovery,
                                tier: resultTier
                            });
                        }
                    }
                }
                
                if (possibleCombos.length === 0) {
                    if (this.isPlayer && this === playerSnake) {
                        comboStreak = 0;
                    }
                    return;
                }
                
                // Prioritize: new discoveries first, then by highest tier
                possibleCombos.sort((a, b) => {
                    if (a.isNewDiscovery && !b.isNewDiscovery) return -1;
                    if (!a.isNewDiscovery && b.isNewDiscovery) return 1;
                    return b.tier - a.tier;
                });
                
                const chosen = possibleCombos[0];
                
                // Debug logging
                
                // Start combination animation for player
                if (this.isPlayer) {
                    this.startCombinationAnimation(chosen.index1, chosen.index2);
                    // Play combination sound - disabled
                    // playCombinationSound();
                    // Create visual flash effect
                    createCombinationFlash();
                    
                    // Add glow/wobble to both combining elements in the bank
                    this.glowWobbleIndices = [chosen.index1, chosen.index2];
                    this.glowWobbleTime = Date.now();
                    
                    // Update UI immediately to show animation
                    updateUI();
                }
                
                // Remove the two elements (remove higher index first to maintain indices)
                const indices = [chosen.index1, chosen.index2].sort((a, b) => b - a);
                this.elements.splice(indices[0], 1);
                this.elements.splice(indices[1], 1);
                
                // Add the result to a random position in the available slots
                const insertIndex = Math.floor(Math.random() * (this.elements.length + 1));
                this.elements.splice(insertIndex, 0, chosen.result);
                
                // Safety check - ensure we never exceed max elements after combination
                if (this.elements.length > this.maxVisibleElements) {
                    console.error('[SAFETY] Elements exceed max after combination, trimming');
                    this.elements = this.elements.slice(0, this.maxVisibleElements);
                }
                            
                    // Discovery check
                    if (chosen.isNewDiscovery) {
                        this.discoveredElements.add(chosen.result);
                        
                        // IMPORTANT: Add to global discovered elements for spawning system!
                        // But delay AI discoveries at game start to give clean beginning
                        const gameTime = Date.now() - gameStartTime;
                        if (this.isPlayer || gameTime > 10000) { // Only after 10 seconds for AI
                            discoveredElements.add(chosen.result);
                        }
                        
                        // Only add to player discoveries if this is the player
                        if (this.isPlayer && this === playerSnake) {
                            // Ensure we store as number
                            const resultId = typeof chosen.result === 'string' ? parseInt(chosen.result) : chosen.result;
                            playerDiscoveredElements.add(resultId);
                        }
                        
                        this.score += 500; // 500 points for new discovery
                        this.discoveries++; // Increment discovery count
                        
                        // Additional effects for player
                        if (this.isPlayer && this === playerSnake) {
                            // Dispatch element discovered event
                            dispatchGameEvent('elementDiscovered', {
                                element1: chosen.elem1,
                                element2: chosen.elem2,
                                result: chosen.result,
                                totalDiscoveries: this.discoveries,
                                score: this.score
                            });
                            
                            // Save to all-time discoveries with recipe
                            const elem1Data = window.elementLoader.elements.get(chosen.elem1);
                            const elem2Data = window.elementLoader.elements.get(chosen.elem2);
                            if (elem1Data && elem2Data) {
                                const emoji1 = window.elementLoader.getEmojiForElement(chosen.elem1, elem1Data.e);
                                const emoji2 = window.elementLoader.getEmojiForElement(chosen.elem2, elem2Data.e);
                                const recipe = `${emoji1} ${elem1Data.n} + ${emoji2} ${elem2Data.n}`;
                                allTimeDiscoveries.set(chosen.result, recipe);
                                saveAllTimeDiscoveries();
                            }
                            
                            showCombinationMessage(chosen.elem1, chosen.elem2, chosen.result, true); // Show new discovery
                            // Grant invincibility on new discovery
                            this.invincibilityTimer = 3000; // 3 seconds
                            
                            // Check for new high score
                            if (this.score > highScore) {
                                highScore = this.score;
                                localStorage.setItem('highScore', highScore.toString());
                            }
                        }
                    } else {
                        // Existing combination - add combo streak points
                        if (this.isPlayer && this === playerSnake) {
                            comboStreak++;
                            let comboBonus = 100; // Base combo points
                            
                            // Calculate streak bonus
                            if (comboStreak >= 4) {
                                comboBonus = 2500;
                                showMessage(`4x COMBO STREAK! +${comboBonus} points!`, 'combo', 5000);
                            } else if (comboStreak >= 3) {
                                comboBonus = 1000;
                                showMessage(`3x Combo Streak! +${comboBonus} points!`, 'combo', 5000);
                            } else if (comboStreak >= 2) {
                                comboBonus = 500;
                                showMessage(`2x Combo! +${comboBonus} points!`, 'combo', 5000);
                            }
                            
                            this.score += comboBonus;
                            showCombinationMessage(chosen.elem1, chosen.elem2, chosen.result, false); // Show combo
                        }
                    }
                            
                    // Create particle effect at snake head
                    createCombinationParticles(this.segments[0].x, this.segments[0].y);
                    
                    // Debug: Log when any snake creates a combination during boss fight
                    if (currentBoss && currentBoss.alive) {
                        console.log('[COMBINATION] Snake:', this.name, 'isPlayer:', this.isPlayer, 'created combination:', chosen.elem1, '+', chosen.elem2, '=', chosen.result, 'Boss element:', currentBoss.elementId);
                    }
                    
                    // Check if this combination involves the boss's element and create shockwave
                    if (this.isPlayer && this === playerSnake && currentBoss && currentBoss.alive) {
                        const bossElementId = currentBoss.elementId;
                        // Check if either of the combining elements or the result is the boss element
                        if (chosen.elem1 === bossElementId || chosen.elem2 === bossElementId || chosen.result === bossElementId) {
                            console.log('[SHOCKWAVE] Creating shockwave for player:', this.name, 'isPlayer:', this.isPlayer, 'playerSnake match:', this === playerSnake);
                            // Create shockwave effect
                            const elementColors = {
                                0: '#8b6914', // Earth - brown
                                1: '#0066ff', // Water - blue
                                2: '#ffffff', // Air - white
                                3: '#ff4444'  // Fire - red
                            };
                            
                            // Determine the color based on player's primary element
                            let shockwaveColor = '#FFD700'; // Default gold
                            if (this.elements.length > 0) {
                                const primaryElement = this.elements[0];
                                shockwaveColor = elementColors[primaryElement] || '#FFD700';
                            }
                            
                            shockwaves.push({
                                x: this.segments[0].x,
                                y: this.segments[0].y,
                                radius: 0,
                                maxRadius: 400, // Reduced radius for increased difficulty
                                speed: 10, // Slower expansion for visibility
                                color: shockwaveColor,
                                life: 1.0,
                                type: 'omnidirectional',
                                owner: 'player' // Mark this as a player shockwave
                            });
                            
                            // Play explosion shockwave sound
                            const shockwaveSound = new Audio('sounds/explosion-shockwave.mp3');
                            shockwaveSound.volume = 0.8;
                            shockwaveSound.play().catch(e => {});
                            
                            // Show special message for boss element combination
                            showMessage('Boss Element Resonance!', 'gold', 3000);
                        }
                    }
                    
                    // Log chain reaction info
                    
                    // Check again in case there are more combinations
                    this.checkCombinations(depth + 1);
                }
            
            consume(element) {
                // Play eating sound for player only
                if (this.isPlayer) {
                    playEatSound();
                }
                
                // Debug logging
                if (this.isPlayer) {
                }
                
                // Safety check - ensure we never have more than max elements (use global elementBankSlots)
                if (this.elements.length > elementBankSlots) {
                    console.error('[CRITICAL] Bank already exceeds maximum!', this.elements.length);
                    this.elements = this.elements.slice(0, elementBankSlots);
                }
                
                // Debug element consumption
                if (this.isPlayer && window.debugElementBank) {
                }
                
                // Check if we have space in visible slots (use global elementBankSlots)
                if (this.elements.length >= elementBankSlots) {
                    // At visible capacity - check if new element can combine with any existing
                    const newElementId = element.id;
                    let combined = false;
                    
                    // Add safety check for elementLoader
                    if (!window.elementLoader || !window.elementLoader.combinations) {
                        console.error('[ERROR] ElementLoader or combinations not loaded!');
                        return;
                    }
                    
                    // Check combinations with all existing elements
                    for (let i = 0; i < this.elements.length && !combined; i++) {
                        const existingId = this.elements[i];
                        // Use min/max to ensure consistent key order
                        const comboKey = `${Math.min(newElementId, existingId)}+${Math.max(newElementId, existingId)}`;
                        const resultId = window.elementLoader.combinations[comboKey];
                        
                        
                        if (resultId !== undefined && resultId !== null) {
                            // Found a combination! Replace the existing element with the result
                            combined = true;
                            
                            // Visual feedback for the combination
                            if (this.isPlayer) {
                                // Start glow/wobble animation on the bank element
                                this.pendingCombinationIndex = i;
                                this.pendingCombinationTime = Date.now();
                                updateUI(); // Update UI to show the glow effect
                            }
                            
                            // Delay the actual combination for visual effect
                            setTimeout(() => {
                                this.elements[i] = resultId;
                                
                                // Final safety check after replacement (use global elementBankSlots)
                                if (this.elements.length > elementBankSlots) {
                                    console.error('[SAFETY] Elements exceed max after replacement, trimming');
                                    this.elements = this.elements.slice(0, elementBankSlots);
                                }
                                
                                if (this.isPlayer) {
                                    this.pendingCombinationIndex = -1;
                                }
                                
                                // Check if it's a new discovery
                                if (!this.discoveredElements.has(resultId)) {
                                    this.discoveredElements.add(resultId);
                                this.score += 500; // Discovery bonus
                                this.discoveries++;
                                
                                if (this.isPlayer && this === playerSnake) {
                                    discoveredElements.add(resultId);
                                    
                                    // Get result data for tracking
                                    const resultData = window.elementLoader.elements.get(resultId);
                                    
                                    // Track discovery event
                                    if (supabaseModule && supabaseModule.addGameEvent) {
                                        supabaseModule.addGameEvent('discovery', {
                                            element_id: resultId,
                                            element_name: resultData?.n || 'Unknown',
                                            recipe: [newElementId, existingId],
                                            score: this.score,
                                            total_discoveries: this.discoveries
                                        });
                                    }
                                    
                                    // Save discovery
                                    const elem1Data = window.elementLoader.elements.get(newElementId);
                                    const elem2Data = window.elementLoader.elements.get(existingId);
                                    if (elem1Data && elem2Data && resultData) {
                                        const emoji1 = window.elementLoader.getEmojiForElement(newElementId, elem1Data.e);
                                        const emoji2 = window.elementLoader.getEmojiForElement(existingId, elem2Data.e);
                                        const recipe = `${emoji1} ${elem1Data.n} + ${emoji2} ${elem2Data.n}`;
                                        allTimeDiscoveries.set(resultId, recipe);
                                        saveAllTimeDiscoveries();
                                    }
                                    
                                    showCombinationMessage(newElementId, existingId, resultId, true);
                                    this.invincibilityTimer = 3000;
                                }
                            } else {
                                // Existing combination
                                if (this.isPlayer && this === playerSnake) {
                                    comboStreak++;
                                    let comboBonus = 100;
                                    if (comboStreak >= 4) {
                                        comboBonus = 2500;
                                        showMessage(`4x COMBO STREAK! +${comboBonus} points!`, 'combo', 5000);
                                    } else if (comboStreak >= 3) {
                                        comboBonus = 1000;
                                        showMessage(`3x Combo Streak! +${comboBonus} points!`, 'combo', 5000);
                                    } else if (comboStreak >= 2) {
                                        comboBonus = 500;
                                        showMessage(`2x Combo! +${comboBonus} points!`, 'combo', 5000);
                                    }
                                    this.score += comboBonus;
                                    showCombinationMessage(newElementId, existingId, resultId, false);
                                }
                            }
                            
                            // Create particle effect
                            createCombinationParticles(this.segments[0].x, this.segments[0].y);
                            
                            // Now check if the new result can combine with other elements
                            this.checkCombinations();
                            
                            updateUI(); // Update UI after combination
                            }, 300); // 300ms delay for visual effect
                        }
                    }
                    
                    if (!combined) {
                        // No combination found with the new element
                        // Force a check for existing combinations in the bank
                        this.checkCombinations();
                        
                        // Bank is full and no combination possible - element is lost
                    }
                } else {
                    // We have space - add element to a random position within the 6 slots
                    const insertIndex = Math.floor(Math.random() * (this.elements.length + 1));
                    this.elements.splice(insertIndex, 0, element.id);
                    
                    // Immediately enforce max limit as a safety measure (use global elementBankSlots)
                    if (this.elements.length > elementBankSlots) {
                        console.error('[SAFETY] Trimming elements array to max size');
                        this.elements = this.elements.slice(0, elementBankSlots);
                    }
                    
                    
                    // Check for immediate combinations after adding
                    if (this.elements.length >= 2) {
                        this.checkCombinations();
                    }
                }
                
                // Track elements eaten
                this.elementsEaten++;
                
                // Grow snake
                this.length += 2;
                
                // Add score - 100 points per element
                this.score += 100;
                
                // Check for new high score
                if (this.isPlayer && this.score > highScore) {
                    highScore = this.score;
                    localStorage.setItem('highScore', highScore.toString());
                }
                
                // Remove element from world
                elementPool.remove(element);
                
                // Update UI if player
                if (this.isPlayer) {
                    updateUI();
                }
            }
            
            digest() {
                if (!this.isPlayer || this.elements.length === 0) {
                    // Non-player digestion happens instantly
                    const digestedCount = this.elements.length;
                    this.elements = [];
                    
                    // Bonus points for digestion based on how full we were
                    const digestBonus = Math.floor(digestedCount * 50);
                    this.score += digestBonus;
                    
                    // Check for new high score
                    if (this.isPlayer && this.score > highScore) {
                        highScore = this.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                    return;
                }
                
                // Player digestion - show message immediately
                const digestedCount = this.elements.length;
                
                // Clear all elements immediately
                this.elements = [];
                
                // Bonus points for digestion based on how full we were
                const digestBonus = Math.floor(digestedCount * 50);
                this.score += digestBonus;
                
                // Show digestion message for player only
                if (this.isPlayer && this === playerSnake) {
                    showMessage(`Digesting ${digestedCount} elements! +${digestBonus} points`, false);
                    // Update UI immediately
                    updateUI();
                }
            }
            
            startCombinationAnimation(index1, index2) {
                // Store indices for animation
                this.combiningIndices = [index1, index2];
                this.combinationAnimationTime = 0;
                this.isAnimatingCombination = true;
                
                // Update global animation state for UI
                if (this.isPlayer) {
                    combinationAnimationState.isAnimating = true;
                    combinationAnimationState.combiningIndices = [index1, index2];
                    combinationAnimationState.animationStartTime = Date.now();
                    
                    // The new element will be inserted at a random position
                    // We'll track it after the combination completes
                    setTimeout(() => {
                        // Find the newest element (the one that's not in the old positions)
                        const remainingElements = this.elements.length;
                        if (remainingElements > 0) {
                            // Since we insert at random position, we need to find it
                            // For now, we'll animate the first slot as a placeholder
                            combinationAnimationState.newElementIndex = Math.floor(Math.random() * remainingElements);
                            // Update UI to show the new element animation
                            updateUI();
                        }
                    }, 300);
                }
            }
            
            die(isBossDeath = false) {
                console.error('Snake dying!', 'isPlayer:', this.isPlayer, 'position:', this.x || 'undefined', this.y || 'undefined');
                console.trace();
                this.alive = false;
                
                // Drop all elements with scatter effect
                for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    
                    // Skip if segment is undefined or missing position
                    if (!segment || segment.x === undefined || segment.y === undefined) {
                        continue;
                    }
                    
                    // Calculate scatter radius based on position in snake
                    // Head elements scatter less, tail elements scatter more
                    const baseRadius = 30; // Base scatter radius
                    const maxRadius = 80; // Maximum scatter radius
                    const radiusProgress = i / Math.max(1, this.elements.length - 1); // 0 to 1
                    const scatterRadius = baseRadius + (maxRadius - baseRadius) * radiusProgress;
                    
                    // Random angle for circular distribution
                    const angle = Math.random() * Math.PI * 2;
                    
                    // Calculate offset with some randomness
                    const actualRadius = scatterRadius * (0.5 + Math.random() * 0.5); // 50% to 100% of radius
                    const offsetX = Math.cos(angle) * actualRadius;
                    const offsetY = Math.sin(angle) * actualRadius;
                    
                    // Calculate final position
                    let finalX = segment.x + offsetX;
                    let finalY = segment.y + offsetY;
                    
                    // Ensure elements stay within world bounds
                    const margin = 50;
                    finalX = Math.max(margin, Math.min(WORLD_SIZE - margin, finalX));
                    finalY = Math.max(margin, Math.min(WORLD_SIZE - margin, finalY));
                    
                    // Spawn the element at the scattered position
                    spawnElement(this.elements[i], finalX, finalY);
                }
                
                // Create death particles scaled to snake size
                createDeathParticles(this.x, this.y, this.length);
                
                // Special effects for boss deaths
                if (this.isPlayer && isBossDeath) {
                    // Create massive explosion for player death by boss
                    for (let i = 0; i < 50; i++) {
                        const angle = (Math.PI * 2 * i) / 50;
                        const speed = 5 + Math.random() * 10;
                        const color = ['#ff0000', '#ff6600', '#ffaa00', '#ffff00'][Math.floor(Math.random() * 4)];
                        const size = 10 + Math.random() * 15;
                        particlePool.spawn(
                            this.x,
                            this.y,
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed,
                            color,
                            size
                        );
                    }
                    
                    // Play powerful explosion sound
                    if (!musicMuted) {
                        const explosionSound = new Audio('sounds/big-powerful-explosion.mp3');
                        explosionSound.volume = 0.7;
                        explosionSound.play().catch(e => {});
                    }
                    
                    // Add intense screen shake
                    bossScreenShakeTimer = 60;
                    bossScreenShakeIntensity = 20;
                }
                
                // Respawn if player
                if (this.isPlayer) {
                    // Player respawn is now handled in the main game loop
                    // This prevents duplicate player snakes from being created
                }
            }
            
            explode(killer) {
                // Check if either party is a boss - bosses don't make explosion sounds
                const killerIsBoss = killer && killer.isBoss;
                const thisIsBoss = this.isBoss;
                
                // Play explosion sound - louder if player is involved, skip if either party is boss
                if (!killerIsBoss && !thisIsBoss) {
                    const isPlayerInvolved = this.isPlayer || (killer && killer.isPlayer);
                    playExplosionSound(isPlayerInvolved);
                }
                
                // Add screen flash effect for player death (helps identify what killed you)
                if (this.isPlayer && canvas) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }
                
                // Award points and kills to killer
                if (killer && killer.alive) {
                    killer.score += 500; // 500 points for snake explosion
                    killer.kills++; // Increment kill count
                    
                    // Track kill event if player is the killer
                    if (killer.isPlayer) {
                        // Dispatch enemy killed event
                        dispatchGameEvent('enemyKilled', {
                            victimName: this.name,
                            victimScore: this.score,
                            victimLength: this.segments.length,
                            killerScore: killer.score,
                            totalKills: killer.kills
                        });
                        
                        if (supabaseModule && supabaseModule.addGameEvent) {
                            supabaseModule.addGameEvent('kill', {
                                victim_name: this.name,
                                victim_score: this.score,
                                victim_length: this.segments.length,
                                killer_score: killer.score,
                                total_kills: killer.kills
                            });
                        }
                    }
                    
                    // Check for new high score if player
                    if (killer.isPlayer && killer.score > highScore) {
                        highScore = killer.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                }
                this.die();
            }
            
            draw(interpolation = 0) {
                if (!this.alive) return;
                
                // Get size multiplier (bosses have size = 3, normal snakes have size = 1)
                // Ensure size multiplier is always at least 1 to prevent invisibility
                const sizeMultiplier = Math.max(1, this.size || 1);
                
                // Early viewport check for the whole snake
                // Skip rendering if snake is completely off-screen (performance optimization)
                if (this.segments.length > 0) {
                    // Quick check using head position first
                    // Increase margin for larger snakes (bosses)
                    const margin = (isMobile ? 300 : 400) * sizeMultiplier;
                    if (!isInViewport(this.x, this.y, margin)) {
                        // Check if any segment is visible
                        let anyInViewport = false;
                        // Check every 5th segment for performance
                        for (let i = 0; i < this.segments.length; i += 5) {
                            if (isInViewport(this.segments[i].x, this.segments[i].y, margin)) {
                                anyInViewport = true;
                                break;
                            }
                        }
                        if (!anyInViewport) return;
                    }
                }
                
                // Explicit player visibility protection - AFTER viewport check to avoid dangling ctx.save()
                if (this.isPlayer) {
                    ctx.save();
                    ctx.globalAlpha = 1; // Force full opacity for player
                }
                
                // Draw boost trail effect (desktop only)
                if (!isMobile && this.isBoosting && this.segments && this.segments.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw speed lines
                    for (let i = 0; i < 3; i++) {
                        const segment = this.segments[Math.min(i * 2, this.segments.length - 1)];
                        const nextSegment = this.segments[Math.min(i * 2 + 5, this.segments.length - 1)];
                        
                        const screenX1 = segment.x - camera.x + canvas.width / 2;
                        const screenY1 = segment.y - camera.y + canvas.height / 2;
                        const screenX2 = nextSegment.x - camera.x + canvas.width / 2;
                        const screenY2 = nextSegment.y - camera.y + canvas.height / 2;
                        
                        // Skip if any coordinate is invalid
                        if (!isFinite(screenX1) || !isFinite(screenY1) || !isFinite(screenX2) || !isFinite(screenY2)) {
                            continue;
                        }
                        
                        const gradient = ctx.createLinearGradient(screenX1, screenY1, screenX2, screenY2);
                        gradient.addColorStop(0, this.isPlayer ? 'rgba(100, 200, 255, 0.6)' : 'rgba(255, 100, 100, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = SEGMENT_SIZE * 2 - i * 5;
                        ctx.beginPath();
                        ctx.moveTo(screenX1, screenY1);
                        ctx.lineTo(screenX2, screenY2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
                
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    
                    // Interpolate position if previous position exists
                    let x = segment.x;
                    let y = segment.y;
                    if (segment.prevX !== undefined && segment.prevY !== undefined) {
                        x = segment.prevX + (segment.x - segment.prevX) * interpolation;
                        y = segment.prevY + (segment.y - segment.prevY) * interpolation;
                    }
                    
                    const screen = worldToScreen(x, y);
                    const screenX = screen.x;
                    const screenY = screen.y;
                    
                    // Skip if off-screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    // Snake body color based on skin
                    const skinData = skinMetadata[this.skin];
                    const colors = skinData ? skinData.colors : ['#4ecdc4', '#45b7aa'];
                    
                    // Always use normal colors
                    ctx.fillStyle = colors[i % colors.length];
                    
                    // Draw pixelated square segment with tapered tail
                    const pixelSize = 4;
                    const baseSegmentSize = SEGMENT_SIZE * sizeMultiplier;
                    
                    // Calculate segment size with smooth tapering
                    let segmentRadius;
                    const totalSegments = this.segments.length;
                    
                    // Progressive tapering throughout the snake, more aggressive at the tail
                    if (i < totalSegments * 0.7) {
                        // First 70% of snake maintains mostly full size with very slight taper
                        segmentRadius = baseSegmentSize * (1 - i * 0.001) * cameraZoom;
                    } else {
                        // Last 30% tapers more aggressively
                        const tailPosition = (i - totalSegments * 0.7) / (totalSegments * 0.3);
                        // Use exponential curve for smoother taper
                        const taperFactor = Math.pow(1 - tailPosition, 1.5);
                        segmentRadius = baseSegmentSize * (0.8 * taperFactor + 0.2) * cameraZoom;
                    }
                    
                    // Ensure minimum size but allow very small tail tip
                    const segmentPixels = Math.max(1, Math.floor(segmentRadius * 2 / pixelSize));
                    
                    // Skip drawing if segment would be invisible (less than 1 pixel)
                    if (segmentPixels < 1) continue;
                    
                    // Draw main square segment
                    const segmentX = Math.floor(screenX / pixelSize) * pixelSize - segmentPixels * pixelSize / 2;
                    const segmentY = Math.floor(screenY / pixelSize) * pixelSize - segmentPixels * pixelSize / 2;
                    const segmentSize = segmentPixels * pixelSize;
                    
                    // Normal square segment for all (removed diamond shape as it was causing the lump)
                    ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
                    
                    // Spawn invincibility sparkle particles for player
                    if (this.invincibilityTimer > 0 && this.isPlayer) {
                        // Spawn subtle sparkle particles occasionally
                        if (Math.random() < 0.08) { // 8% chance per segment per frame
                            const sparkleAngle = Math.random() * Math.PI * 2;
                            const sparkleSpeed = 0.5 + Math.random() * 1.5;
                            
                            // Convert segment screen position to world position
                            const worldSegX = segment.x;
                            const worldSegY = segment.y;
                            
                            particlePool.spawn(
                                worldSegX,
                                worldSegY,
                                Math.cos(sparkleAngle) * sparkleSpeed,
                                Math.sin(sparkleAngle) * sparkleSpeed,
                                '#FFD700' // Golden sparkles
                            );
                        }
                    }
                }
                
                // Draw head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    
                    // Interpolate head position
                    let headX = head.x;
                    let headY = head.y;
                    let angle = this.angle;
                    
                    if (head.prevX !== undefined && head.prevY !== undefined) {
                        headX = head.prevX + (head.x - head.prevX) * interpolation;
                        headY = head.prevY + (head.y - head.prevY) * interpolation;
                    }
                    
                    if (this.prevAngle !== undefined) {
                        // Handle angle wrapping for smooth interpolation
                        let angleDiff = this.angle - this.prevAngle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        angle = this.prevAngle + angleDiff * interpolation;
                    }
                    
                    // Offset head position forward along the snake direction
                    const offsetDistance = 10; // pixels to move head forward
                    const offsetX = Math.cos(angle) * offsetDistance;
                    const offsetY = Math.sin(angle) * offsetDistance;
                    
                    const screen = worldToScreen(headX + offsetX, headY + offsetY);
                    const screenX = screen.x;
                    const screenY = screen.y;
                    
                    // Draw boost glow around head (desktop only)
                    if (this.isBoosting && !isMobile) {
                        // Pixelated boost effect
                        const pixelSize = 8;
                        const boostColor = this.isPlayer ? 'rgba(100, 200, 255, 0.3)' : 'rgba(255, 100, 100, 0.3)';
                        ctx.fillStyle = boostColor;
                        
                        // Draw pixelated glow pattern
                        for (let px = -3; px <= 3; px++) {
                            for (let py = -3; py <= 3; py++) {
                                if (Math.abs(px) + Math.abs(py) <= 4) {
                                    ctx.fillRect(
                                        Math.floor((screenX + px * pixelSize) / pixelSize) * pixelSize,
                                        Math.floor((screenY + py * pixelSize) / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    }
                    
                    // Spawn invincibility sparkle particles around head for player
                    if (this.invincibilityTimer > 0 && this.isPlayer) {
                        // More frequent particles around the head
                        if (Math.random() < 0.2) { // 20% chance per frame for head
                            // Create a ring of particles around the head
                            const numParticles = 2 + Math.floor(Math.random() * 2);
                            for (let i = 0; i < numParticles; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = SEGMENT_SIZE * sizeMultiplier * 1.5;
                                const particleX = headX + Math.cos(angle) * distance;
                                const particleY = headY + Math.sin(angle) * distance;
                                const speed = 1 + Math.random() * 2;
                                
                                particlePool.spawn(
                                    particleX,
                                    particleY,
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    '#FFD700' // Golden sparkles
                                );
                            }
                        }
                    }
                    
                    // Draw skin image
                    const skinImage = skinImages[this.skin];
                    if (skinImage && skinImage.complete && !skinImage.error) {
                        try {
                            ctx.save();
                            ctx.translate(screenX, screenY);
                            ctx.rotate(angle - Math.PI/2); // Rotate 90 degrees counter-clockwise so top faces body
                            // Increase head size by 15% for regular snakes (not bosses)
                            const baseMultiplier = this.isBoss ? 3.47875 : 3.47875 * 1.15; // 15% increase for non-boss snakes
                            const size = SEGMENT_SIZE * sizeMultiplier * baseMultiplier * cameraZoom;
                            ctx.drawImage(skinImage, -size/2, -size/2, size, size);
                            ctx.restore();
                        } catch (e) {
                            ctx.restore();
                            // Fall through to emoji fallback
                        }
                    } else {
                        // Fallback to emoji if image not loaded
                        const emojiMultiplier = this.isBoss ? 2 : 2 * 1.15; // 15% increase for non-boss snakes
                        const snakeEmojiSize = Math.round(SEGMENT_SIZE * sizeMultiplier * emojiMultiplier * cameraZoom);
                        const snakeEmojiCanvas = getCachedEmoji(this.isPlayer ? '😊' : '🐍', snakeEmojiSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.drawImage(snakeEmojiCanvas, screenX - snakeEmojiCanvas.width / 2, screenY - snakeEmojiCanvas.height / 2);
                        ctx.restore();
                    }
                    
                    // Draw name (with colored personality for AI snakes)
                    const nameFontSize = isMobile ? 11 : 14;
                    ctx.font = `bold ${nameFontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    const nameY = screenY - SEGMENT_SIZE * cameraZoom - 10;
                    
                    // Check for boss first, before checking personality
                    if (this.isBoss) {
                        // Bosses don't show their name, only the skull emoji below
                    } else if (!this.isPlayer && this.personality) {
                        // Split name into personality and actual name parts
                        const personalityName = this.personality.name + ' ';
                        const actualName = this.name.substring(personalityName.length);
                        
                        // Measure text widths
                        ctx.fillStyle = this.personalityColor;
                        const personalityWidth = ctx.measureText(personalityName).width;
                        ctx.fillStyle = 'white';
                        const actualNameWidth = ctx.measureText(actualName).width;
                        const totalWidth = personalityWidth + actualNameWidth;
                        
                        // Draw personality name with color
                        const startX = screenX - totalWidth / 2;
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.strokeText(personalityName, startX + personalityWidth / 2, nameY);
                        ctx.fillStyle = this.personalityColor;
                        ctx.fillText(personalityName, startX + personalityWidth / 2, nameY);
                        
                        // Draw actual name in white
                        ctx.strokeText(actualName, startX + personalityWidth + actualNameWidth / 2, nameY);
                        ctx.fillStyle = 'white';
                        ctx.fillText(actualName, startX + personalityWidth + actualNameWidth / 2, nameY);
                    } else {
                        // Player name or AI without personality - draw normally
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        ctx.fillStyle = 'white';
                        ctx.strokeText(this.name, screenX, nameY);
                        ctx.fillText(this.name, screenX, nameY);
                    }
                    
                    // Draw crown if leader
                    if (this.isLeader) {
                        const crownSize = 24;
                        const crownCanvas = getCachedEmoji('👑', crownSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        // Increased offset from 30 to 45 to move crown higher
                        ctx.drawImage(crownCanvas, screenX - crownCanvas.width / 2, screenY - SEGMENT_SIZE * cameraZoom - 45 - crownCanvas.height / 2);
                        ctx.restore();
                    }
                    
                    // Draw skull if boss
                    if (this.isBoss) {
                        const skullSize = 32; // Larger than crown
                        const skullCanvas = getCachedEmoji('💀', skullSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        // Position skull above head, similar to crown but larger
                        ctx.drawImage(skullCanvas, screenX - skullCanvas.width / 2, screenY - SEGMENT_SIZE * cameraZoom - 50 - skullCanvas.height / 2);
                        ctx.restore();
                    }
                }
                
                // Restore context state for player
                if (this.isPlayer) {
                    ctx.restore();
                }
            }
            
            // Enhanced AI update logic with personalities
            updateAI(deltaTime) {
                const personality = this.personality;
                const currentTime = Date.now();
                
                // Update panic mode
                if (this.panicMode) {
                    this.panicTimer--;
                    if (this.panicTimer <= 0) {
                        this.panicMode = false;
                    }
                }
                
                // Border avoidance (personality-aware)
                const borderDanger = personality.riskTolerance > 0.7 ? 80 : 120;
                const emergencyDistance = personality.riskTolerance > 0.7 ? 40 : 60;
                
                // Check distances to borders
                const distToLeftBorder = this.x;
                const distToRightBorder = WORLD_SIZE - this.x;
                const distToTopBorder = this.y;
                const distToBottomBorder = WORLD_SIZE - this.y;
                
                const nearBorder = distToLeftBorder < borderDanger || distToRightBorder < borderDanger ||
                                  distToTopBorder < borderDanger || distToBottomBorder < borderDanger;
                
                const emergencyTurn = distToLeftBorder < emergencyDistance || distToRightBorder < emergencyDistance ||
                                     distToTopBorder < emergencyDistance || distToBottomBorder < emergencyDistance;
                
                if (emergencyTurn || this.panicMode) {
                    // Emergency evasion with personality-based urgency
                    let avoidAngle = this.angle;
                    const urgency = personality.riskTolerance < 0.5 ? 0.2 : 0.15;
                    
                    if (distToLeftBorder < emergencyDistance) avoidAngle = 0;
                    else if (distToRightBorder < emergencyDistance) avoidAngle = Math.PI;
                    
                    if (distToTopBorder < emergencyDistance) avoidAngle = Math.PI / 2;
                    else if (distToBottomBorder < emergencyDistance) avoidAngle = -Math.PI / 2;
                    
                    let angleDiff = avoidAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    this.angle += angleDiff * urgency;
                    
                    return; // Skip normal AI when in emergency mode
                }
                
                // Enhanced snake collision detection and avoidance
                let dangerVector = { x: 0, y: 0 };
                let nearestThreat = null;
                let nearestPrey = null;
                let threatDistance = Infinity;
                let preyDistance = Infinity;
                let lateralThreats = new Map(); // Track threats by direction - moved here to fix scope issue
                
                // Optimize: Check collisions more frequently for better avoidance
                if (currentTime - this.lastCollisionCheck > 20) { // Check more frequently for better response
                    this.lastCollisionCheck = currentTime;
                    
                    // Add future position prediction - longer for better planning
                    const futureTime = personality.predictiveLookAhead * 1.5; // Increased prediction time
                    const futureX = this.x + Math.cos(this.angle) * this.speed * futureTime * 60;
                    const futureY = this.y + Math.sin(this.angle) * this.speed * futureTime * 60;
                    
                    // Track segment density around us
                    let nearbySegmentCount = 0;
                    const densityRadius = 300; // Increased for better awareness
                    
                    // Vision cone parameters - wider and farther for better detection
                    const visionDistance = 500 + (personality.collisionAvoidanceRadius * 0.8); // Further vision
                    const visionAngle = Math.PI / 1.5; // 120 degree cone (wider)
                    const visionConeAngle = personality.riskTolerance < 0.3 ? visionAngle * 1.3 : visionAngle;
                    
                    // Additional peripheral vision for detecting segments to the side
                    const peripheralDistance = 250 + personality.collisionAvoidanceRadius;
                    const peripheralAngle = Math.PI; // 180 degrees - full side vision
                    
                    // Add lateral scanning rays for better side awareness
                    const lateralCheckAngles = [-Math.PI/2, -Math.PI/4, 0, Math.PI/4, Math.PI/2]; // Check 5 directions
                    lateralThreats.clear(); // Clear previous threats
                    
                    for (const otherSnake of snakes) {
                        if (otherSnake === this || !otherSnake.alive) continue;
                        
                        const dx = otherSnake.x - this.x;
                        const dy = otherSnake.y - this.y;
                        const distanceSq = dx * dx + dy * dy;
                        const distance = Math.sqrt(distanceSq);
                        
                        // Check if this snake is a threat or prey
                        const lengthRatio = otherSnake.length / this.length;
                        
                        // Special Cautious behavior - always avoid player
                        if (personality.playerAvoidanceRadius && otherSnake.isPlayer) {
                            if (distance < personality.playerAvoidanceRadius) {
                                // Treat player as major threat regardless of size
                                const avoidanceWeight = 1 - (distance / personality.playerAvoidanceRadius);
                                dangerVector.x -= (dx / distance) * avoidanceWeight * 3.0;
                                dangerVector.y -= (dy / distance) * avoidanceWeight * 3.0;
                            }
                        }
                        
                        // Threat detection
                        if (lengthRatio > personality.fleeThreshold && distance < 300) {
                            if (distance < threatDistance) {
                                threatDistance = distance;
                                nearestThreat = otherSnake;
                            }
                        }
                        
                        // Prey detection - fixed to use preyRatioMax
                        const isValidPrey = lengthRatio <= personality.preyRatioMax;
                        const inChaseRange = distance < personality.chaseDistance;
                        
                        if (isValidPrey && inChaseRange && personality.huntingPriority > 0) {
                            // Opportunists prefer wounded or very small targets
                            if (personality.preferWeakTargets) {
                                const isWeak = otherSnake.length < this.length * 0.5 || otherSnake.stamina < 30;
                                if (isWeak && distance < preyDistance) {
                                    preyDistance = distance;
                                    nearestPrey = otherSnake;
                                }
                            } else if (distance < preyDistance) {
                                preyDistance = distance;
                                nearestPrey = otherSnake;
                            }
                        }
                        
                        // Check collision with snake body segments
                        // ALWAYS check segments, not just when close to head!
                        const maxCheckDistance = 1000; // Increased check range for better detection
                        
                        // For very long snakes, check every Nth segment for performance
                        const segmentCheckInterval = otherSnake.segments.length > 100 ? 2 : 1; // Check more segments
                        
                        // Always check segments regardless of head distance
                        const startIndex = otherSnake === this ? 5 : 1;
                        for (let i = startIndex; i < otherSnake.segments.length; i += segmentCheckInterval) {
                                const segment = otherSnake.segments[i];
                                const segDx = segment.x - this.x;
                                const segDy = segment.y - this.y;
                                const segDistanceSq = segDx * segDx + segDy * segDy;
                                const segDistance = Math.sqrt(segDistanceSq);
                                
                                // Skip segments that are too far away
                                if (segDistance > maxCheckDistance) continue;
                                
                                // Vision cone check - is this segment in our forward path?
                                const angleToSegment = Math.atan2(segDy, segDx);
                                let angleDiff = angleToSegment - this.angle;
                                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                                
                                const inVisionCone = Math.abs(angleDiff) < visionConeAngle / 2 && segDistance < visionDistance;
                                const inPeripheral = Math.abs(angleDiff) < peripheralAngle / 2 && segDistance < peripheralDistance;
                                
                                // Also check future collision
                                const futureDx = segment.x - futureX;
                                const futureDy = segment.y - futureY;
                                const futureDistanceSq = futureDx * futureDx + futureDy * futureDy;
                                const futureDistance = Math.sqrt(futureDistanceSq);
                                
                                // Use the closer of current or future distance
                                const effectiveDistance = Math.min(segDistance, futureDistance);
                                
                                // Use appropriate check radius based on distance
                                const checkRadius = effectiveDistance < personality.collisionAvoidanceRadius ? 
                                                  personality.collisionAvoidanceRadius : 
                                                  personality.dangerZoneRadius;
                                
                                if (effectiveDistance < checkRadius || inVisionCone || inPeripheral) {
                                    // Check if this is a head or body segment
                                    const isHead = i === 0;
                                    
                                    // For aggressive snakes targeting player, don't avoid the head if we're similar size
                                    if (isHead && personality.huntingPriority > 0.7 && otherSnake.isPlayer) {
                                        const sizeRatio = this.length / otherSnake.length;
                                        if (sizeRatio >= 0.8 && sizeRatio <= 1.5) {
                                            continue; // Skip head avoidance for aggressive head-on attacks
                                        }
                                    }
                                    
                                    // Much stronger weight calculation for close segments
                                    const proximityWeight = effectiveDistance < 80 ? 
                                                          3.0 : // Triple weight for very close segments
                                                          effectiveDistance < 150 ?
                                                          2.0 : // Double weight for close segments
                                                          (1 - (effectiveDistance / checkRadius));
                                    
                                    // Stronger avoidance for body segments vs heads
                                    const bodyMultiplier = isHead ? 1.0 : personality.bodyAvoidanceMultiplier;
                                    const strengthMultiplier = personality.avoidanceStrength * bodyMultiplier;
                                    
                                    // Higher multipliers for different detection zones
                                    let visionMultiplier = 1.0;
                                    if (inVisionCone && effectiveDistance < 150) {
                                        visionMultiplier = 6.0; // Very high weight for segments directly ahead
                                    } else if (inVisionCone && effectiveDistance < 300) {
                                        visionMultiplier = 4.0;
                                    } else if (inVisionCone) {
                                        visionMultiplier = 3.0;
                                    } else if (inPeripheral) {
                                        visionMultiplier = 2.5; // Better weight for peripheral segments
                                    }
                                    
                                    const weight = proximityWeight * strengthMultiplier * 4 * visionMultiplier; // Increased base multiplier
                                    
                                    // Extra weight for player snake segments (they're more dangerous)
                                    const playerMultiplier = otherSnake.isPlayer ? 2.5 : 1.0; // Increased from 2.0
                                    
                                    // Use future position for avoidance if it's closer
                                    if (futureDistance < segDistance) {
                                        dangerVector.x -= (futureDx / futureDistance) * weight * playerMultiplier;
                                        dangerVector.y -= (futureDy / futureDistance) * weight * playerMultiplier;
                                    } else {
                                        dangerVector.x -= (segDx / segDistance) * weight * playerMultiplier;
                                        dangerVector.y -= (segDy / segDistance) * weight * playerMultiplier;
                                    }
                                    
                                    // Count nearby segments for density check
                                    if (segDistance < densityRadius) {
                                        nearbySegmentCount++;
                                    }
                                    
                                    // Track lateral threats for smarter navigation
                                    for (const checkAngle of lateralCheckAngles) {
                                        const rayAngle = this.angle + checkAngle;
                                        const rayDx = segment.x - (this.x + Math.cos(rayAngle) * 100);
                                        const rayDy = segment.y - (this.y + Math.sin(rayAngle) * 100);
                                        const rayDist = Math.sqrt(rayDx * rayDx + rayDy * rayDy);
                                        
                                        if (rayDist < 150) { // Threat detected in this direction
                                            const currentThreat = lateralThreats.get(checkAngle) || 0;
                                            lateralThreats.set(checkAngle, currentThreat + (150 - rayDist) / 150);
                                        }
                                    }
                                }
                            }
                    }
                    
                    // Add density-based danger if area is crowded
                    if (nearbySegmentCount > 8) { // Lower threshold for better response
                        const densityFactor = Math.min(nearbySegmentCount / 15, 1.0); // Cap at 1.0
                        dangerVector.x *= (1 + densityFactor * 0.8); // Stronger amplification
                        dangerVector.y *= (1 + densityFactor * 0.8);
                    }
                }
                
                // Decision making based on personality and situation
                let targetAngle = null;
                let shouldBoost = false;
                
                // Priority 1: Avoid immediate collisions - much lower threshold
                const dangerMagnitudeSq = dangerVector.x * dangerVector.x + dangerVector.y * dangerVector.y;
                const dangerMagnitude = Math.sqrt(dangerMagnitudeSq);
                if (dangerMagnitude > 0.05) { // Reduced threshold for faster response
                    // Calculate escape angle - opposite of danger
                    targetAngle = Math.atan2(dangerVector.y, dangerVector.x);
                    
                    // Add smart escape logic with lateral awareness
                    const escapeAngles = [];
                    const angleSteps = 16; // More angles for better path finding
                    
                    // Use lateral threat data to find safest initial direction
                    let safestDirection = 0;
                    let minThreat = Infinity;
                    for (const [angle, threat] of lateralThreats) {
                        if (threat < minThreat) {
                            minThreat = threat;
                            safestDirection = angle;
                        }
                    }
                    
                    for (let i = 0; i < angleSteps; i++) {
                        // Bias search toward safer lateral directions
                        const biasedAngle = targetAngle + safestDirection * 0.3;
                        const testAngle = biasedAngle + (i * Math.PI * 2 / angleSteps);
                        let clearDistance = 0;
                        let narrowestGap = Infinity;
                        let pathScore = 0;
                        
                        // Check how clear this direction is with finer granularity
                        const checkStep = 15;
                        for (let dist = checkStep; dist < personality.collisionAvoidanceRadius * 1.2; dist += checkStep) {
                            const checkX = this.x + Math.cos(testAngle) * dist;
                            const checkY = this.y + Math.sin(testAngle) * dist;
                            let blocked = false;
                            let minDist = Infinity;
                            
                            // Quick check against all snake segments
                            for (const snake of snakes) {
                                if (snake === this || !snake.alive) continue;
                                // Skip head check for aggressive snakes hunting player
                                const startJ = (snake.isPlayer && personality.huntingPriority > 0.7) ? 1 : 0;
                                const checkInterval = snake.segments.length > 100 ? 2 : 1;
                                
                                for (let j = startJ; j < snake.segments.length; j += checkInterval) {
                                    const segment = snake.segments[j];
                                    const sdx = segment.x - checkX;
                                    const sdy = segment.y - checkY;
                                    const segDist = Math.sqrt(sdx * sdx + sdy * sdy);
                                    
                                    minDist = Math.min(minDist, segDist);
                                    
                                    // Tighter gaps for aggressive, wider for cautious
                                    const threshold = personality.riskTolerance > 0.7 ? 25 : 35;
                                    if (segDist < threshold) {
                                        blocked = true;
                                        break;
                                    }
                                }
                                if (blocked) break;
                            }
                            
                            narrowestGap = Math.min(narrowestGap, minDist);
                            
                            if (blocked) break;
                            clearDistance = dist;
                            
                            // Reward wider paths
                            if (minDist > 60) pathScore += 2;
                            else if (minDist > 40) pathScore += 1;
                        }
                        
                        // Calculate overall score considering distance, gap width, and path quality
                        const score = clearDistance + 
                                     (narrowestGap > 50 ? narrowestGap : narrowestGap * 0.5) +
                                     pathScore * 10;
                        
                        escapeAngles.push({ angle: testAngle, score, clearDistance, narrowestGap });
                    }
                    
                    // Sort by score and pick best option based on personality
                    escapeAngles.sort((a, b) => b.score - a.score);
                    
                    // Aggressive snakes willing to take tighter paths
                    if (personality.riskTolerance > 0.8 && escapeAngles[0].narrowestGap > 30) {
                        targetAngle = escapeAngles[0].angle;
                    } else {
                        // Cautious snakes prefer wider gaps
                        const safeOptions = escapeAngles.filter(e => e.narrowestGap > 45);
                        targetAngle = safeOptions.length > 0 ? safeOptions[0].angle : escapeAngles[0].angle;
                    }
                    
                    // Boost decision based on danger level - more aggressive
                    shouldBoost = dangerMagnitude > 0.2 || personality.riskTolerance < 0.7; // Lower thresholds
                    
                    // Enter panic mode if danger is very high - more sensitive
                    if (dangerMagnitude > 0.3) { // Reduced from 0.5
                        this.panicMode = true;
                        this.panicTimer = 120; // 2 seconds at 60fps (increased from 1.5)
                    }
                }
                // Priority 2: Flee from threats
                else if (nearestThreat && threatDistance < 200) {
                    const dx = nearestThreat.x - this.x;
                    const dy = nearestThreat.y - this.y;
                    targetAngle = Math.atan2(-dy, -dx); // Opposite direction
                    shouldBoost = personality.riskTolerance < 0.7 && this.stamina > 40;
                }
                // Priority 3: Hunt prey (aggressive personalities)
                else if (nearestPrey) {
                    // For aggressive personalities, ALWAYS prioritize hunting over elements
                    const shouldHunt = personality.huntingPriority > 0.8 || 
                                     (personality.huntingPriority > 0.5 && preyDistance < 150);
                    
                    if (shouldHunt) {
                        // Predict where the prey's head will be to eat them
                        const predictedPos = this.predictHeadPosition(nearestPrey);
                        if (predictedPos) {
                            const dx = predictedPos.x - this.x;
                            const dy = predictedPos.y - this.y;
                            targetAngle = Math.atan2(dy, dx);
                        } else {
                            // Fallback to current head position
                            const dx = nearestPrey.x - this.x;
                            const dy = nearestPrey.y - this.y;
                            targetAngle = Math.atan2(dy, dx);
                        }
                        
                        shouldBoost = this.stamina > 30 && preyDistance < 200;
                        
                        // Override element seeking for aggressive snakes
                        this.targetMemory = null;
                        this.targetMemoryTimer = 0;
                    }
                }
                // Priority 4: Seek game objectives
                else {
                    // Aggressive personalities should still look for prey opportunities
                    if (personality.huntingPriority > 0.7 && Math.random() < personality.elementIgnoreChance) {
                        // Scan for any snakes we might have missed
                        for (const otherSnake of snakes) {
                            if (otherSnake === this || !otherSnake.alive) continue;
                            const dist = Math.hypot(otherSnake.x - this.x, otherSnake.y - this.y);
                            if (dist < personality.chaseDistance * 0.7 && otherSnake.length < this.length) {
                                // Found a target! Predict head position to eat them
                                const predictedPos = this.predictHeadPosition(otherSnake);
                                if (predictedPos) {
                                    const dx = predictedPos.x - this.x;
                                    const dy = predictedPos.y - this.y;
                                    targetAngle = Math.atan2(dy, dx);
                                    shouldBoost = this.stamina > 40 && dist < 200;
                                }
                                break;
                            }
                        }
                    }
                    
                    // If still no target, seek elements
                    if (targetAngle === null) {
                        let target = null;
                        
                        // Use cached target for a few frames to reduce computation
                        if (this.targetMemory && this.targetMemoryTimer > 0) {
                            target = this.targetMemory;
                            this.targetMemoryTimer--;
                        } else {
                        // Find new target based on personality
                        if (this.elements.length >= this.elementCapacity) {
                            // At capacity - prioritize Void Orbs
                            let nearestVoidOrb = null;
                            let minVoidDist = 800;
                            
                            for (const orb of voidOrbs) {
                                const dist = Math.hypot(orb.x - this.x, orb.y - this.y);
                                if (dist < minVoidDist && !this.isPathBlocked(orb.x, orb.y, dist)) {
                                    minVoidDist = dist;
                                    nearestVoidOrb = orb;
                                }
                            }
                            target = nearestVoidOrb;
                        }
                        
                        // Check for Catalyst Gems (combo-focused personalities prioritize these)
                        if (!target && this.elements.length > 0 && personality.comboPriority > Math.random()) {
                            let nearestCatalystGem = null;
                            let minCatalystDist = 600;
                            
                            for (const gem of catalystGems) {
                                const dist = Math.hypot(gem.x - this.x, gem.y - this.y);
                                if (dist < minCatalystDist && !this.isPathBlocked(gem.x, gem.y, dist)) {
                                    minCatalystDist = dist;
                                    nearestCatalystGem = gem;
                                }
                            }
                            target = nearestCatalystGem;
                        }
                        
                        // Find nearest element if no special targets
                        if (!target) {
                            let nearestElement = null;
                            let minDist = 500;
                            
                            for (const element of elementPool.getActiveElements()) {
                                const dist = Math.hypot(element.x - this.x, element.y - this.y);
                                if (dist < minDist && !this.isPathBlocked(element.x, element.y, dist)) {
                                    minDist = dist;
                                    nearestElement = element;
                                }
                            }
                            target = nearestElement;
                        }
                        
                        // Cache the target
                        this.targetMemory = target;
                        this.targetMemoryTimer = 30; // Cache for 30 frames
                    }
                    
                    if (target) {
                        targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                        
                        // Boost decision based on personality and distance
                        const targetDist = Math.hypot(target.x - this.x, target.y - this.y);
                        if (targetDist > 300 && this.stamina > (personality.boostThreshold * 100)) {
                            shouldBoost = true;
                        }
                    }
                    } // Close the if (targetAngle === null) check
                }
                
                // Apply turning with personality-based smoothness
                if (targetAngle !== null) {
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Dynamic turn speed based on situation - increased for better response
                    let turnSpeed;
                    if (this.panicMode || dangerMagnitude > 0.2) { // Lower threshold
                        // Emergency turn - much faster
                        turnSpeed = 0.20 + (personality.avoidanceStrength * 0.15); // Increased turn rates
                    } else if (dangerMagnitude > 0.1) {
                        // High danger - very fast turn
                        turnSpeed = 0.18 + (personality.avoidanceStrength * 0.1);
                    } else if (nearestThreat && threatDistance < 200) {
                        // Fleeing - fast turn
                        turnSpeed = 0.15;
                    } else {
                        // Normal turn - personality-based
                        turnSpeed = personality.riskTolerance > 0.7 ? 0.10 : 0.08; // Slightly increased
                    }
                    
                    this.angle += angleDiff * turnSpeed;
                } else {
                    // Wander with personality-based randomness
                    const wanderAmount = personality.riskTolerance * 0.05;
                    this.angle += (Math.random() - 0.5) * wanderAmount;
                }
                
                // Set boost state
                this.isBoosting = shouldBoost && this.stamina > 20 && !nearBorder;
            }
            
            // Helper method for predicting head position to eat smaller snakes
            predictHeadPosition(targetSnake) {
                if (!targetSnake || !targetSnake.segments || targetSnake.segments.length === 0) {
                    return null;
                }
                
                // Get the head position
                const head = targetSnake.segments[0];
                const targetSpeed = targetSnake.speed || SNAKE_SPEED;
                const distance = Math.hypot(head.x - this.x, head.y - this.y);
                
                // Calculate time to intercept
                const relativeSpeed = this.speed * 1.5; // Assume we'll boost
                const interceptTime = distance / relativeSpeed;
                
                // Predict where the head will be
                const predictedX = head.x + Math.cos(targetSnake.angle) * targetSpeed * interceptTime;
                const predictedY = head.y + Math.sin(targetSnake.angle) * targetSpeed * interceptTime;
                
                return { x: predictedX, y: predictedY };
            }
            
            // Helper method for enhanced pathfinding
            isPathBlocked(targetX, targetY, distance) {
                // Check more thoroughly for nearby targets
                const checkDistance = Math.min(distance, 400); // Check further ahead
                const steps = Math.floor(checkDistance / 12); // Finer granularity
                if (steps <= 1) return false;
                
                const stepX = (targetX - this.x) / steps;
                const stepY = (targetY - this.y) / steps;
                
                // Also check perpendicular to the path for wider clearance
                // Aggressive snakes check narrower paths
                const clearanceWidth = this.personality.riskTolerance > 0.7 ? 20 : 30;
                const perpX = -stepY / Math.hypot(stepX, stepY) * clearanceWidth;
                const perpY = stepX / Math.hypot(stepX, stepY) * clearanceWidth;
                
                for (let i = 1; i < steps; i++) {
                    const checkX = this.x + stepX * i;
                    const checkY = this.y + stepY * i;
                    
                    // Check center and both sides of the path
                    const checkPoints = [
                        { x: checkX, y: checkY },
                        { x: checkX + perpX, y: checkY + perpY },
                        { x: checkX - perpX, y: checkY - perpY }
                    ];
                    
                    for (const point of checkPoints) {
                        // Check if this point is too close to any snake body
                        for (const snake of snakes) {
                            if (!snake.alive) continue;
                            
                            // For self, check from segment 5 onward
                            // For others, check from segment 1
                            const startIndex = snake === this ? 5 : 1;
                            
                            for (let j = startIndex; j < snake.segments.length; j++) {
                                const segment = snake.segments[j];
                                const segDist = Math.hypot(segment.x - point.x, segment.y - point.y);
                                
                                const threshold = snake === this ? 50 : SEGMENT_SIZE * 2.5;
                                if (segDist < threshold) {
                                    return true; // Path is blocked
                                }
                            }
                        }
                    }
                }
                
                return false; // Path is clear
            }
        }
        
        // Element class
        class Element {
            constructor(id, x, y, isCatalystSpawned = false) {
                this.id = id;
                this.x = x;
                this.y = y;
                
                // Get element data from new system
                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                    const elem = window.elementLoader.elements.get(id);
                    if (elem) {
                        this.data = {
                            emoji: window.elementLoader.getEmojiForElement(id, elem.e),
                            name: elem.n,
                            tier: elem.t,
                            base: elem.t === 0
                        };
                    }
                }
                
                // Fallback if element not found
                if (!this.data) {
                    console.warn(`Element ID ${id} not found`);
                    this.data = { emoji: '❓', name: 'Unknown', tier: 0 };
                }
                this.pulse = 0;
                this.isCatalystSpawned = isCatalystSpawned;
                this.catalystSparkleTime = 0;
                this.pendingCombination = false;
                this.combiningAnimation = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                if (this.isCatalystSpawned) {
                    this.catalystSparkleTime += 0.1 * deltaTime;
                }
                
                // Magnetism effect - draw elements toward nearby snakes
                const magnetRange = 100; // Range at which magnetism starts
                const magnetStrength = 4.0; // Speed of attraction
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    // Check distance to snake head
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    
                    // Apply magnetism if within range
                    if (distance < magnetRange && distance > ELEMENT_SIZE) {
                        // Calculate normalized direction vector
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        
                        // Stronger pull when closer
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength * deltaTime;
                        
                        // Move element toward snake
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                let scale = 1 + Math.sin(this.pulse || 0) * 0.1;
                
                // Add wobble effect if this element is about to combine
                if (this.pendingCombination) {
                    this.combiningAnimation += 0.15;
                    const wobble = Math.sin(this.combiningAnimation * 3) * 0.1;
                    scale = scale * (1 + wobble);
                }
                
                // Check if this element is compatible with player's tail during AlchemyVision
                let alchemyGlow = null;
                if (alchemyVisionActive && playerSnake && playerSnake.alive && playerSnake.elements.length > 0) {
                    const tailElement = playerSnake.elements[playerSnake.elements.length - 1];
                    const distance = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    
                    // Only show glows within 300 pixel radius
                    if (distance <= 300) {
                        // Check if this element can combine with tail
                        const combo1 = `${this.id}+${tailElement}`;
                        const combo2 = `${tailElement}+${this.id}`;
                        
                        if (combinations[combo1] || combinations[combo2]) {
                            const result = combinations[combo1] || combinations[combo2];
                            // Check if this is a new discovery
                            if (!discoveredElements.has(result)) {
                                alchemyGlow = 'discovery'; // Golden glow
                            } else {
                                alchemyGlow = 'known'; // Green glow
                            }
                        }
                    }
                }
                
                // Skip all glow effects on mobile for better performance
                if (!isMobile) {
                    // Draw pixelated combination glow if this element will combine when eaten
                    if (this.pendingCombination) {
                        const pixelSize = 8;
                        const glowIntensity = 0.3 + Math.sin(Date.now() * 0.005) * 0.3; // Pulsing glow
                        ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity})`;
                        
                        // Draw larger pixelated glow pattern
                        for (let px = -4; px <= 4; px++) {
                            for (let py = -4; py <= 4; py++) {
                                if (Math.abs(px) + Math.abs(py) <= 6) {
                                    ctx.fillRect(
                                        Math.floor((screenX + px * pixelSize) / pixelSize) * pixelSize,
                                        Math.floor((screenY + py * pixelSize) / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    }
                    
                    // Draw pixelated glow effects
                    else if (alchemyGlow === 'discovery') {
                        // Golden pixels for new discoveries
                        const pixelSize = 6;
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                        
                        for (let px = -4; px <= 4; px++) {
                            for (let py = -4; py <= 4; py++) {
                                if (Math.abs(px) + Math.abs(py) <= 6) {
                                    ctx.fillRect(
                                        Math.floor((screenX + px * pixelSize) / pixelSize) * pixelSize,
                                        Math.floor((screenY + py * pixelSize) / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    } else if (alchemyGlow === 'known') {
                        // Green pixels for known combinations
                        const pixelSize = 6;
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                        
                        for (let px = -3; px <= 3; px++) {
                            for (let py = -3; py <= 3; py++) {
                                if (Math.abs(px) + Math.abs(py) <= 4) {
                                    ctx.fillRect(
                                        Math.floor((screenX + px * pixelSize) / pixelSize) * pixelSize,
                                        Math.floor((screenY + py * pixelSize) / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    } else if (this.data && this.data.tier > 0) {
                        // Pixelated tier-based glow
                        const pixelSize = 6;
                        const hue = (this.data.tier * 60) % 360;
                        ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.4)`;
                        
                        for (let px = -2; px <= 2; px++) {
                            for (let py = -2; py <= 2; py++) {
                                if (Math.abs(px) + Math.abs(py) <= 3) {
                                    ctx.fillRect(
                                        Math.floor((screenX + px * pixelSize) / pixelSize) * pixelSize,
                                        Math.floor((screenY + py * pixelSize) / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    }
                }
                
                // Draw emoji using cache
                const emojiSize = Math.round(ELEMENT_SIZE * 2 * scale * cameraZoom);
                const emoji = this.data ? window.elementLoader.getEmojiForElement(this.id, this.data.base ? this.id : window.elementLoader.elements.get(this.id)?.e || this.id) : '❓';
                const emojiCanvas = getCachedEmoji(emoji, emojiSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(emojiCanvas, screenX - emojiCanvas.width / 2, screenY - emojiCanvas.height / 2);
                ctx.restore();
                
                // Draw element name below emoji
                const elementNameFontSize = isMobile ? 10 : 12;
                ctx.font = `${elementNameFontSize}px Arial`;
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                const name = this.data ? this.data.name : 'Unknown';
                ctx.strokeText(name, screenX, screenY + ELEMENT_SIZE * cameraZoom + 5);
                ctx.fillText(name, screenX, screenY + ELEMENT_SIZE * cameraZoom + 5);
                
                // Draw catalyst sparkles if this element was spawned by catalyst (desktop only)
                if (this.isCatalystSpawned && !isMobile) {
                    ctx.save();
                    for (let i = 0; i < 4; i++) {
                        const angle = (this.catalystSparkleTime + i * Math.PI / 2) % (Math.PI * 2);
                        const dist = (ELEMENT_SIZE * cameraZoom) + 10 + Math.sin(this.catalystSparkleTime * 2) * 5;
                        const px = screenX + Math.cos(angle) * dist;
                        const py = screenY + Math.sin(angle) * dist;
                        
                        ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add a small star
                        const sparkleCanvas = getCachedEmoji('✨', 12);
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.drawImage(sparkleCanvas, px - sparkleCanvas.width / 2, py - sparkleCanvas.height / 2);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
        
        // AlchemyVision power-up class
        class AlchemyVision {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                this.rotation += 0.02 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetRangeSq = magnetRange * magnetRange;
                const magnetStrength = 5.0; // Stronger pull for power-ups
                const sizeSq = this.size * this.size;
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < magnetRangeSq && distanceSq > sizeSq) {
                        const distance = Math.sqrt(distanceSq);
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength * deltaTime;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Purple/gold glow effect
                const glowSize = this.size * 2 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)'); // Gold
                gradient.addColorStop(0.5, 'rgba(147, 0, 211, 0.4)'); // Purple
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Crystal ball emoji
                const crystalSize = Math.round(this.size * 2 * scale);
                const crystalCanvas = getCachedEmoji('🔮', crystalSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(crystalCanvas, -crystalCanvas.width / 2, -crystalCanvas.height / 2);
                ctx.restore();
                
                // Swirling particles
                for (let i = 0; i < 3; i++) {
                    const angle = (this.rotation * 2) + (i * Math.PI * 2 / 3);
                    const dist = this.size * scale;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(255, 215, 0, 0.8)' : 'rgba(147, 0, 211, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // VoidOrb class
        class VoidOrb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                this.rotation += 0.03 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetRangeSq = magnetRange * magnetRange;
                const magnetStrength = 5.0; // Stronger pull for power-ups
                const sizeSq = this.size * this.size;
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < magnetRangeSq && distanceSq > sizeSq) {
                        const distance = Math.sqrt(distanceSq);
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Blue glow effect
                const glowSize = this.size * 2 * scale * cameraZoom;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(0, 150, 255, 0.6)'); // Bright blue
                gradient.addColorStop(0.5, 'rgba(0, 50, 200, 0.4)'); // Dark blue
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Void orb emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale * cameraZoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('🌀', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Swirling particles
                for (let i = 0; i < 4; i++) {
                    const angle = (this.rotation * 3) + (i * Math.PI / 2);
                    const dist = this.size * scale * 0.8 * cameraZoom;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2 * cameraZoom, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // CatalystGem class
        class CatalystGem {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
                this.sparkleTime = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.04 * deltaTime;
                this.rotation += 0.02 * deltaTime;
                this.sparkleTime += 0.1 * deltaTime;
                
                // Magnetism effect
                const magnetRange = 120; // Slightly larger range for power-ups
                const magnetRangeSq = magnetRange * magnetRange;
                const magnetStrength = 5.0; // Stronger pull for power-ups
                const sizeSq = this.size * this.size;
                
                for (const snake of snakes) {
                    if (!snake.alive) continue;
                    
                    const dx = snake.x - this.x;
                    const dy = snake.y - this.y;
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < magnetRangeSq && distanceSq > sizeSq) {
                        const distance = Math.sqrt(distanceSq);
                        const dirX = dx / distance;
                        const dirY = dy / distance;
                        const pullStrength = (1 - distance / magnetRange) * magnetStrength;
                        
                        this.x += dirX * pullStrength;
                        this.y += dirY * pullStrength;
                    }
                }
            }
            
            draw() {
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.15;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Orange glow effect
                const glowSize = this.size * 2.5 * scale * cameraZoom;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Bright orange
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)'); // Dark orange
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Catalyst gem emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale * cameraZoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('💎', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Sparkle particles
                for (let i = 0; i < 6; i++) {
                    const angle = (this.sparkleTime + i * Math.PI / 3) % (Math.PI * 2);
                    const dist = this.size * scale * (0.8 + Math.sin(this.sparkleTime * 2 + i) * 0.3) * cameraZoom;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
                    ctx.beginPath();
                    ctx.arc(px, py, (2 + Math.sin(this.sparkleTime * 3 + i) * 1) * cameraZoom, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color, size = 4) {
                this.reset(x, y, vx, vy, color, size);
            }
            
            reset(x, y, vx, vy, color, size = 4) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.life = 1;
                this.active = true;
            }
            
            update(deltaTime = 1) {
                if (!this.active) return false;
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.life -= 0.02 * deltaTime;
                this.vx *= Math.pow(0.98, deltaTime);
                this.vy *= Math.pow(0.98, deltaTime);
                
                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }
                return true;
            }
            
            draw() {
                if (!this.active) return;
                
                const pixelSize = 4;
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                
                // Draw as pixel square
                ctx.fillRect(
                    Math.floor(screenX / pixelSize) * pixelSize,
                    Math.floor(screenY / pixelSize) * pixelSize,
                    this.size,
                    this.size
                );
                
                ctx.restore();
            }
        }
        
        // Object pools for performance
        class ParticlePool {
            constructor(size = 200) {
                this.pool = [];
                this.activeParticles = [];
                this.poolSize = size;
                
                // Pre-allocate particles
                for (let i = 0; i < size; i++) {
                    this.pool.push(new Particle(0, 0, 0, 0, 'white'));
                }
                
                // Pre-warm the pool by cycling through particles
                this.preWarm();
            }
            
            preWarm() {
                // Temporarily activate and deactivate particles to warm up memory
                const warmupCount = Math.min(50, this.poolSize);
                const tempParticles = [];
                for (let i = 0; i < warmupCount; i++) {
                    tempParticles.push(this.spawn(0, 0, 0, 0, 'white'));
                }
                // Return them to pool
                tempParticles.forEach(p => {
                    p.active = false;
                    p.life = 0;
                });
                this.update();
            }
            
            spawn(x, y, vx, vy, color, size = 4) {
                let particle = this.pool.pop();
                if (!particle) {
                    // Pool is empty, create new particle
                    particle = new Particle(x, y, vx, vy, color, size);
                } else {
                    particle.reset(x, y, vx, vy, color, size);
                }
                this.activeParticles.push(particle);
                return particle;
            }
            
            update(deltaTime = 1) {
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    if (!particle.update(deltaTime)) {
                        // Return to pool
                        this.activeParticles.splice(i, 1);
                        this.pool.push(particle);
                    }
                }
            }
            
            draw() {
                this.activeParticles.forEach(particle => {
                    if (isInViewport(particle.x, particle.y, 50)) {
                        particle.draw();
                    }
                });
            }
            
            getActiveCount() {
                return this.activeParticles.length;
            }
        }
        
        // Initialize particle pool
        const particlePool = new ParticlePool(isMobile ? 50 : 200); // Further reduced for mobile performance
        
        // Element pool for performance
        class ElementPool {
            constructor(size = 50) {
                this.pool = [];
                this.activeElements = [];
            }
            
            spawn(id, x, y, isCatalystSpawned = false) {
                let element = this.pool.pop();
                if (!element) {
                    element = new Element(id, x, y, isCatalystSpawned);
                } else {
                    // Reset existing element
                    element.id = id;
                    element.x = x;
                    element.y = y;
                    
                    // Get element data from new system
                    const elem = window.elementLoader.elements.get(id);
                    if (elem) {
                        element.data = {
                            emoji: window.elementLoader.getEmojiForElement(id, elem.e),
                            name: elem.n,
                            tier: elem.t,
                            base: elem.t === 0
                        };
                    } else {
                        console.warn(`Element ID ${id} not found`);
                        element.data = { emoji: '❓', name: 'Unknown', tier: 0 };
                    }
                    element.pulse = 0;
                    element.isCatalystSpawned = isCatalystSpawned;
                    element.catalystSparkleTime = 0;
                }
                this.activeElements.push(element);
                return element;
            }
            
            remove(element) {
                const index = this.activeElements.indexOf(element);
                if (index > -1) {
                    this.activeElements.splice(index, 1);
                    this.pool.push(element);
                }
            }
            
            update(deltaTime = 1) {
                this.activeElements.forEach(element => element.update(deltaTime));
            }
            
            draw() {
                this.activeElements.forEach(element => {
                    if (isInViewport(element.x, element.y, ELEMENT_SIZE + 50)) {
                        element.draw();
                    }
                });
            }
            
            getActiveElements() {
                return this.activeElements;
            }
            
            getActiveCount() {
                return this.activeElements.length;
            }
        }
        
        // Initialize element pool
        const elementPool = new ElementPool();
        
        // Shooting Star class
        class ShootingStar {
            constructor() {
                // Random starting position on screen edge
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // Top
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = 0;
                        break;
                    case 1: // Right
                        this.x = WORLD_SIZE;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = WORLD_SIZE;
                        break;
                    case 3: // Left
                        this.x = 0;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                }
                
                // Random angle and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = 15 + Math.random() * 10; // Fast movement
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.trail = [];
                this.maxTrailLength = isMobile ? 5 : 20; // Shorter trails on mobile
                this.life = 1.0;
                this.fadeSpeed = 0.01; // Slower fade for 1-2 second visibility
                
                // Add color variety
                const colorSchemes = [
                    { star: '#FFFF00', trail: '#FFFFFF' }, // Classic yellow/white
                    { star: '#00FFFF', trail: '#E0FFFF' }, // Cyan/light blue
                    { star: '#FFE4B5', trail: '#FFF8DC' }, // Pale yellow/cream
                    { star: '#FF69B4', trail: '#FFB6C1' }, // Pink/light pink
                    { star: '#98FB98', trail: '#F0FFF0' }  // Pale green/honeydew
                ];
                const scheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
                this.starColor = scheme.star;
                this.trailColor = scheme.trail;
            }
            
            update(deltaTime = 1) {
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y, alpha: this.life });
                
                // Limit trail length
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Fade out
                this.life -= this.fadeSpeed * deltaTime;
                
                // Update trail alpha
                this.trail.forEach((point, index) => {
                    point.alpha = (index / this.trail.length) * this.life;
                });
                
                // Check if out of bounds or faded
                return this.life > 0 && this.x > -100 && this.x < WORLD_SIZE + 100 && 
                       this.y > -100 && this.y < WORLD_SIZE + 100;
            }
            
            draw() {
                // Draw pixelated trail
                const pixelSize = 2;
                ctx.save();
                
                this.trail.forEach((point, index) => {
                    const screenX = point.x - camera.x + canvas.width / 2;
                    const screenY = point.y - camera.y + canvas.height / 2;
                    
                    ctx.globalAlpha = point.alpha * 0.5;
                    ctx.fillStyle = this.trailColor;
                    const size = Math.max(pixelSize, Math.floor((index / this.trail.length) * 3) * pixelSize);
                    
                    ctx.fillRect(
                        Math.floor(screenX / pixelSize) * pixelSize,
                        Math.floor(screenY / pixelSize) * pixelSize,
                        size,
                        size
                    );
                });
                
                // Draw main star as pixel
                const screen = worldToScreen(this.x, this.y);
                const screenX = screen.x;
                const screenY = screen.y;
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.starColor;
                ctx.fillRect(
                    Math.floor(screenX / pixelSize) * pixelSize,
                    Math.floor(screenY / pixelSize) * pixelSize,
                    pixelSize * 3,
                    pixelSize * 3
                );
                
                ctx.restore();
            }
        }
        
        // Boss class - extends Snake with special abilities
        class Boss extends Snake {
            constructor(bossType, x, y) {
                super(x, y, false);
                this.isBoss = true; // Set this early to prevent personality assignment
                
                // Boss configuration
                this.bossType = bossType;
                const bossData = BOSS_TYPES[bossType];
                this.baseName = bossData.name; // Store the original base name
                this.isUndead = bossIsUndead;
                this.name = bossIsUndead ? `Undead ${bossData.name}` : bossData.name;
                this.maxHealth = bossIsUndead ? bossData.maxHealth * 2 : bossData.maxHealth;
                this.health = this.maxHealth;
                this.elementType = bossData.element;
                this.elementId = bossData.elementId;
                this.color = bossData.color;
                this.emoji = bossData.emoji;
                this.attackCooldown = bossData.attackCooldown;
                this.skin = bossData.skin;
                this.attackSound = bossData.attackSound;
                
                // Boss-specific properties
                this.isBoss = true;
                this.size = 3; // 300% larger than normal snakes
                this.length = 30; // Longer than normal snakes
                this.speed = SNAKE_SPEED * 0.8; // 80% of normal speed (20% slower)
                this.baseSpeed = SNAKE_SPEED * 0.8;
                this.attackTimer = 0;
                this.introAnimationTimer = 120; // 2 seconds of intro animation
                this.damageFlashTimer = 0;
                this.stunTimer = 0;
                this.invulnerabilityTimer = 0; // Post-stun invulnerability
                
                // Stationary attack phase management
                this.attackPhase = false;
                this.attackPhaseTimer = 0;
                this.attackPhaseDuration = 180; // 3 seconds
                this.chasePhaseDuration = 240; // 4 seconds
                this.phaseTimer = this.chasePhaseDuration; // Start in chase phase
                
                // Laugh sound management
                this.laughCooldown = 0;
                this.nextLaughDelay = 15000 + Math.random() * 10000; // 15-25 seconds
                
                // Special attack counter for Zephyrus vacuum
                this.specialAttackCounter = 0;
                this.vacuumAttackInterval = 4; // Use vacuum every 4th attack
                
                // Override segment initialization for longer boss
                this.segments = [];
                for (let i = 0; i < this.length; i++) {
                    const segX = x - i * SEGMENT_SIZE * this.size * Math.cos(this.angle);
                    const segY = y - i * SEGMENT_SIZE * this.size * Math.sin(this.angle);
                    this.segments.push({
                        x: segX,
                        y: segY,
                        prevX: segX,
                        prevY: segY
                    });
                }
                
                // Boss starts with some elements matching its type
                for (let i = 0; i < 4; i++) {
                    this.elements.push(this.elementId);
                }
            }
            
            update(deltaTime = 1) {
                if (!this.alive) return;
                
                // Update timers
                if (this.introAnimationTimer > 0) {
                    this.introAnimationTimer -= deltaTime;
                    return; // Don't move during intro
                }
                
                if (this.damageFlashTimer > 0) {
                    this.damageFlashTimer -= deltaTime;
                }
                
                if (this.stunTimer > 0) {
                    this.stunTimer -= deltaTime;
                    if (this.stunTimer <= 0) {
                        // When stun ends, start invulnerability period
                        this.invulnerabilityTimer = 180; // 3 seconds of invulnerability
                    }
                    return; // Don't move or attack while stunned
                }
                
                // Update invulnerability timer
                if (this.invulnerabilityTimer > 0) {
                    this.invulnerabilityTimer -= deltaTime;
                }
                
                // Update phase timer
                this.phaseTimer -= deltaTime;
                
                // Switch between chase and attack phases
                if (this.phaseTimer <= 0) {
                    if (this.attackPhase) {
                        // Exit attack phase, return to chase
                        this.attackPhase = false;
                        this.phaseTimer = this.chasePhaseDuration;
                        this.speed = this.baseSpeed; // Resume movement
                    } else {
                        // Enter attack phase
                        this.attackPhase = true;
                        this.phaseTimer = this.attackPhaseDuration;
                        this.speed = 0; // Stop moving
                        
                        // Show attack warning message
                        switch(this.bossType) {
                            case 'PYRAXIS':
                                showMessage("The Molten One gathers primordial flames!", 'orange', 2000);
                                break;
                            case 'ABYSSOS':
                                showMessage("The Deep One summons torrential fury!", 'blue', 2000);
                                break;
                            case 'OSSEUS':
                                showMessage("The Bone Sovereign calls forth earthen devastation!", 'brown', 2000);
                                break;
                            case 'ZEPHYRUS':
                                showMessage("The Storm Caller harnesses the void!", 'purple', 2000);
                                break;
                        }
                    }
                }
                
                // Update attack timer
                this.attackTimer += deltaTime * 16; // Convert to milliseconds
                
                // Update laugh cooldown and play periodic laugh sounds
                if (this.laughCooldown > 0) {
                    this.laughCooldown -= deltaTime * 16;
                } else if (this.laughCooldown <= 0 && bossEncounterActive) {
                    // Check if it's time to laugh
                    if (Math.random() < 0.3) { // 30% chance when cooldown expires
                        const bossData = BOSS_TYPES[this.bossType];
                        if (!musicMuted && bossData.laughSound) {
                            const laughSound = new Audio(bossData.laughSound);
                            laughSound.volume = 0.5; // Quieter than initial laugh
                            laughSound.play().catch(e => {});
                        }
                    }
                    // Reset cooldown with random delay
                    this.laughCooldown = 15000 + Math.random() * 10000; // 15-25 seconds
                }
                
                // Boss AI - Strategic hunting behavior
                if (playerSnake && playerSnake.alive && !this.attackPhase) {
                    const dx = playerSnake.x - this.x;
                    const dy = playerSnake.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Initialize boss AI state if not present
                    if (!this.aiState) {
                        this.aiState = 'chase';
                        this.aiStateTimer = 0;
                        this.lastPlayerAngle = playerSnake.angle;
                    }
                    
                    this.aiStateTimer += deltaTime;
                    
                    // State machine for boss behavior
                    let targetAngle = Math.atan2(dy, dx); // Default chase angle
                    let speedMultiplier = 1.0;
                    
                    switch(this.aiState) {
                        case 'chase':
                            // Direct chase for 2-3 seconds
                            targetAngle = Math.atan2(dy, dx);
                            speedMultiplier = 0.85;
                            
                            if (this.aiStateTimer > 120 + Math.random() * 60) { // 2-3 seconds
                                // Announce strategy change
                                if (distance < 400) {
                                    const nextState = Math.random() < 0.5 ? 'cutoff' : 'flank';
                                    if (nextState === 'cutoff') {
                                        showMessage(`${this.name} is trying to cut you off!`, 'orange', 1500);
                                    } else {
                                        showMessage(`${this.name} is flanking!`, 'orange', 1500);
                                    }
                                    this.aiState = nextState;
                                } else {
                                    this.aiState = 'chase'; // Keep chasing if too far
                                }
                                this.aiStateTimer = 0;
                            }
                            break;
                            
                        case 'cutoff':
                            // Try to get in front of the player
                            const playerSpeed = playerSnake.speed || SNAKE_SPEED;
                            const futureSteps = 10; // Look ahead
                            const futureX = playerSnake.x + Math.cos(playerSnake.angle) * playerSpeed * futureSteps;
                            const futureY = playerSnake.y + Math.sin(playerSnake.angle) * playerSpeed * futureSteps;
                            
                            // Aim for a point ahead of the player
                            const cutoffDx = futureX - this.x;
                            const cutoffDy = futureY - this.y;
                            targetAngle = Math.atan2(cutoffDy, cutoffDx);
                            speedMultiplier = 1.0; // Move faster to cut off
                            
                            if (this.aiStateTimer > 90 || distance < 100) { // 1.5 seconds or too close
                                this.aiState = 'coil';
                                this.aiStateTimer = 0;
                                if (distance < 150) {
                                    showMessage(`${this.name} is coiling around you!`, 'red', 1500);
                                }
                            }
                            break;
                            
                        case 'flank':
                            // Move to the side of the player
                            const sideAngle = Math.atan2(dy, dx) + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
                            targetAngle = sideAngle;
                            speedMultiplier = 0.95;
                            
                            if (this.aiStateTimer > 60 || distance < 150) { // 1 second or close enough
                                this.aiState = 'coil';
                                this.aiStateTimer = 0;
                            }
                            break;
                            
                        case 'coil':
                            // Try to circle around the player
                            if (distance < 200) {
                                // Circle at current distance
                                const perpAngle = Math.atan2(dy, dx) + Math.PI/2;
                                targetAngle = perpAngle;
                                speedMultiplier = 1.0;
                            } else {
                                // Too far, get closer first
                                targetAngle = Math.atan2(dy, dx);
                                speedMultiplier = 0.85;
                            }
                            
                            if (this.aiStateTimer > 120) { // 2 seconds
                                this.aiState = 'backoff';
                                this.aiStateTimer = 0;
                            }
                            break;
                            
                        case 'backoff':
                            // Move away briefly to reset
                            targetAngle = Math.atan2(-dy, -dx); // Opposite direction
                            speedMultiplier = 0.8;
                            
                            if (this.aiStateTimer > 60 || distance > 300) { // 1 second or far enough
                                this.aiState = 'chase';
                                this.aiStateTimer = 0;
                            }
                            break;
                    }
                    
                    // Smooth angle interpolation
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Bosses have good turning but not perfect
                    const baseTurnSpeed = this.bossType === 'ZEPHYRUS' && elementVacuumActive ? 
                        TURN_SPEED * 1.5 : TURN_SPEED * 0.5;
                    // Faster turning when cutting off or coiling
                    const turnSpeed = (this.aiState === 'cutoff' || this.aiState === 'coil') ? 
                        baseTurnSpeed * 1.5 : baseTurnSpeed;
                    this.angle += angleDiff * turnSpeed;
                    
                    // Apply speed based on state and boss type (only if not in attack phase)
                    if (!this.attackPhase) {
                        if (this.bossType === 'ZEPHYRUS' && elementVacuumActive) {
                            this.speed = this.baseSpeed * 2 * speedMultiplier;
                        } else {
                            this.speed = this.baseSpeed * speedMultiplier;
                        }
                    }
                    
                    // Store player angle for prediction
                    this.lastPlayerAngle = playerSnake.angle;
                }
                
                // Execute attack pattern only during attack phase
                // Double attack speed when desperate (health <= 25%)
                const healthPercent = this.health / this.maxHealth;
                const effectiveCooldown = healthPercent <= 0.25 ? this.attackCooldown / 2 : this.attackCooldown;
                
                if (this.attackPhase && this.attackTimer >= effectiveCooldown) {
                    this.executeAttack();
                    this.attackTimer = 0;
                }
                
                
                // Call parent update
                super.update(deltaTime);
            }
            
            executeAttack() {
                if (!playerSnake || !playerSnake.alive) return;
                
                switch (this.bossType) {
                    case 'PYRAXIS':
                        this.fireballAttack();
                        break;
                    case 'ABYSSOS':
                        this.waterWaveAttack();
                        break;
                    case 'OSSEUS':
                        this.rockFallAttack();
                        break;
                    case 'ZEPHYRUS':
                        this.specialAttackCounter++;
                        // Use vacuum attack every Nth attack, otherwise shoot void projectiles
                        if (this.specialAttackCounter >= this.vacuumAttackInterval) {
                            this.elementVacuumAttack();
                            this.specialAttackCounter = 0;
                            showMessage("Zephyrus summons a void vortex!", 'purple', 2000);
                        } else {
                            this.shootVoidProjectiles();
                        }
                        break;
                }
                
                // Play attack sound
                if (this.attackSound && !musicMuted) {
                    const audio = new Audio(this.attackSound);
                    audio.volume = 0.5;
                    audio.play().catch(e => {});
                }
            }
            
            fireballAttack() {
                // Shoot 4 fireballs in spread pattern toward player
                const baseAngle = Math.atan2(playerSnake.y - this.y, playerSnake.x - this.x);
                const spreadAngle = Math.PI / 8; // Slightly tighter spread for 4 fireballs
                
                for (let i = -1.5; i <= 1.5; i++) {
                    const angle = baseAngle + (i * spreadAngle);
                    const speed = 8;
                    
                    bossProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        type: 'fireball',
                        size: 20,
                        damage: 0.25,
                        elementId: 3, // Fire element
                        life: 300 // 5 seconds
                    });
                }
            }
            
            waterWaveAttack() {
                // Shoot water orbs in all directions
                const orbs = 12; // Reduced from 16 for easier dodging
                for (let i = 0; i < orbs; i++) {
                    const angle = (Math.PI * 2 * i) / orbs;
                    const speed = 5; // Reduced from 6 for more reaction time
                    
                    bossProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        type: 'waterorb',
                        size: 25,
                        damage: 0.25,
                        elementId: 1, // Water element
                        life: 400 // 6.7 seconds
                    });
                }
            }
            
            rockFallAttack() {
                // Create ground fissures attack
                bossScreenShakeTimer = 60; // Longer shake for ground splitting
                bossScreenShakeIntensity = 12;
                
                // Clear existing fissures
                bossFissures = [];
                
                // Create multiple fissures around the map
                const fissureCount = 8 + Math.floor(Math.random() * 5); // 8-12 fissures
                
                for (let i = 0; i < fissureCount; i++) {
                    // Random position anywhere on the visible game board
                    // Get the visible world bounds based on camera
                    const worldBounds = {
                        left: camera.x - (canvas.width / 2) / cameraZoom,
                        right: camera.x + (canvas.width / 2) / cameraZoom,
                        top: camera.y - (canvas.height / 2) / cameraZoom,
                        bottom: camera.y + (canvas.height / 2) / cameraZoom
                    };
                    
                    // Add some padding to ensure fissures can appear at screen edges
                    const padding = 100;
                    const x = worldBounds.left - padding + Math.random() * (worldBounds.right - worldBounds.left + padding * 2);
                    const y = worldBounds.top - padding + Math.random() * (worldBounds.bottom - worldBounds.top + padding * 2);
                    
                    // Vary fissure sizes
                    const size = 60 + Math.random() * 80; // 60-140 pixel radius
                    
                    bossFissures.push({
                        x: x,
                        y: y,
                        radius: 0, // Start small and grow
                        targetRadius: size,
                        growthSpeed: 3, // How fast fissure opens
                        life: 240, // 4 seconds at 60fps
                        maxLife: 240,
                        state: 'opening' // 'opening', 'open', 'closing'
                    });
                }
                
                // Play rumbling sound
                if (!musicMuted) {
                    const rumbleSound = new Audio('sounds/boom-explosion.mp3');
                    rumbleSound.volume = 0.6;
                    rumbleSound.play().catch(e => {});
                }
                
                showMessage("The ground splits open!", 'brown', 2000);
            }
            
            elementVacuumAttack() {
                // ALL elements get vacuumed for 7 seconds
                elementVacuumActive = true;
                elementVacuumTimer = 420; // 7 seconds at 60fps
                
                // Store current elements for vacuum effect
                vacuumedElements = [];
                const activeElements = elementPool.getActiveElements();
                activeElements.forEach(element => {
                    vacuumedElements.push({
                        element: element,
                        originalX: element.x,
                        originalY: element.y
                    });
                });
            }
            
            shootVoidProjectiles() {
                if (!playerSnake || !playerSnake.alive) return;
                
                // Shoot tornados at the player
                const baseAngle = Math.atan2(playerSnake.y - this.y, playerSnake.x - this.x);
                
                // Create 3 tornados with slightly different paths
                for (let i = -1; i <= 1; i++) { // -1, 0, and 1 for 3 tornados
                    const angle = baseAngle + (i * 0.25); // Spread pattern for 3 tornados
                    const speed = 4; // Slower than void projectiles
                    
                    bossProjectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        type: 'tornado',
                        size: 40, // Larger than void projectiles
                        damage: 0.3,
                        elementId: 2, // Air element
                        life: 600, // Longer lasting
                        rotation: 0, // For spinning effect
                        rotationSpeed: 0.2, // Spinning speed
                        wanderAngle: angle, // For erratic movement
                        wanderTimer: 0
                    });
                }
                
                showMessage("Zephyrus unleashes twisters!", 'purple', 2000);
            }
            
            takeDamage(source = 'unknown') {
                console.trace('[BOSS] Damage call stack');
                
                // Only allow damage from player elemental combinations
                if (source !== 'player_elemental') {
                    console.warn('[BOSS] Damage blocked - not from player elemental:', source);
                    return;
                }
                
                // Make boss invincible during stun period and post-stun invulnerability
                if (this.stunTimer > 0) {
                    console.log('[BOSS] Damage blocked - boss is stunned');
                    return;
                }
                
                if (this.invulnerabilityTimer > 0) {
                    console.log('[BOSS] Damage blocked - boss is invulnerable');
                    return;
                }
                
                // Make Zephyrus invincible during element vacuum
                if (this.bossType === 'ZEPHYRUS' && elementVacuumActive) {
                    return;
                }
                
                this.health--;
                this.damageFlashTimer = 30;
                this.stunTimer = 60; // 1 second stun (reduced from 2 seconds)
                bossDamageFlashTimer = 20;
                
                // Create damage number
                damageNumbers.push({
                    x: this.x,
                    y: this.y - 50,
                    text: '-1',
                    color: '#FFD700',
                    life: 60,
                    vy: -3
                });
                
                // Create damage particles
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    particlePool.spawn(
                        this.x, 
                        this.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        this.color
                    );
                }
                
                // Check if defeated
                if (this.health <= 0) {
                    this.defeatBoss();
                }
                
                // Update health bar
                if (bossHealthBar) {
                    const healthPercent = (this.health / this.maxHealth) * 100;
                    bossHealthBar.style.width = healthPercent + '%';
                }
                
                // Update boss name with prefix based on health
                if (bossNameDisplay) {
                    let prefix = '';
                    const healthRatio = this.health / this.maxHealth;
                    
                    if (healthRatio <= 0.2) {
                        prefix = 'Desperate ';
                    } else if (healthRatio <= 0.4) {
                        prefix = 'Furious ';
                    } else if (healthRatio <= 0.6) {
                        prefix = 'Enraged ';
                    } else if (healthRatio < 1.0) {
                        prefix = 'Angry ';
                    }
                    
                    // Build display name using the stored base name
                    const displayName = this.isUndead ? `Undead ${prefix}${this.baseName}` : `${prefix}${this.baseName}`;
                    bossNameDisplay.textContent = `💀 ${displayName}`;
                }
            }
            
            defeatBoss() {
                this.alive = false;
                bossEncounterActive = false;
                defeatedBosses.add(this.bossType);
                bossesDefeatedThisCycle++;
                
                // Dispatch boss defeated event
                dispatchGameEvent('bossDefeated', {
                    bossType: this.bossType,
                    bossName: this.baseName,
                    totalBossesDefeated: bossesDefeatedThisCycle
                });
                
                // Epic victory explosion sequence
                // First wave - main explosion
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 8;
                    particlePool.spawn(
                        this.x,
                        this.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        this.color
                    );
                }
                
                // Second wave - delayed secondary explosions
                setTimeout(() => {
                    for (let j = 0; j < 5; j++) {
                        const offsetAngle = (Math.PI * 2 / 5) * j;
                        const offsetDist = 100;
                        const offsetX = this.x + Math.cos(offsetAngle) * offsetDist;
                        const offsetY = this.y + Math.sin(offsetAngle) * offsetDist;
                        
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 1 + Math.random() * 4;
                            particlePool.spawn(
                                offsetX,
                                offsetY,
                                Math.cos(angle) * speed,
                                Math.sin(angle) * speed,
                                this.color
                            );
                        }
                    }
                }, 200);
                
                // Screen flash and shake
                bossScreenShakeTimer = 60;
                bossScreenShakeIntensity = 20;
                
                // Victory damage number
                damageNumbers.push({
                    x: this.x,
                    y: this.y - 100,
                    text: 'VICTORY!',
                    color: '#FFD700',
                    life: 120,
                    vy: -2
                });
                
                // Elemental burst - spawn fewer elements in a spiral (reduced from 16 to 8)
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    const delay = i * 50; // Stagger the spawns
                    
                    setTimeout(() => {
                        const dist = 150;
                        spawnElement(this.elementId, 
                            this.x + Math.cos(angle) * dist,
                            this.y + Math.sin(angle) * dist
                        );
                    }, delay);
                }
                
                // Play boss defeat sounds
                if (!musicMuted) {
                    // Play boss laugh sound immediately (as they're banished)
                    const bossData = BOSS_TYPES[this.bossType];
                    if (bossData.laughSound) {
                        const laughSound = new Audio(bossData.laughSound);
                        laughSound.volume = 0.7;
                        laughSound.play().catch(e => {});
                    }
                    
                    // Play success tone after a delay
                    setTimeout(() => {
                        const successSound = new Audio('sounds/success-tone.mp3');
                        successSound.volume = 0.6;
                        successSound.play().catch(e => {});
                    }, 800);
                    
                    // Play explosion shockwave sound
                    const shockwaveSound = new Audio('sounds/explosion-shockwave.mp3');
                    shockwaveSound.volume = 0.8;
                    shockwaveSound.play().catch(e => {});
                }
                
                // Spawn rewards
                // 4 catalyst gems
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 / 4) * i;
                    const dist = 50;
                    catalystGems.push(new CatalystGem(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist
                    ));
                }
                
                // 2 void orbs
                for (let i = 0; i < 2; i++) {
                    const angle = Math.PI * i;
                    const dist = 80;
                    voidOrbs.push(new VoidOrb(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist
                    ));
                }
                
                // 8-12 random elements
                const numElements = 8 + Math.floor(Math.random() * 5);
                for (let i = 0; i < numElements; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 100 + Math.random() * 100;
                    spawnElement(null,
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist
                    );
                }
                
                // Award points
                if (playerSnake) {
                    playerSnake.score += 10000;
                }
                
                // Track skin unlock status
                const bossData = BOSS_TYPES[this.bossType];
                const bossSkinName = bossData.skin;
                let skinUnlocked = false;
                
                if (!unlockedSkins.has(bossSkinName)) {
                    unlockedSkins.add(bossSkinName);
                    if (skinMetadata[bossSkinName]) {
                        skinMetadata[bossSkinName].unlocked = true;
                    }
                    saveSkinData();
                    skinUnlocked = true;
                }
                
                // Track element bank expansion
                let elementBankExpanded = false;
                if (elementBankSlots < 12) {
                    elementBankSlots++;
                    updateElementBankUI();
                    elementBankExpanded = true;
                }
                
                // Show the epic boss victory message
                showBossVictoryMessage(this, skinUnlocked, elementBankExpanded);
                
                // Remove boss from snakes array
                const bossIndex = snakes.indexOf(this);
                if (bossIndex > -1) {
                    snakes.splice(bossIndex, 1);
                }
                
                // Hide health bar
                if (bossHealthBarContainer) {
                    bossHealthBarContainer.style.display = 'none';
                }
                
                // Stop boss battle music and resume normal music
                if (bossBattleMusic) {
                    bossBattleMusic.pause();
                    bossBattleMusic = null;
                }
                if (currentTrack && !musicMuted) {
                    currentTrack.volume = musicVolume;
                    currentTrack.play();
                }
                
                // Check if all bosses defeated for undead cycle
                if (bossesDefeatedThisCycle >= 4 && !bossIsUndead) {
                    bossIsUndead = true;
                    bossesDefeatedThisCycle = 0;
                    defeatedBosses.clear();
                    showMessage('The Bosses Rise Again... UNDEAD!', 'purple');
                }
                
                currentBoss = null;
                bossFissures = []; // Clear all fissures when boss is defeated
            }
            
            // Override die method to prevent normal death
            die() {
                // Bosses don't die from collisions, only from elemental damage
                return;
            }
            
            // Override draw method to handle boss-specific rendering
            draw(interpolation = 0) {
                if (!this.alive) return;
                
                // Boss-specific effects
                const glowIntensity = this.damageFlashTimer > 0 ? 
                    Math.sin(this.damageFlashTimer * 0.3) : 0;
                
                // Health phase effects
                const healthPercent = this.health / this.maxHealth;
                let phaseColor = this.color;
                let phaseGlow = false;
                
                if (healthPercent <= 0.25) {
                    // Critical phase - red tint and strong glow
                    phaseColor = '#ff0000';
                    phaseGlow = true;
                } else if (healthPercent <= 0.5) {
                    // Danger phase - orange tint
                    phaseColor = '#ff8800';
                    phaseGlow = true;
                } else if (healthPercent <= 0.75) {
                    // Caution phase - yellow tint
                    phaseColor = '#ffff00';
                }
                
                // Don't scale SEGMENT_SIZE globally - it can break viewport calculations
                // Instead, we'll pass the size to the parent draw method
                try {
                    // Call parent draw method directly
                    super.draw(interpolation);
                } catch (e) {
                    console.error('Boss draw error:', e);
                    // Fallback to custom boss drawing
                    this.drawBossSnake(interpolation);
                }
                
                // No need to restore SEGMENT_SIZE since we didn't change it
                
                // Add invulnerability shield effect
                if (this.invulnerabilityTimer > 0) {
                    ctx.save();
                    const screen = worldToScreen(this.x, this.y);
                    
                    // Pulsing blue shield effect
                    const shieldPulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.3;
                    ctx.globalAlpha = shieldPulse;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 8 * cameraZoom;
                    
                    // Draw shield ring
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, 90 * cameraZoom, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add inner shield effect
                    ctx.globalAlpha = shieldPulse * 0.5;
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, 85 * cameraZoom, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // Add boss glow effect
                if (glowIntensity > 0 || phaseGlow) {
                    ctx.save();
                    const screen = worldToScreen(this.x, this.y);
                    
                    // Damage flash or phase glow
                    if (glowIntensity > 0) {
                        ctx.globalAlpha = glowIntensity * 0.5;
                        ctx.fillStyle = this.color;
                    } else if (phaseGlow) {
                        const phasePulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                        ctx.globalAlpha = phasePulse * 0.4;
                        ctx.fillStyle = phaseColor;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, 100 * cameraZoom, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add phase indicator ring
                    if (phaseGlow) {
                        ctx.strokeStyle = phaseColor;
                        ctx.lineWidth = 5 * cameraZoom;
                        ctx.globalAlpha = 0.8;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, 80 * cameraZoom, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            }
            
            drawBossSnake(interpolation) {
                // Basic boss snake drawing if parent draw doesn't exist
                // This is a fallback implementation
                const segmentSize = SEGMENT_SIZE * this.size;
                
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    const screen = worldToScreen(segment.x, segment.y);
                    
                    ctx.save();
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, segmentSize * cameraZoom, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw head with boss skin
                const headScreen = worldToScreen(this.x, this.y);
                const headSize = segmentSize * 1.2 * cameraZoom;
                
                if (skinImages[this.skin] && !skinImages[this.skin].error) {
                    ctx.save();
                    ctx.translate(headScreen.x, headScreen.y);
                    ctx.rotate(this.angle);
                    ctx.drawImage(skinImages[this.skin], 
                        -headSize * 1.5, -headSize * 1.5, 
                        headSize * 3, headSize * 3);
                    ctx.restore();
                } else {
                    // Fallback to emoji if skin not loaded
                    const emojiCanvas = getCachedEmoji(this.emoji, Math.round(headSize * 2));
                    ctx.drawImage(emojiCanvas, 
                        headScreen.x - emojiCanvas.width / 2, 
                        headScreen.y - emojiCanvas.height / 2);
                }
            }
        }
        
        // Boss system functions
        function spawnBoss() {
            // Select a random boss that hasn't been defeated this cycle
            const availableBosses = Object.keys(BOSS_TYPES).filter(boss => !defeatedBosses.has(boss));
            if (availableBosses.length === 0) {
                return;
            }
            
            const selectedBoss = availableBosses[Math.floor(Math.random() * availableBosses.length)];
            const bossData = BOSS_TYPES[selectedBoss];
            
            // Show warning message
            const bossName = bossIsUndead ? `Undead ${bossData.name}` : bossData.name;
            showMessage(`${bossName} Emerges from the Cosmic Void!`, 'red', 3000);
            
            // Pause normal music completely
            if (currentTrack && !musicMuted) {
                currentTrack.pause();
            }
            
            // Play boss intro music
            if (!musicMuted) {
                bossIntroMusic = new Audio('sounds/low-pitched-melody.mp3');
                bossIntroMusic.volume = 0.7 * musicVolume;
                bossIntroMusic.play().catch(e => {});
                
                // Start battle music when intro ends
                bossIntroMusic.addEventListener('ended', () => {
                    if (!musicMuted && currentBoss && currentBoss.alive) {
                        bossBattleMusic = new Audio('music/dramatic-pounding-percussion.mp3');
                        bossBattleMusic.volume = 0.6 * musicVolume;
                        bossBattleMusic.loop = true;
                        bossBattleMusic.play().catch(e => {});
                    }
                });
            }
            
            // Select random edge to spawn from
            const edge = Math.floor(Math.random() * 4);
            let spawnX, spawnY;
            
            switch(edge) {
                case 0: // Top
                    spawnX = Math.random() * WORLD_SIZE;
                    spawnY = 100;
                    break;
                case 1: // Right
                    spawnX = WORLD_SIZE - 100;
                    spawnY = Math.random() * WORLD_SIZE;
                    break;
                case 2: // Bottom
                    spawnX = Math.random() * WORLD_SIZE;
                    spawnY = WORLD_SIZE - 100;
                    break;
                case 3: // Left
                    spawnX = 100;
                    spawnY = Math.random() * WORLD_SIZE;
                    break;
            }
            
            // Create boss
            currentBoss = new Boss(selectedBoss, spawnX, spawnY);
            snakes.push(currentBoss);
            bossEncounterActive = true;
            
            // Play boss laugh sound on spawn
            if (!musicMuted && BOSS_TYPES[selectedBoss].laughSound) {
                const laughSound = new Audio(BOSS_TYPES[selectedBoss].laughSound);
                laughSound.volume = 0.7;
                laughSound.play().catch(e => {});
            }
            
            // Make AI snakes flee
            snakes.forEach(snake => {
                if (!snake.isPlayer && !snake.isBoss && snake.alive) {
                    snake.panicMode = true;
                    snake.panicTimer = 999999; // Permanent panic during boss
                }
            });
            
            // Create boss health bar UI
            createBossHealthBar();
        }
        
        function createBossHealthBar() {
            // Remove existing health bar if any
            if (bossHealthBarContainer) {
                bossHealthBarContainer.remove();
            }
            
            // Create health bar container
            bossHealthBarContainer = document.createElement('div');
            bossHealthBarContainer.style.position = 'fixed';
            bossHealthBarContainer.style.top = isMobile ? '80px' : '50px'; // Lower on mobile to avoid UI overlap
            bossHealthBarContainer.style.left = '50%';
            bossHealthBarContainer.style.transform = 'translateX(-50%)';
            bossHealthBarContainer.style.width = isMobile ? '300px' : '600px'; // Smaller on mobile
            bossHealthBarContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            bossHealthBarContainer.style.border = '3px solid #fff';
            bossHealthBarContainer.style.borderRadius = '10px';
            bossHealthBarContainer.style.padding = '10px';
            bossHealthBarContainer.style.zIndex = '50'; // Below pause menu (z-index 100)
            
            // Create health bar
            const healthBarBg = document.createElement('div');
            healthBarBg.style.width = '100%';
            healthBarBg.style.height = isMobile ? '20px' : '30px';
            healthBarBg.style.backgroundColor = '#333';
            healthBarBg.style.borderRadius = '5px';
            healthBarBg.style.overflow = 'hidden';
            
            bossHealthBar = document.createElement('div');
            bossHealthBar.style.width = '100%';
            bossHealthBar.style.height = '100%';
            bossHealthBar.style.backgroundColor = currentBoss.color;
            bossHealthBar.style.transition = 'width 0.3s ease';
            
            healthBarBg.appendChild(bossHealthBar);
            
            // Create boss name display
            bossNameDisplay = document.createElement('div');
            bossNameDisplay.style.textAlign = 'center';
            bossNameDisplay.style.color = '#fff';
            bossNameDisplay.style.fontSize = isMobile ? '14px' : '18px';
            bossNameDisplay.style.fontWeight = 'bold';
            bossNameDisplay.style.marginTop = '5px';
            bossNameDisplay.style.whiteSpace = 'nowrap'; // Ensure single line display
            bossNameDisplay.style.overflow = 'hidden';
            bossNameDisplay.style.textOverflow = 'ellipsis';
            bossNameDisplay.textContent = `💀 ${currentBoss.name}`;
            
            bossHealthBarContainer.appendChild(healthBarBg);
            bossHealthBarContainer.appendChild(bossNameDisplay);
            document.body.appendChild(bossHealthBarContainer);
        }
        
        function updateBossProjectiles(deltaTime) {
            // Update and remove expired projectiles
            bossProjectiles = bossProjectiles.filter(projectile => {
                switch(projectile.type) {
                    case 'fireball':
                        projectile.x += projectile.vx * deltaTime;
                        projectile.y += projectile.vy * deltaTime;
                        projectile.life -= deltaTime;
                        
                        // Check collision with player
                        if (playerSnake && playerSnake.alive) {
                            const dx = playerSnake.x - projectile.x;
                            const dy = playerSnake.y - projectile.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const playerRadius = SEGMENT_SIZE * (playerSnake.size || 1);
                            if (distance < projectile.size + playerRadius) {
                                // Check invincibility before dealing damage
                                if (playerSnake.invincibilityTimer <= 0) {
                                    // Create explosion particles before death
                                    for (let i = 0; i < 30; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 2 + Math.random() * 5;
                                        particlePool.spawn(
                                            playerSnake.x,
                                            playerSnake.y,
                                            Math.cos(angle) * speed,
                                            Math.sin(angle) * speed,
                                            '#ff6600'
                                        );
                                    }
                                    // Boss elemental attacks are insta-death
                                    playerSnake.die(true);
                                    showMessage('Incinerated by Pyraxis!', 'red');
                                }
                                
                                // Rarely leave fire element (reduced from 30% to 10%)
                                if (Math.random() < 0.1) {
                                    spawnElement(projectile.elementId, projectile.x, projectile.y);
                                }
                                
                                return false; // Remove projectile
                            }
                        }
                        
                        return projectile.life > 0;
                        
                    case 'waterwave':
                        projectile.radius += projectile.expandSpeed * deltaTime;
                        
                        // Check collision with player
                        if (playerSnake && playerSnake.alive) {
                            const dx = playerSnake.x - projectile.x;
                            const dy = playerSnake.y - projectile.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < projectile.radius && dist > projectile.radius - 20 && !projectile.hasHitPlayer) {
                                // Check invincibility before dealing damage
                                if (playerSnake.invincibilityTimer <= 0) {
                                    // Create water splash particles before death
                                    for (let i = 0; i < 30; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 2 + Math.random() * 5;
                                        particlePool.spawn(
                                            playerSnake.x,
                                            playerSnake.y,
                                            Math.cos(angle) * speed,
                                            Math.sin(angle) * speed,
                                            '#0066ff'
                                        );
                                    }
                                    // Boss elemental attacks are insta-death
                                    playerSnake.die(true);
                                    showMessage('Drowned by Abyssos!', 'red');
                                }
                                projectile.hasHitPlayer = true; // Prevent multiple hits from same wave
                            }
                        }
                        
                        // Spawn water elements occasionally
                        if (Math.random() < 0.02) { // Reduced from 5% to 2%
                            const angle = Math.random() * Math.PI * 2;
                            spawnElement(projectile.elementId,
                                projectile.x + Math.cos(angle) * projectile.radius,
                                projectile.y + Math.sin(angle) * projectile.radius
                            );
                        }
                        
                        return projectile.radius < projectile.maxRadius;
                        
                    case 'rock':
                        if (projectile.falling) {
                            const fallSpeed = projectile.fallSpeed || 10;
                            projectile.y += fallSpeed * deltaTime;
                            
                            // Check collision while falling
                            if (playerSnake && playerSnake.alive) {
                                const dx = playerSnake.x - projectile.x;
                                const dy = playerSnake.y - projectile.y;
                                const distSq = dx * dx + dy * dy;
                                
                                // Collision radius is larger while falling (40 pixels)
                                if (distSq < 40 * 40) {
                                    if (playerSnake.invincibilityTimer <= 0) {
                                        // Create debris particles
                                        for (let i = 0; i < 20; i++) {
                                            const angle = Math.random() * Math.PI * 2;
                                            const speed = 3 + Math.random() * 4;
                                            particlePool.spawn(
                                                playerSnake.x,
                                                playerSnake.y,
                                                Math.cos(angle) * speed,
                                                Math.sin(angle) * speed,
                                                '#8b6914'
                                            );
                                        }
                                        playerSnake.die(true);
                                        showMessage('Crushed by falling rock!', 'red');
                                    }
                                }
                            }
                            
                            if (projectile.y >= projectile.shadowY) {
                                projectile.falling = false;
                                projectile.y = projectile.shadowY;
                                
                                // Create impact crater when rock lands
                                if (!projectile.impactCrater) {
                                    projectile.impactCrater = {
                                        x: projectile.x,
                                        y: projectile.y,
                                        radius: 50, // 50 pixel radius crater
                                        life: 180 // 3 seconds
                                    };
                                    
                                    // Screen shake on impact
                                    bossScreenShakeTimer = 15;
                                    bossScreenShakeIntensity = 8;
                                    
                                    // Create impact particles
                                    for (let i = 0; i < 15; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 2 + Math.random() * 3;
                                        particlePool.spawn(
                                            projectile.x,
                                            projectile.y,
                                            Math.cos(angle) * speed,
                                            Math.sin(angle) * speed,
                                            '#8b6914'
                                        );
                                    }
                                }
                            }
                        }
                        
                        // Check collision with impact crater
                        if (projectile.impactCrater && playerSnake && playerSnake.alive) {
                            const crater = projectile.impactCrater;
                            const dx = playerSnake.x - crater.x;
                            const dy = playerSnake.y - crater.y;
                            
                            if (dx * dx + dy * dy < crater.radius * crater.radius) {
                                if (playerSnake.invincibilityTimer <= 0) {
                                    // Create debris particles
                                    for (let i = 0; i < 25; i++) {
                                        const angle = Math.random() * Math.PI * 2;
                                        const speed = 2 + Math.random() * 5;
                                        particlePool.spawn(
                                            playerSnake.x,
                                            playerSnake.y,
                                            Math.cos(angle) * speed,
                                            Math.sin(angle) * speed,
                                            '#8b6914'
                                        );
                                    }
                                    playerSnake.die(true);
                                    showMessage('Crushed in impact crater!', 'red');
                                }
                            }
                            
                            // Update crater life
                            crater.life -= deltaTime;
                            if (crater.life <= 0) {
                                projectile.impactCrater = null;
                            }
                        }
                        
                        // Rocks and craters stay for a while
                        if (!projectile.falling) {
                            if (!projectile.groundTimer) {
                                projectile.groundTimer = 180; // 3 seconds on ground
                                // Disabled element spawning from bone projectiles to reduce boss element abundance
                                // spawnElement(projectile.elementId, projectile.x, projectile.y);
                            }
                            projectile.groundTimer -= deltaTime;
                            
                            return projectile.groundTimer > 0 || projectile.impactCrater;
                        }
                        
                        return true; // Keep falling rocks active
                        
                case 'waterorb':
                    // Update water orb position
                    projectile.x += projectile.vx * deltaTime;
                    projectile.y += projectile.vy * deltaTime;
                    projectile.life -= deltaTime;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.alive) {
                        const dx = playerSnake.x - projectile.x;
                        const dy = playerSnake.y - projectile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const playerRadius = SEGMENT_SIZE * (playerSnake.size || 1);
                        if (distance < projectile.size + playerRadius) {
                            if (playerSnake.invincibilityTimer <= 0) {
                                // Create water splash particles before death
                                for (let i = 0; i < 30; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 2 + Math.random() * 5;
                                    particlePool.spawn(
                                        playerSnake.x,
                                        playerSnake.y,
                                        Math.cos(angle) * speed,
                                        Math.sin(angle) * speed,
                                        '#40a4df'
                                    );
                                }
                                // Boss elemental attacks are insta-death
                                playerSnake.die(true);
                                showMessage('Swept away by Abyssos!', 'red');
                            }
                            
                            // Rarely leave water element (reduced from 30% to 10%)
                            if (Math.random() < 0.1) {
                                spawnElement(projectile.elementId, projectile.x, projectile.y);
                            }
                            
                            return false; // Remove projectile
                        }
                    }
                    
                    return projectile.life > 0;
                    
                case 'void':
                    // Update void projectile position
                    projectile.x += projectile.vx * deltaTime;
                    projectile.y += projectile.vy * deltaTime;
                    projectile.life -= deltaTime;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.alive) {
                        const dx = projectile.x - playerSnake.x;
                        const dy = projectile.y - playerSnake.y;
                        if (Math.sqrt(dx * dx + dy * dy) < projectile.size + SEGMENT_SIZE) {
                            if (playerSnake.invincibilityTimer <= 0) {
                                // Create void particles before death
                                for (let i = 0; i < 30; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 2 + Math.random() * 5;
                                    particlePool.spawn(
                                        playerSnake.x,
                                        playerSnake.y,
                                        Math.cos(angle) * speed,
                                        Math.sin(angle) * speed,
                                        '#9b59b6'
                                    );
                                }
                                playerSnake.die(true);
                                showMessage('Consumed by the void!', 'red');
                            }
                            return false; // Remove projectile
                        }
                    }
                    
                    return projectile.life > 0;
                    
                case 'tornado':
                    // Update tornado position with wandering movement
                    projectile.wanderTimer += deltaTime;
                    if (projectile.wanderTimer > 30) { // Change direction every 0.5 seconds
                        projectile.wanderAngle += (Math.random() - 0.5) * 0.5;
                        projectile.wanderTimer = 0;
                    }
                    
                    // Update velocity based on wander angle
                    const tornadoSpeed = 4;
                    projectile.vx = Math.cos(projectile.wanderAngle) * tornadoSpeed;
                    projectile.vy = Math.sin(projectile.wanderAngle) * tornadoSpeed;
                    
                    projectile.x += projectile.vx * deltaTime;
                    projectile.y += projectile.vy * deltaTime;
                    projectile.life -= deltaTime;
                    projectile.rotation += projectile.rotationSpeed * deltaTime;
                    
                    // Check collision with player
                    if (playerSnake && playerSnake.alive) {
                        const dx = projectile.x - playerSnake.x;
                        const dy = projectile.y - playerSnake.y;
                        if (Math.sqrt(dx * dx + dy * dy) < projectile.size + SEGMENT_SIZE) {
                            if (playerSnake.invincibilityTimer <= 0) {
                                // Create wind particles before death
                                for (let i = 0; i < 40; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 3 + Math.random() * 6;
                                    particlePool.spawn(
                                        playerSnake.x,
                                        playerSnake.y,
                                        Math.cos(angle) * speed,
                                        Math.sin(angle) * speed,
                                        '#87ceeb'
                                    );
                                }
                                playerSnake.die(true);
                                showMessage('Swept away by the tornado!', 'red');
                            }
                            return false; // Remove projectile
                        }
                    }
                    
                    return projectile.life > 0;
                }
                
                return false;
            });
        }
        
        function updateElementVacuum(deltaTime) {
            // Make all elements move toward boss and consume them
            if (!currentBoss || !currentBoss.alive) return;
            
            vacuumedElements = vacuumedElements.filter(({element, originalX, originalY}) => {
                if (!element.active) return false; // Already deactivated
                
                const dx = currentBoss.x - element.x;
                const dy = currentBoss.y - element.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 50) {
                    const speed = 5 * deltaTime;
                    element.x += (dx / dist) * speed;
                    element.y += (dy / dist) * speed;
                    return true; // Keep in array
                } else {
                    // Element reached the boss - consume it into the void
                    element.deactivate();
                    
                    // Create void consumption particles
                    for (let i = 0; i < 10; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 2 + Math.random() * 3;
                        particlePool.spawn(
                            element.x,
                            element.y,
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed,
                            '#9b59b6' // Purple void color
                        );
                    }
                    
                    return false; // Remove from array
                }
            });
        }
        
        function endElementVacuum() {
            elementVacuumActive = false;
            
            // Elements have been consumed into the void - don't restore them
            // The map will naturally repopulate through the normal spawn system
            
            // Create a burst of void energy particles when vacuum ends
            if (currentBoss && currentBoss.alive) {
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 5;
                    particlePool.spawn(
                        currentBoss.x,
                        currentBoss.y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#9b59b6' // Purple void color
                    );
                }
            }
            
            vacuumedElements = [];
        }
        
        function drawBossSkullIndicator() {
            if (!currentBoss || !currentBoss.alive || !playerSnake || !playerSnake.alive) return;
            
            // Calculate boss position relative to camera
            const bossScreenX = (currentBoss.x - camera.x) * cameraZoom + canvas.width / 2;
            const bossScreenY = (currentBoss.y - camera.y) * cameraZoom + canvas.height / 2;
            
            // Check if boss is on screen
            const margin = 100; // Extra margin to ensure boss is fully visible
            if (bossScreenX >= -margin && bossScreenX <= canvas.width + margin && 
                bossScreenY >= -margin && bossScreenY <= canvas.height + margin) {
                // Boss is on screen, don't show indicator
                return;
            }
            
            // Calculate direction from player to boss
            const dx = currentBoss.x - playerSnake.x;
            const dy = currentBoss.y - playerSnake.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            
            // Calculate position on screen edge
            const edgeMargin = 60; // Distance from edge of screen
            let indicatorX, indicatorY;
            
            // Find intersection with screen edges
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Calculate the parameter t for the ray from center to boss
            const maxX = (canvas.width / 2 - edgeMargin) / Math.abs(dirX * cameraZoom);
            const maxY = (canvas.height / 2 - edgeMargin) / Math.abs(dirY * cameraZoom);
            const t = Math.min(maxX, maxY);
            
            indicatorX = centerX + dirX * t * cameraZoom;
            indicatorY = centerY + dirY * t * cameraZoom;
            
            // Clamp to screen bounds with margin
            indicatorX = Math.max(edgeMargin, Math.min(canvas.width - edgeMargin, indicatorX));
            indicatorY = Math.max(edgeMargin, Math.min(canvas.height - edgeMargin, indicatorY));
            
            // Draw the skull indicator
            ctx.save();
            
            // Create pulsing effect
            const pulseScale = 1 + Math.sin(Date.now() * 0.003) * 0.2;
            const indicatorSize = 50 * pulseScale; // Increased from 30 to 50
            
            // Draw background circle with boss color
            ctx.fillStyle = currentBoss.color;
            ctx.globalAlpha = 0.5; // Increased from 0.3
            ctx.beginPath();
            ctx.arc(indicatorX, indicatorY, indicatorSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw border circle
            ctx.strokeStyle = currentBoss.color;
            ctx.lineWidth = 5; // Increased from 3
            ctx.globalAlpha = 1.0; // Increased from 0.8
            ctx.stroke();
            
            // Add white outline for better visibility
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            ctx.stroke();
            
            // Draw skull emoji
            ctx.globalAlpha = 1;
            const skullSize = Math.round(indicatorSize * 1.5);
            const skullCanvas = getCachedEmoji('💀', skullSize);
            ctx.drawImage(skullCanvas, indicatorX - skullCanvas.width / 2, indicatorY - skullCanvas.height / 2);
            
            // Draw directional arrow pointing towards boss
            ctx.save();
            ctx.translate(indicatorX, indicatorY);
            ctx.rotate(Math.atan2(dy, dx));
            
            // Arrow pointing outward
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4; // Increased from 2
            ctx.globalAlpha = 1.0; // Increased from 0.8
            ctx.beginPath();
            ctx.moveTo(indicatorSize + 10, 0);
            ctx.lineTo(indicatorSize + 25, -10); // Increased arrow size
            ctx.moveTo(indicatorSize + 10, 0);
            ctx.lineTo(indicatorSize + 25, 10); // Increased arrow size
            ctx.stroke();
            
            ctx.restore();
            
            // Draw distance text
            const distanceInUnits = Math.round(distance / 10);
            ctx.font = `bold ${14 * cameraZoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(`${distanceInUnits}m`, indicatorX, indicatorY + indicatorSize + 5);
            ctx.fillStyle = '#fff';
            ctx.fillText(`${distanceInUnits}m`, indicatorX, indicatorY + indicatorSize + 5);
            
            ctx.restore();
        }
        
        function checkBossElementalDamage() {
            if (!currentBoss || !currentBoss.alive || !playerSnake || !playerSnake.alive) return;
            
            // Check cooldown to prevent spam damage
            if (bossDamageCooldown > 0) return;
            
            // Don't allow damage while boss is stunned
            if (currentBoss.stunTimer > 0) return;
            
            // Check player's element bank for combinations
            const playerElements = playerSnake.elements;
            const elementBank = getElementBankElements();
            const allPlayerElements = [...playerElements, ...elementBank];
            
            // Check if player has the right combination near the boss
            const dx = playerSnake.x - currentBoss.x;
            const dy = playerSnake.y - currentBoss.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 500) { // Within 500 pixels
                let canDamage = false;
                
                // Check if player has ANY combination containing the boss's element
                const bossElementId = currentBoss.elementId;
                let comboFound = null;
                let otherElementId = null;
                
                // First check for boss elements on the map near the player
                let mapBossElement = null;
                const elements = elementPool.getActiveElements();
                for (let i = 0; i < elements.length; i++) {
                    const element = elements[i];
                    if (!element.active || element.id !== bossElementId) continue;
                    
                    // Check if this boss element is near the player
                    const elemDx = element.x - playerSnake.x;
                    const elemDy = element.y - playerSnake.y;
                    const elemDist = Math.sqrt(elemDx * elemDx + elemDy * elemDy);
                    
                    if (elemDist < 150) { // Close enough to interact
                        mapBossElement = element;
                        break;
                    }
                }
                
                // Check if we can form a combination
                if (mapBossElement && allPlayerElements.length > 0) {
                    // Player has elements and there's a boss element on the map nearby
                    canDamage = true;
                    // Find any element in player's bank to combine with
                    otherElementId = allPlayerElements[0];
                    const comboKey = `${Math.min(bossElementId, otherElementId)}+${Math.max(bossElementId, otherElementId)}`;
                    if (window.elementLoader && window.elementLoader.combinations[comboKey]) {
                        comboFound = window.elementLoader.combinations[comboKey];
                    }
                } else if (allPlayerElements.includes(bossElementId)) {
                    // Check if player has the boss's element in their bank
                    const uniqueElements = [...new Set(allPlayerElements)];
                    if (uniqueElements.length >= 2) {
                        canDamage = true;
                        // Find the other element that isn't the boss element
                        for (let elemId of uniqueElements) {
                            if (elemId !== bossElementId) {
                                otherElementId = elemId;
                                // Check what this combination creates
                                const comboKey = `${Math.min(bossElementId, elemId)}+${Math.max(bossElementId, elemId)}`;
                                if (window.elementLoader && window.elementLoader.combinations[comboKey]) {
                                    comboFound = window.elementLoader.combinations[comboKey];
                                }
                                break;
                            }
                        }
                    }
                }
                
                if (canDamage) {
                    currentBoss.takeDamage('player_elemental');
                    
                    // Show combo message
                    if (comboFound && otherElementId !== null) {
                        const bossElement = window.elementLoader.elementsById[bossElementId];
                        const otherElement = window.elementLoader.elementsById[otherElementId];
                        const resultElement = window.elementLoader.elementsById[comboFound];
                        if (bossElement && otherElement && resultElement) {
                            showMessage(`${bossElement.name} + ${otherElement.name} = ${resultElement.name}!`, 'gold', 5000);
                        } else {
                            showMessage('Elemental Resonance!', 'gold', 5000);
                        }
                    } else {
                        showMessage('Elemental Resonance!', 'gold', 5000);
                    }
                    
                    bossDamageCooldown = 120; // 2 second cooldown
                    
                    // Create shockwave effect
                    const elementColors = {
                        0: '#8b6914', // Earth - brown
                        1: '#0066ff', // Water - blue
                        2: '#ffffff', // Air - white
                        3: '#ff4444'  // Fire - red
                    };
                    
                    // Determine the color based on player's primary element
                    let shockwaveColor = '#FFD700'; // Default gold
                    if (allPlayerElements.length > 0) {
                        const primaryElement = allPlayerElements[0];
                        shockwaveColor = elementColors[primaryElement] || '#FFD700';
                    }
                    
                    shockwaves.push({
                        x: playerSnake.x,
                        y: playerSnake.y,
                        radius: 0,
                        maxRadius: 600, // Fixed max radius for omnidirectional wave
                        speed: 10, // Slower expansion for visibility
                        color: shockwaveColor,
                        life: 1.0,
                        type: 'omnidirectional',
                        owner: 'player' // Mark this as a player shockwave
                    });
                    
                    // Create spawn effect - energy gathering particles
                    for (let i = 0; i < 20; i++) {
                        const angle = (Math.PI * 2 * i) / 20;
                        const startRadius = 50;
                        particlePool.spawn(
                            playerSnake.x + Math.cos(angle) * startRadius,
                            playerSnake.y + Math.sin(angle) * startRadius,
                            -Math.cos(angle) * 3, // Particles move inward
                            -Math.sin(angle) * 3,
                            shockwaveColor
                        );
                    }
                    
                    // Play energy blast sound
                    if (!musicMuted) {
                        const blastSound = new Audio('sounds/magic-energy-whoosh.mp3');
                        blastSound.volume = 0.7;
                        blastSound.play().catch(e => {});
                    }
                }
            }
        }
        
        function getElementBankElements() {
            // Get elements from the element bank UI
            const slots = document.querySelectorAll('.element-slot');
            const elements = [];
            
            slots.forEach(slot => {
                const elementId = slot.dataset.elementId;
                if (elementId) {
                    elements.push(parseInt(elementId));
                }
            });
            
            return elements;
        }
        
        function updateElementBankUI() {
            // This will be called when element bank expands
            // Force a UI update to show the new slots
            if (gameStarted && playerSnake) {
                updateUI();
            }
        }
        
        function updateShockwaves(deltaTime) {
            shockwaves = shockwaves.filter(shockwave => {
                shockwave.radius += shockwave.speed * deltaTime;
                shockwave.life = 1.0 - (shockwave.radius / shockwave.maxRadius);
                
                // For omnidirectional shockwaves, check if it hits the boss
                if (shockwave.type === 'omnidirectional' && currentBoss && currentBoss.alive && !shockwave.hasHitBoss) {
                    const dx = currentBoss.x - shockwave.x;
                    const dy = currentBoss.y - shockwave.y;
                    const distToBoss = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if the expanding ring has reached the boss
                    const ringThickness = 20; // How thick the shockwave ring is
                    if (distToBoss >= shockwave.radius - ringThickness && distToBoss <= shockwave.radius + ringThickness) {
                        shockwave.hasHitBoss = true;
                        
                        // Deal damage to the boss only if this is a player shockwave
                        if (shockwave.owner === 'player') {
                            currentBoss.takeDamage('player_elemental');
                        }
                        
                        // Create impact particles at boss location
                        const impactParticles = 30;
                        for (let i = 0; i < impactParticles; i++) {
                            const angle = (Math.PI * 2 * i) / impactParticles;
                            const speed = 3 + Math.random() * 5;
                            const particleColor = i % 2 === 0 ? shockwave.color : '#ffffff';
                            
                            particlePool.spawn(
                                currentBoss.x,
                                currentBoss.y,
                                Math.cos(angle) * speed,
                                Math.sin(angle) * speed,
                                particleColor
                            );
                        }
                        
                        // Add screen shake for impact
                        if (bossScreenShakeTimer < 10) {
                            bossScreenShakeTimer = 10;
                            bossScreenShakeIntensity = 5;
                        }
                    }
                } else if (!shockwave.type) {
                    // Old directional shockwave logic (kept for compatibility)
                    if (shockwave.life <= 0 && !shockwave.exploded) {
                        shockwave.exploded = true;
                        
                        // Create explosion particles at target location
                        const explosionParticles = 50;
                        for (let i = 0; i < explosionParticles; i++) {
                            const angle = (Math.PI * 2 * i) / explosionParticles;
                            const speed = 5 + Math.random() * 7;
                            const particleColor = i % 2 === 0 ? shockwave.color : '#ffffff';
                            
                            particlePool.spawn(
                                shockwave.targetX,
                                shockwave.targetY,
                                Math.cos(angle) * speed,
                                Math.sin(angle) * speed,
                                particleColor
                            );
                        }
                    }
                }
                
                return shockwave.life > 0;
            });
        }
        
        function drawShockwaves() {
            shockwaves.forEach(shockwave => {
                ctx.save();
                
                const centerScreen = worldToScreen(shockwave.x, shockwave.y);
                
                if (shockwave.type === 'omnidirectional') {
                    // Draw expanding ring shockwave
                    const ringRadius = shockwave.radius * cameraZoom;
                    const progress = shockwave.radius / shockwave.maxRadius;
                    
                    // Outer ring
                    ctx.strokeStyle = shockwave.color;
                    ctx.lineWidth = 4 * cameraZoom;
                    ctx.globalAlpha = shockwave.life * 0.8;
                    ctx.beginPath();
                    ctx.arc(centerScreen.x, centerScreen.y, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner bright ring
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2 * cameraZoom;
                    ctx.globalAlpha = shockwave.life;
                    ctx.beginPath();
                    ctx.arc(centerScreen.x, centerScreen.y, ringRadius - 2 * cameraZoom, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Energy glow
                    const glowGradient = ctx.createRadialGradient(
                        centerScreen.x, centerScreen.y, ringRadius - 20 * cameraZoom,
                        centerScreen.x, centerScreen.y, ringRadius + 20 * cameraZoom
                    );
                    glowGradient.addColorStop(0, shockwave.color + '00');
                    glowGradient.addColorStop(0.5, shockwave.color + '66');
                    glowGradient.addColorStop(1, shockwave.color + '00');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.globalAlpha = shockwave.life * 0.5;
                    ctx.beginPath();
                    ctx.arc(centerScreen.x, centerScreen.y, ringRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add energy particles along the ring
                    const particleCount = 16;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (Math.PI * 2 * i) / particleCount + Date.now() * 0.001;
                        const particleX = centerScreen.x + Math.cos(angle) * ringRadius;
                        const particleY = centerScreen.y + Math.sin(angle) * ringRadius;
                        
                        ctx.fillStyle = i % 2 === 0 ? shockwave.color : '#ffffff';
                        ctx.globalAlpha = shockwave.life;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 3 * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Old directional blast rendering (kept for compatibility)
                    const angle = Math.atan2(
                        shockwave.targetY - shockwave.y,
                        shockwave.targetX - shockwave.x
                    );
                    
                    const currentX = shockwave.x + Math.cos(angle) * shockwave.radius;
                    const currentY = shockwave.y + Math.sin(angle) * shockwave.radius;
                    
                    const screen = worldToScreen(currentX, currentY);
                    
                    const progress = shockwave.radius / shockwave.maxRadius;
                    const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.2 + progress * 0.5;
                    const blastSize = 40 * cameraZoom * pulseScale;
                    
                    const gradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, blastSize);
                    gradient.addColorStop(0, shockwave.color);
                    gradient.addColorStop(0.3, shockwave.color);
                    gradient.addColorStop(0.6, shockwave.color + '88');
                    gradient.addColorStop(1, shockwave.color + '00');
                    
                    ctx.globalAlpha = shockwave.life;
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screen.x, screen.y, blastSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }
        
        function updateBossFissures(deltaTime) {
            bossFissures = bossFissures.filter(fissure => {
                // Update fissure state
                if (fissure.state === 'opening') {
                    fissure.radius += fissure.growthSpeed * deltaTime;
                    if (fissure.radius >= fissure.targetRadius) {
                        fissure.radius = fissure.targetRadius;
                        fissure.state = 'open';
                    }
                } else if (fissure.state === 'open') {
                    fissure.life -= deltaTime;
                    if (fissure.life <= 60) { // Start closing in last second
                        fissure.state = 'closing';
                    }
                } else if (fissure.state === 'closing') {
                    fissure.radius -= fissure.growthSpeed * 2 * deltaTime; // Close faster
                    fissure.life -= deltaTime;
                    if (fissure.radius <= 0 || fissure.life <= 0) {
                        return false; // Remove fissure
                    }
                }
                
                // Check collision with player when fissure is open
                if (fissure.radius > 20 && playerSnake && playerSnake.alive) {
                    const dx = playerSnake.x - fissure.x;
                    const dy = playerSnake.y - fissure.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const playerRadius = SEGMENT_SIZE * (playerSnake.size || 1);
                    
                    if (distance < fissure.radius + playerRadius) {
                        if (playerSnake.invincibilityTimer <= 0) {
                            // Create earth particles before death
                            for (let i = 0; i < 30; i++) {
                                const angle = Math.random() * Math.PI * 2;
                                const speed = 2 + Math.random() * 5;
                                particlePool.spawn(
                                    playerSnake.x,
                                    playerSnake.y,
                                    Math.cos(angle) * speed,
                                    Math.sin(angle) * speed,
                                    '#8b6914'
                                );
                            }
                            playerSnake.die(true);
                            showMessage('Swallowed by the earth!', 'red');
                        }
                    }
                }
                
                return true;
            });
        }
        
        function drawBossFissures() {
            bossFissures.forEach(fissure => {
                const screen = worldToScreen(fissure.x, fissure.y);
                const radius = fissure.radius * cameraZoom;
                
                ctx.save();
                
                // Draw dark fissure hole
                const gradient = ctx.createRadialGradient(
                    screen.x, screen.y, 0,
                    screen.x, screen.y, radius
                );
                
                // Animate the colors based on state
                if (fissure.state === 'opening') {
                    gradient.addColorStop(0, 'rgba(20, 10, 0, 0.9)');
                    gradient.addColorStop(0.5, 'rgba(50, 25, 10, 0.7)');
                    gradient.addColorStop(0.8, 'rgba(80, 40, 20, 0.5)');
                    gradient.addColorStop(1, 'rgba(100, 50, 25, 0.2)');
                } else if (fissure.state === 'closing') {
                    const alpha = fissure.life / 60; // Fade out
                    gradient.addColorStop(0, `rgba(20, 10, 0, ${0.9 * alpha})`);
                    gradient.addColorStop(0.5, `rgba(50, 25, 10, ${0.7 * alpha})`);
                    gradient.addColorStop(0.8, `rgba(80, 40, 20, ${0.5 * alpha})`);
                    gradient.addColorStop(1, `rgba(100, 50, 25, ${0.2 * alpha})`);
                } else {
                    gradient.addColorStop(0, 'rgba(10, 5, 0, 1)'); // Very dark center
                    gradient.addColorStop(0.3, 'rgba(30, 15, 5, 0.9)');
                    gradient.addColorStop(0.6, 'rgba(60, 30, 15, 0.6)');
                    gradient.addColorStop(1, 'rgba(90, 45, 20, 0.3)');
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw danger edge
                if (fissure.state === 'open') {
                    ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.lineWidth = 3 * cameraZoom;
                    ctx.stroke();
                }
                
                // Draw cracks around the edge
                ctx.strokeStyle = 'rgba(50, 25, 10, 0.8)';
                ctx.lineWidth = 2 * cameraZoom;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const crackLength = radius * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(
                        screen.x + Math.cos(angle) * radius,
                        screen.y + Math.sin(angle) * radius
                    );
                    ctx.lineTo(
                        screen.x + Math.cos(angle) * (radius + crackLength),
                        screen.y + Math.sin(angle) * (radius + crackLength)
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function drawBossProjectiles() {
            bossProjectiles.forEach(projectile => {
                const screen = worldToScreen(projectile.x, projectile.y);
                
                ctx.save();
                
                switch(projectile.type) {
                    case 'fireball':
                        // Draw fireball
                        const gradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, projectile.size);
                        gradient.addColorStop(0, '#ffff00');
                        gradient.addColorStop(0.5, '#ff6600');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, projectile.size * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add fire emoji
                        const fireCanvas = getCachedEmoji('🔥', Math.round(projectile.size * cameraZoom));
                        ctx.drawImage(fireCanvas, screen.x - fireCanvas.width / 2, screen.y - fireCanvas.height / 2);
                        break;
                        
                    case 'waterwave':
                        // Draw expanding water ring
                        ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
                        ctx.lineWidth = 10 * cameraZoom;
                        ctx.beginPath();
                        ctx.arc(projectile.x - camera.x + canvas.width / 2, 
                               projectile.y - camera.y + canvas.height / 2, 
                               projectile.radius * cameraZoom, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                        ctx.lineWidth = 20 * cameraZoom;
                        ctx.stroke();
                        break;
                        
                    case 'rock':
                        if (projectile.falling) {
                            // Draw shadow at target position with warning indicator
                            const shadowScreen = worldToScreen(projectile.x, projectile.targetY);
                            
                            // Draw pulsing red warning circle
                            const warningPulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                            ctx.globalAlpha = warningPulse * 0.5;
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 3 * cameraZoom;
                            ctx.beginPath();
                            ctx.arc(shadowScreen.x, shadowScreen.y, 
                                  projectile.size * 1.5 * cameraZoom, 
                                  0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Draw shadow
                            ctx.globalAlpha = 0.3;
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.ellipse(shadowScreen.x, shadowScreen.y, 
                                      projectile.size * cameraZoom, 
                                      projectile.size * 0.5 * cameraZoom, 
                                      0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        
                        // Draw rock
                        const rockGradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, projectile.size);
                        rockGradient.addColorStop(0, '#8b6914');
                        rockGradient.addColorStop(0.7, '#654321');
                        rockGradient.addColorStop(1, '#4a3018');
                        ctx.fillStyle = rockGradient;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, projectile.size * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add rock emoji
                        const rockCanvas = getCachedEmoji('🪨', Math.round(projectile.size * 1.5 * cameraZoom));
                        ctx.drawImage(rockCanvas, screen.x - rockCanvas.width / 2, screen.y - rockCanvas.height / 2);
                        
                        // Draw impact crater if it exists
                        if (projectile.impactCrater) {
                            const crater = projectile.impactCrater;
                            const craterScreen = worldToScreen(crater.x, crater.y);
                            
                            // Draw crater with fading effect
                            const craterAlpha = crater.life / 180; // Fade out over time
                            ctx.globalAlpha = craterAlpha * 0.6;
                            
                            // Crater gradient
                            const craterGradient = ctx.createRadialGradient(
                                craterScreen.x, craterScreen.y, 0,
                                craterScreen.x, craterScreen.y, crater.radius * cameraZoom
                            );
                            craterGradient.addColorStop(0, 'rgba(50, 30, 10, 0.8)');
                            craterGradient.addColorStop(0.5, 'rgba(80, 50, 20, 0.5)');
                            craterGradient.addColorStop(1, 'rgba(100, 70, 30, 0)');
                            
                            ctx.fillStyle = craterGradient;
                            ctx.beginPath();
                            ctx.arc(craterScreen.x, craterScreen.y, crater.radius * cameraZoom, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Danger zone indicator
                            ctx.globalAlpha = craterAlpha * 0.3;
                            ctx.strokeStyle = '#ff4444';
                            ctx.lineWidth = 2 * cameraZoom;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.arc(craterScreen.x, craterScreen.y, crater.radius * cameraZoom, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        break;
                        
                    case 'waterorb':
                        // Draw water orb
                        const waterOrbGradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, projectile.size * cameraZoom);
                        waterOrbGradient.addColorStop(0, 'rgba(100, 200, 255, 0.8)');
                        waterOrbGradient.addColorStop(0.5, 'rgba(64, 164, 223, 0.6)');
                        waterOrbGradient.addColorStop(1, 'rgba(30, 100, 200, 0.4)');
                        
                        ctx.fillStyle = waterOrbGradient;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, projectile.size * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add water emoji
                        const waterCanvas = getCachedEmoji('💧', Math.round(projectile.size * 1.2 * cameraZoom));
                        ctx.drawImage(waterCanvas, screen.x - waterCanvas.width / 2, screen.y - waterCanvas.height / 2);
                        break;
                        
                    case 'void':
                        // Draw void projectile with dark purple energy
                        const voidGradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, projectile.size * cameraZoom);
                        voidGradient.addColorStop(0, 'rgba(155, 89, 182, 0.9)');
                        voidGradient.addColorStop(0.5, 'rgba(75, 0, 130, 0.7)');
                        voidGradient.addColorStop(1, 'rgba(25, 0, 51, 0.5)');
                        
                        ctx.fillStyle = voidGradient;
                        ctx.beginPath();
                        ctx.arc(screen.x, screen.y, projectile.size * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add void/dark energy effect
                        ctx.strokeStyle = 'rgba(155, 89, 182, 0.8)';
                        ctx.lineWidth = 3 * cameraZoom;
                        ctx.stroke();
                        
                        // Add void emoji or symbol
                        const voidCanvas = getCachedEmoji('🌀', Math.round(projectile.size * 1.3 * cameraZoom));
                        ctx.drawImage(voidCanvas, screen.x - voidCanvas.width / 2, screen.y - voidCanvas.height / 2);
                        break;
                        
                    case 'tornado':
                        // Save context for rotation
                        ctx.save();
                        ctx.translate(screen.x, screen.y);
                        ctx.rotate(projectile.rotation);
                        
                        // Draw swirling tornado effect
                        const tornadoGradient = ctx.createRadialGradient(0, 0, projectile.size * 0.2 * cameraZoom, 0, 0, projectile.size * cameraZoom);
                        tornadoGradient.addColorStop(0, 'rgba(135, 206, 235, 0.9)'); // Light blue center
                        tornadoGradient.addColorStop(0.3, 'rgba(100, 150, 200, 0.7)');
                        tornadoGradient.addColorStop(0.6, 'rgba(70, 130, 180, 0.5)');
                        tornadoGradient.addColorStop(1, 'rgba(50, 100, 150, 0.2)');
                        
                        ctx.fillStyle = tornadoGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, projectile.size * cameraZoom, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw spiral lines
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 2 * cameraZoom;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            const startAngle = (i * Math.PI * 2 / 3);
                            ctx.moveTo(0, 0);
                            const endX = Math.cos(startAngle) * projectile.size * cameraZoom;
                            const endY = Math.sin(startAngle) * projectile.size * cameraZoom;
                            ctx.quadraticCurveTo(
                                endX * 0.5, endY * 0.5 + 10 * cameraZoom,
                                endX, endY
                            );
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                        
                        // Add tornado emoji
                        const tornadoCanvas = getCachedEmoji('🌪️', Math.round(projectile.size * 1.5 * cameraZoom));
                        ctx.drawImage(tornadoCanvas, screen.x - tornadoCanvas.width / 2, screen.y - tornadoCanvas.height / 2);
                        break;
                }
                
                ctx.restore();
            });
        }
        
        function updateDamageNumbers(deltaTime) {
            damageNumbers = damageNumbers.filter(num => {
                num.y += num.vy * deltaTime;
                num.life -= deltaTime;
                num.vy += 0.2 * deltaTime; // Gravity
                return num.life > 0;
            });
        }
        
        function drawDamageNumbers() {
            damageNumbers.forEach(num => {
                const screen = worldToScreen(num.x, num.y);
                
                ctx.save();
                ctx.globalAlpha = num.life / 60; // Fade out
                ctx.font = `bold ${40 * cameraZoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw outline
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4 * cameraZoom;
                ctx.strokeText(num.text, screen.x, screen.y);
                
                // Draw text
                ctx.fillStyle = num.color;
                ctx.fillText(num.text, screen.x, screen.y);
                
                ctx.restore();
            });
        }
        
        // Helper functions
        function getGridKey(x, y) {
            const gridX = Math.floor(x / ELEMENT_GRID_SIZE);
            const gridY = Math.floor(y / ELEMENT_GRID_SIZE);
            return `${gridX},${gridY}`;
        }
        
        function updateElementGrid() {
            // Rebuild grid map based on current elements
            elementGrid.clear();
            const activeElements = elementPool.getActiveElements();
            
            activeElements.forEach(element => {
                const key = getGridKey(element.x, element.y);
                if (!elementGrid.has(key)) {
                    elementGrid.set(key, []);
                }
                elementGrid.get(key).push(element);
            });
        }
        
        function spawnElementWithGridDistribution() {
            // Update grid map
            updateElementGrid();
            
            // Find cells that need more elements
            const gridCellsX = Math.ceil(WORLD_SIZE / ELEMENT_GRID_SIZE);
            const gridCellsY = Math.ceil(WORLD_SIZE / ELEMENT_GRID_SIZE);
            const underfilledCells = [];
            
            for (let gx = 0; gx < gridCellsX; gx++) {
                for (let gy = 0; gy < gridCellsY; gy++) {
                    const key = `${gx},${gy}`;
                    const cellElements = elementGrid.get(key) || [];
                    
                    if (cellElements.length < MIN_ELEMENTS_PER_CELL) {
                        // Priority for empty or underfilled cells
                        underfilledCells.push({ gx, gy, count: cellElements.length, priority: 1 });
                    } else if (cellElements.length < MAX_ELEMENTS_PER_CELL) {
                        // Lower priority for partially filled cells
                        underfilledCells.push({ gx, gy, count: cellElements.length, priority: 0.3 });
                    }
                }
            }
            
            if (underfilledCells.length > 0) {
                // Sort by priority and element count
                underfilledCells.sort((a, b) => {
                    if (a.priority !== b.priority) return b.priority - a.priority;
                    return a.count - b.count;
                });
                
                // Pick from top candidates with some randomness
                const topCandidates = underfilledCells.slice(0, Math.min(5, underfilledCells.length));
                const selectedCell = topCandidates[Math.floor(Math.random() * topCandidates.length)];
                
                // Spawn in the selected cell
                const cellX = selectedCell.gx * ELEMENT_GRID_SIZE;
                const cellY = selectedCell.gy * ELEMENT_GRID_SIZE;
                
                // Random position within cell with margin
                const margin = 50;
                const x = cellX + margin + Math.random() * (ELEMENT_GRID_SIZE - margin * 2);
                const y = cellY + margin + Math.random() * (ELEMENT_GRID_SIZE - margin * 2);
                
                // Ensure within world bounds
                const finalX = Math.max(100, Math.min(WORLD_SIZE - 100, x));
                const finalY = Math.max(100, Math.min(WORLD_SIZE - 100, y));
                
                spawnElement(null, finalX, finalY);
            } else {
                // Fallback to random spawn if all cells are filled
                spawnElement();
            }
        }
        
        function spawnElement(id = null, x = null, y = null) {
            if (id === null || id === undefined) {
                // Smart spawning: bias towards elements that can combine with what snakes are carrying
                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                    // Focus on PLAYER's carried elements for smart spawning
                    const playerCarriedElements = new Set();
                    const allCarriedElements = new Set();
                    
                    snakes.forEach(snake => {
                        if (snake && snake.alive) {
                            snake.elements.forEach(elemId => {
                                allCarriedElements.add(elemId);
                                if (snake.isPlayer) {
                                    playerCarriedElements.add(elemId);
                                }
                            });
                        }
                    });
                    
                    // Build weighted spawn list
                    const spawnWeights = new Map();
                    
                    // Determine progression phase based on PLAYER discoveries only (much lower base weights)
                    const discoveryCount = playerDiscoveredElements.size;
                    let phase;
                    if (discoveryCount <= 10) {
                        phase = { name: 'TUTORIAL', baseWeight: 4, discoveredWeight: 2 };
                    } else if (discoveryCount <= 25) {
                        phase = { name: 'EARLY', baseWeight: 1, discoveredWeight: 5 };
                    } else if (discoveryCount <= 50) {
                        phase = { name: 'MID', baseWeight: 0.3, discoveredWeight: 8 };
                    } else if (discoveryCount <= 100) {
                        phase = { name: 'LATE', baseWeight: 0.1, discoveredWeight: 10 };
                    } else {
                        phase = { name: 'MASTER', baseWeight: 0.05, discoveredWeight: 12 };
                    }
                    
                    // 60% chance to prioritize spawning for player combinations/discoveries
                    const prioritizePlayerCombos = Math.random() < 0.6;
                    const prioritizeDiscovery = Math.random() < 0.4;
                    
                    // Less verbose debug logging
                    if (Math.random() < 0.05) { // Only log 5% of the time
                    }
                    
                    // Clean up old discovery echoes
                    const now = Date.now();
                    for (const [elemId, timestamp] of recentlyDiscoveredElements) {
                        if (now - timestamp > DISCOVERY_ECHO_DURATION) {
                            recentlyDiscoveredElements.delete(elemId);
                        }
                    }
                    
                    // Iterate through all elements in the new system
                    let totalDiscoveredNonBase = 0;
                    for (const [elemId, element] of window.elementLoader.elements) {
                        let weight = 0; // Start with 0 weight
                        
                        // Check if element should spawn
                        // IMPORTANT: Only IDs 0,1,2,3 are true base elements, not all tier 0!
                        const elemIdNum = typeof elemId === 'string' ? parseInt(elemId) : elemId;
                        const isBaseElement = elemIdNum >= 0 && elemIdNum <= 3;
                        // IMPORTANT: Only spawn elements the PLAYER has discovered, not AI discoveries
                        const isPlayerDiscovered = playerDiscoveredElements.has(elemIdNum);
                        
                        if (isBaseElement || isPlayerDiscovered) {
                            // Base weight calculation
                            if (isBaseElement) {
                                weight = phase.baseWeight;
                            } else {
                                // Discovered non-base elements
                                const tierModifier = Math.max(0.5, 1 - (element.t * 0.05)); // Less harsh tier penalty
                                weight = phase.discoveredWeight * tierModifier;
                                totalDiscoveredNonBase++;
                            }
                            
                            // Anti-clustering: reduce weight if recently spawned (less harsh)
                            const recentSpawnCount = recentlySpawnedElements.filter(id => id === elemId).length;
                            if (recentSpawnCount > 0) {
                                weight *= Math.pow(0.5, recentSpawnCount); // 50% reduction per recent spawn (was 80%)
                            }
                            
                            // SPECIAL CASE: Heavily reduce Fire element after early game
                            if (elemId === 3 && discoveryCount > 10) { // Fire element ID is 3 (correct)
                                weight *= 0.1; // 90% reduction for Fire after 10 discoveries
                            }
                            
                            // Discovery echo: boost recently discovered elements
                            if (recentlyDiscoveredElements.has(elemId)) {
                                weight *= 5; // 5x boost for recently discovered elements
                            }
                            
                            // Ensure minimum weight for player-discovered elements
                            if (isPlayerDiscovered && !isBaseElement && weight > 0) {
                                weight = Math.max(weight, 0.5); // Minimum weight of 0.5 for player-discovered elements
                            }
                            
                            let hasPlayerCombo = false;
                            let hasUndiscoveredCombo = false;
                            
                            // MASSIVE bonus for elements that can combine with PLAYER's bank
                            if (prioritizePlayerCombos && playerCarriedElements.size > 0) {
                                for (const carriedId of playerCarriedElements) {
                                    const comboKey = `${Math.min(elemId, carriedId)}+${Math.max(elemId, carriedId)}`;
                                    const resultId = window.elementLoader.combinations[comboKey];
                                    if (resultId !== undefined && resultId !== null) {
                                        hasPlayerCombo = true;
                                        // Check if the result is discovered by player
                                        if (!playerDiscoveredElements.has(resultId)) {
                                            hasUndiscoveredCombo = true;
                                            weight *= 20; // MASSIVE bonus for new discoveries from player's bank
                                        } else {
                                            weight *= 10; // Big bonus for known combinations with player's bank
                                        }
                                    }
                                }
                            }
                            
                            // Secondary check for other snakes if not prioritizing player
                            if (!hasPlayerCombo && allCarriedElements.size > 0) {
                                for (const carriedId of allCarriedElements) {
                                    const comboKey = `${Math.min(elemId, carriedId)}+${Math.max(elemId, carriedId)}`;
                                    const resultId = window.elementLoader.combinations[comboKey];
                                    if (resultId !== undefined && resultId !== null) {
                                        if (!playerDiscoveredElements.has(resultId)) {
                                            weight *= 3; // Smaller bonus for AI snake potential discoveries
                                        } else {
                                            weight *= 1.5; // Small bonus for AI snake combinations
                                        }
                                        break; // Only apply once
                                    }
                                }
                            }
                            
                            // Additional bonus for elements that can lead to many undiscovered combinations
                            if (prioritizeDiscovery && !hasUndiscoveredCombo) {
                                // Check how many undiscovered combinations this element can create
                                let undiscoveredPotential = 0;
                                for (const [otherId, otherElem] of window.elementLoader.elements) {
                                    if (playerDiscoveredElements.has(otherId) || otherElem.t === 0) { // Player discovered or base element
                                        const comboKey = `${Math.min(elemId, otherId)}+${Math.max(elemId, otherId)}`;
                                        const resultId = window.elementLoader.combinations[comboKey];
                                        if (resultId !== undefined && resultId !== null && !playerDiscoveredElements.has(resultId)) {
                                            undiscoveredPotential++;
                                        }
                                    }
                                }
                                
                                if (undiscoveredPotential > 0) {
                                    weight *= (1 + undiscoveredPotential * 0.5); // Bonus based on discovery potential
                                }
                            }
                        }
                        
                        if (weight > 0) {
                            spawnWeights.set(elemId, weight);
                        }
                    }
                    
                    // Weighted random selection
                    let totalWeight = 0;
                    spawnWeights.forEach(w => totalWeight += w);
                    
                    // Debug spawn weights at game start
                    const weightsGameTime = Date.now() - gameStartTime;
                    if (weightsGameTime < 5000) { // First 5 seconds
                        spawnWeights.forEach((weight, elemId) => {
                            const elem = window.elementLoader.elements.get(elemId);
                            const elemIdNum = typeof elemId === 'string' ? parseInt(elemId) : elemId;
                            const isRealBase = elemIdNum >= 0 && elemIdNum <= 3;
                            if (elem && !isRealBase) { // Non-base elements (excluding IDs 0-3)
                            }
                        });
                    }
                    
                    // Add discovered elements debug
                    if (totalDiscoveredNonBase > 0 && Math.random() < 0.02) {
                    }
                    
                    // If we have very few spawn options, force add some player-discovered elements
                    if (spawnWeights.size < 10 && playerDiscoveredElements.size > 10) {
                        // Add random player-discovered elements to spawn pool
                        const playerDiscoveredArray = Array.from(playerDiscoveredElements);
                        for (let i = 0; i < 5; i++) {
                            const randomDiscovered = playerDiscoveredArray[Math.floor(Math.random() * playerDiscoveredArray.length)];
                            if (!spawnWeights.has(randomDiscovered)) {
                                const elem = window.elementLoader.elements.get(randomDiscovered);
                                if (elem && elem.t > 0) { // Non-base element
                                    spawnWeights.set(randomDiscovered, phase.discoveredWeight * 0.5);
                                    totalWeight += phase.discoveredWeight * 0.5;
                                }
                            }
                        }
                    }
                    
                    let rand = Math.random() * totalWeight;
                    let selectedId = null;
                    
                    for (const [elemId, weight] of spawnWeights) {
                        rand -= weight;
                        if (rand <= 0) {
                            selectedId = elemId;
                            break;
                        }
                    }
                    
                    id = (selectedId !== null && selectedId !== undefined) ? selectedId : 3; // Fallback to Fire (ID 3) if something goes wrong
                    
                    // ALWAYS log what's being spawned at game start
                    const spawnGameTime = Date.now() - gameStartTime;
                    if (spawnGameTime < 5000) { // First 5 seconds
                        const elem = window.elementLoader.elements.get(id);
                    }
                    
                    // Debug what was selected (with player bank info)
                    if (selectedId !== undefined && selectedId !== null && window.elementLoader && Math.random() < 0.1) {
                        const elem = window.elementLoader.elements.get(selectedId);
                        if (elem && playerCarriedElements.size > 0) {
                            // Check if this can combine with player's bank
                            let canCombine = false;
                            for (const carriedId of playerCarriedElements) {
                                const comboKey = `${Math.min(selectedId, carriedId)}+${Math.max(selectedId, carriedId)}`;
                                if (window.elementLoader.combinations[comboKey]) {
                                    canCombine = true;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Fallback - use base elements
                    const basics = [0, 1, 2, 3]; // Earth, Water, Air, Fire
                    id = basics[Math.floor(Math.random() * basics.length)];
                }
            }
            
            // Random position if not specified
            if (!x || !y) {
                // Try to find a position not too close to snakes
                let attempts = 0;
                const maxAttempts = 20;
                const minDistanceFromSnakes = 150; // Minimum distance from any snake
                
                while (attempts < maxAttempts) {
                    x = 100 + Math.random() * (WORLD_SIZE - 200);
                    y = 100 + Math.random() * (WORLD_SIZE - 200);
                    
                    // Check distance from all snakes
                    let tooClose = false;
                    for (const snake of snakes) {
                        if (snake && snake.alive) {
                            // Check distance to snake head
                            const dist = Math.hypot(snake.x - x, snake.y - y);
                            if (dist < minDistanceFromSnakes) {
                                tooClose = true;
                                break;
                            }
                            
                            // Also check first few segments
                            for (let i = 0; i < Math.min(5, snake.segments.length); i++) {
                                const segment = snake.segments[i];
                                const segDist = Math.hypot(segment.x - x, segment.y - y);
                                if (segDist < minDistanceFromSnakes) {
                                    tooClose = true;
                                    break;
                                }
                            }
                            
                            if (tooClose) break;
                        }
                    }
                    
                    if (!tooClose) {
                        break; // Found a good position
                    }
                    
                    attempts++;
                }
                
                // If we couldn't find a good position after max attempts, use the last one
                if (attempts >= maxAttempts) {
                }
            }
            
            // Add to spawn history for anti-clustering
            recentlySpawnedElements.push(id);
            if (recentlySpawnedElements.length > MAX_SPAWN_HISTORY) {
                recentlySpawnedElements.shift(); // Remove oldest
            }
            
            // Also check distance from other elements to prevent clustering
            const minDistanceBetweenSameElements = 200;
            const activeElements = elementPool.getActiveElements();
            for (const element of activeElements) {
                if (element.id === id && element !== elementPool.activeElements[elementPool.activeElements.length - 1]) {
                    const dist = Math.hypot(element.x - x, element.y - y);
                    if (dist < minDistanceBetweenSameElements) {
                        // Try to find a better position
                        x = 100 + Math.random() * (WORLD_SIZE - 200);
                        y = 100 + Math.random() * (WORLD_SIZE - 200);
                        break;
                    }
                }
            }
            
            elementPool.spawn(id, x, y);
        }
        
        function createCombinationParticles(x, y) {
            const particleCount = isMobile ? 10 : 20; // Reduced for mobile
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particlePool.spawn(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    `hsl(${Math.random() * 360}, 70%, 50%)`
                );
            }
        }
        
        function createDeathParticles(x, y, snakeLength = 5) {
            // Scale particle count and speed based on snake size
            const baseParticles = isMobile ? 10 : 20;
            const particleCount = Math.min(baseParticles + Math.floor(snakeLength / (isMobile ? 4 : 2)), isMobile ? 30 : 100);
            const speedMultiplier = 1 + (snakeLength / 50);
            const pixelSize = 4;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * speedMultiplier;
                const size = Math.random() > 0.5 ? pixelSize : pixelSize * 2;
                particlePool.spawn(
                    Math.floor(x / pixelSize) * pixelSize,
                    Math.floor(y / pixelSize) * pixelSize,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    '#ff0000',
                    size
                );
            }
            
            // Add some larger pixel blocks for bigger snakes
            if (snakeLength > 20) {
                const largeParticleCount = Math.min(Math.floor(snakeLength / 10), 20);
                for (let i = 0; i < largeParticleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 3 + 1) * speedMultiplier;
                    particlePool.spawn(
                        Math.floor(x / pixelSize) * pixelSize,
                        Math.floor(y / pixelSize) * pixelSize,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#ff6600',
                        pixelSize * 3
                    );
                }
            }
        }
        
        function showCombinationMessage(id1, id2, resultId, isNew) {
            // Get element data from new system using numeric IDs
            const elem1Data = window.elementLoader.elements.get(id1);
            const elem2Data = window.elementLoader.elements.get(id2);
            const resultData = window.elementLoader.elements.get(resultId);
            
            if (!elem1Data || !elem2Data || !resultData) {
                console.error('Missing element data for combination message');
                return;
            }
            
            const emoji1 = window.elementLoader.getEmojiForElement(id1, elem1Data.e);
            const emoji2 = window.elementLoader.getEmojiForElement(id2, elem2Data.e);
            const emojiResult = window.elementLoader.getEmojiForElement(resultId, resultData.e);
            
            let message = `${emoji1} ${elem1Data.n} + ${emoji2} ${elem2Data.n} = ${emojiResult} ${resultData.n}`;
            if (isNew) {
                message = `New Discovery! ${message}`;
                // Update discovery log for new discoveries
                lastDiscoveredElement = resultId;
                updateDiscoveryLog();
                
                // Add to discovery echo system for boosted spawning
                recentlyDiscoveredElements.set(resultId, Date.now());
                
                // Add to discovery feed
                const recipeText = `${emoji1} ${elem1Data.n} + ${emoji2} ${elem2Data.n}`;
                throttledAddDiscovery({
                    emoji: emojiResult,
                    name: resultData.n
                }, recipeText);
            } else {
                message = `Combo! ${message}`;
            }
            
            showMessage(message, isNew, 5000);
        }
        
        function showMessage(text, isDiscovery, timeout = 3000) {
            const popup = document.getElementById('recentDiscovery');
            popup.innerHTML = text;
            
            // Handle different types of messages
            if (isDiscovery === 'gold') {
                popup.className = 'show gold';
            } else if (isDiscovery === 'red') {
                popup.className = 'show red';
            } else if (isDiscovery === 'cyan') {
                popup.className = 'show cyan';
            } else if (isDiscovery === 'purple') {
                popup.className = 'show purple';
            } else if (isDiscovery === 'orange') {
                popup.className = 'show orange';
            } else if (isDiscovery === 'combo') {
                popup.className = 'show combo';
            } else if (isDiscovery === true) {
                popup.className = 'show';
            } else {
                popup.className = 'show combo';
            }
            
            popup.style.opacity = '1';
            
            // Clear any existing timeout
            if (popup.hideTimeout) {
                clearTimeout(popup.hideTimeout);
            }
            
            // Set new timeout
            popup.hideTimeout = setTimeout(() => {
                popup.style.opacity = '0';
                popup.className = '';
            }, timeout);
        }
        
        // Boss Victory Message function
        function showBossVictoryMessage(boss, skinUnlocked, elementBankExpanded) {
            const victoryBox = document.getElementById('bossVictoryMessage');
            
            // Build the message content
            let html = '<h2>BOSS VANQUISHED!</h2>';
            html += `<div class="boss-name">${boss.name}</div>`;
            
            // Add defeat flavor text based on boss type
            let defeatText = '';
            switch(boss.bossType) {
                case 'PYRAXIS':
                    defeatText = "The Molten Lord's flames are extinguished! Banished to the eternal void!";
                    break;
                case 'ABYSSOS':
                    defeatText = "The Deep One sinks into the abyss! Cast into the void's embrace!";
                    break;
                case 'ZEPHYRUS':
                    defeatText = "The Storm Caller's winds are silenced! Scattered to the void!";
                    break;
                case 'OSSEUS':
                    defeatText = "The Bone Sovereign crumbles to dust! Entombed in the void!";
                    break;
                default:
                    defeatText = `${boss.name} has been banished to the void!`;
            }
            html += `<div class="defeat-text">${defeatText}</div>`;
            
            // Add rewards section
            html += '<div class="rewards">';
            html += '<div class="reward-item highlight">✨ +10,000 Points!</div>';
            html += '<div class="reward-item">💎 4x Catalyst Gems</div>';
            html += '<div class="reward-item">🌀 2x Void Orbs</div>';
            html += '<div class="reward-item">🔥 16x Boss Elements</div>';
            
            // Only show skin unlock if it's new
            if (skinUnlocked) {
                const skinName = BOSS_TYPES[boss.bossType].skin;
                html += `<div class="reward-item highlight">🎨 ${boss.name} Skin Unlocked!</div>`;
            }
            
            // Show element bank expansion if applicable
            if (elementBankExpanded) {
                html += `<div class="reward-item highlight">📦 Element Bank Expanded!</div>`;
            }
            
            html += '</div>';
            
            // Set the content and show the message
            victoryBox.innerHTML = html;
            victoryBox.className = 'show';
            victoryBox.style.display = 'block';
            
            // Clear any existing timeout
            if (victoryBox.hideTimeout) {
                clearTimeout(victoryBox.hideTimeout);
            }
            
            // Hide after 8 seconds
            victoryBox.hideTimeout = setTimeout(() => {
                victoryBox.style.opacity = '0';
                setTimeout(() => {
                    victoryBox.style.display = 'none';
                    victoryBox.className = '';
                    victoryBox.style.opacity = '1';
                }, 300);
            }, 8000);
        }
        
        // Victory popup function
        function showVictoryScreen(type, target) {
            const overlay = document.getElementById('victoryOverlay');
            const scoreDisplay = document.getElementById('victoryScore');
            const discoveryDisplay = document.getElementById('victoryDiscoveries');
            const timeDisplay = document.getElementById('victoryTime');
            const loreDisplay = document.getElementById('victoryLore');
            
            // Calculate game time
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            // Set stats
            scoreDisplay.textContent = playerSnake.score.toLocaleString();
            const discoveryCount = discoveredElements.size;
            discoveryDisplay.textContent = `${discoveryCount}`;
            timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Set lore message based on victory type
            const loreMessages = {
                discovery: [
                    `You have mastered the art of elemental fusion, discovering ${target} unique combinations. The universe bows to your alchemical prowess!`,
                    `Through countless experiments, you've unlocked ${target} elemental secrets. Your name shall be etched in the annals of discovery!`,
                    `The elements themselves whisper your name. ${target} discoveries mark you as a true Alchemist of the Infinite!`
                ],
                points: [
                    `With ${playerSnake.score.toLocaleString()} points, you've proven your mastery over the elemental realm. The serpent of infinity coils in reverence!`,
                    `Your score of ${playerSnake.score.toLocaleString()} echoes through the void. You are the undisputed champion of the elemental dance!`,
                    `${playerSnake.score.toLocaleString()} points! The very fabric of reality trembles at your achievement. You are legend incarnate!`
                ]
            };
            
            const messages = loreMessages[type] || [`Victory achieved with ${playerSnake.score.toLocaleString()} points!`];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            loreDisplay.textContent = randomMessage;
            
            // Show overlay
            overlay.style.display = 'flex';
            gameRunning = false;
            
            // Play victory sound if available
            if (eatSounds.length > 0 && !musicMuted) {
                const sound = eatSounds[0];
                sound.currentTime = 0;
                sound.volume = 0.75;
                sound.play().catch(e => {});
            }
        }
        
        // Add discovery to the feed (MMO chat-style)
        function addDiscoveryToFeed(element, recipe) {
            const feed = document.getElementById('discoveryFeed');
            if (!feed) {
                console.error('Discovery feed element not found!');
                return;
            }
            
            // Debug: Make sure feed is visible
            const feedContainer = document.querySelector('.discovery-feed');
            if (feedContainer) {
                feedContainer.style.display = 'flex';
                feedContainer.style.opacity = '1';
                feedContainer.style.visibility = 'visible';
            }
            
            const message = document.createElement('div');
            message.className = 'discovery-message new-message';
            
            // Recipe is passed as parameter now
            let recipeText = recipe || '';
            
            message.innerHTML = `
                <span class="emoji">${element.emoji}</span>
                <div class="discovery-text">
                    <div class="discovery-name">${element.name}</div>
                    ${recipeText ? `<div class="discovery-combo">${recipeText}</div>` : ''}
                </div>
            `;
            
            feed.appendChild(message);
            
            // Auto-scroll to bottom
            feed.scrollTop = feed.scrollHeight;
            
            // Add fade animation timeout
            setTimeout(() => {
                message.classList.remove('new-message');
                message.classList.add('faded-message');
            }, 3000);
            
            // Update message opacity based on position
            const updateMessageOpacity = () => {
                const messages = feed.querySelectorAll('.discovery-message');
                messages.forEach((msg, index) => {
                    const opacity = Math.max(0.4, 1 - (messages.length - index - 1) * 0.15);
                    msg.style.opacity = opacity;
                });
            };
            updateMessageOpacity();
            
            // Limit messages to prevent memory issues (reduce for mobile)
            const maxMessages = isTabletOrMobile() ? 10 : 20;
            while (feed.children.length > maxMessages) {
                feed.removeChild(feed.firstChild);
            }
            
        }
        
        // Throttled version for mobile performance
        let messageUpdateTimeout;
        function throttledAddDiscovery(element, recipe) {
            if (isTabletOrMobile()) {
                clearTimeout(messageUpdateTimeout);
                messageUpdateTimeout = setTimeout(() => {
                    addDiscoveryToFeed(element, recipe);
                }, 100);
            } else {
                addDiscoveryToFeed(element, recipe);
            }
        }
        
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            
            // Sort snakes based on game mode
            let sortedSnakes = [...snakes].filter(s => s.alive);
            
            if (gameMode === 'discovery') {
                // Sort by discoveries, then by score
                sortedSnakes.sort((a, b) => {
                    if (b.discoveries !== a.discoveries) {
                        return b.discoveries - a.discoveries;
                    }
                    return b.score - a.score;
                });
            } else {
                // Sort by score
                sortedSnakes.sort((a, b) => b.score - a.score);
            }
            
            // Mark the leader
            snakes.forEach(s => s.isLeader = false);
            if (sortedSnakes.length > 0) {
                sortedSnakes[0].isLeader = true;
            }
            
            // Display top 5 with MMO-style formatting
            leaderboardList.innerHTML = '';
            sortedSnakes.slice(0, 5).forEach((snake, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                
                if (index === 0) {
                    div.classList.add('leader');
                }
                if (snake.isPlayer) {
                    div.classList.add('player');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                
                // Handle colored personality names for AI snakes
                if (!snake.isPlayer && snake.personality) {
                    // Add crown for leader
                    if (index === 0) {
                        const crownSpan = document.createElement('span');
                        crownSpan.textContent = '👑 ';
                        nameSpan.appendChild(crownSpan);
                    }
                    
                    // Split name into personality and actual name
                    const personalityName = snake.personality.name + ' ';
                    const actualName = snake.name.substring(personalityName.length);
                    
                    // Create colored personality span
                    const personalitySpan = document.createElement('span');
                    personalitySpan.style.color = snake.personalityColor;
                    personalitySpan.style.fontWeight = 'bold';
                    personalitySpan.textContent = personalityName;
                    
                    // Create white name span
                    const actualNameSpan = document.createElement('span');
                    actualNameSpan.style.color = '#ffffff';
                    actualNameSpan.textContent = actualName;
                    
                    nameSpan.appendChild(personalitySpan);
                    nameSpan.appendChild(actualNameSpan);
                } else {
                    // Player or fallback - normal display
                    nameSpan.textContent = (index === 0 ? '👑 ' : '') + snake.name;
                }
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'leaderboard-stats';
                const discoveriesText = isMobile ? 'disc.' : 'discoveries';
                statsDiv.innerHTML = `
                    <div>${Math.floor(snake.score).toLocaleString()} pts</div>
                    <div>${snake.discoveries || 0} ${discoveriesText}</div>
                `;
                
                div.appendChild(nameSpan);
                div.appendChild(statsDiv);
                leaderboardList.appendChild(div);
            });
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            // Get all PLAYER discovered elements and sort by tier (highest first)
            const discovered = Array.from(playerDiscoveredElements)
                .map(key => {
                    // Try new system first
                    if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                        const element = window.elementLoader.getElementByKey(key);
                        if (element) return { key, element };
                    }
                    // Fallback to old system
                    const element = elementDatabase[key];
                    if (element) return { key, element };
                    return null;
                })
                .filter(item => item !== null)
                .sort((a, b) => {
                    // Sort by tier descending, then alphabetically
                    if (b.element.tier !== a.element.tier) {
                        return b.element.tier - a.element.tier;
                    }
                    return a.element.name.localeCompare(b.element.name);
                });
            
            discovered.forEach(({ key, element }) => {
                const div = document.createElement('div');
                div.className = 'discovery-item';
                
                // Highlight if this is the newest discovery
                if (key === lastDiscoveredElement) {
                    div.classList.add('new');
                }
                
                div.innerHTML = `
                    <div class="emoji">${element.emoji}</div>
                    <div class="info">
                        <div class="name">${element.name}</div>
                        <div class="tier">Tier ${element.tier}</div>
                    </div>
                `;
                list.appendChild(div);
            });
            
            // Update count in header
            const header = document.querySelector('#discoveryLog h3');
            if (header) {
                header.textContent = `Discoveries (${discovered.length})`;
            }
        }
        
        // Update boost bar separately for real-time updates
        function updateBoostBar() {
            if (!playerSnake) return;
            
            const boostFill = document.getElementById('boostBarFill');
            if (!boostFill) return;
            
            // Calculate stamina percentage
            const staminaPercent = Math.max(0, Math.min(100, (playerSnake.stamina / playerSnake.maxStamina) * 100));
            
            // Force immediate style update
            boostFill.style.width = staminaPercent + '%';
            
            // Force browser to recalculate styles
            boostFill.offsetWidth;
            
            // Change color based on stamina level
            if (staminaPercent <= 20) {
                boostFill.className = 'boost-bar-fill low';
            } else if (playerSnake.isBoosting) {
                boostFill.className = 'boost-bar-fill boosting';
            } else {
                boostFill.className = 'boost-bar-fill';
            }
        }
        
        // Leaderboard Integration Variables
        let supabaseModule = null;
        let leaderboardSubmitted = false;
        let currentGameSessionId = null;
        let gameSessionStartTime = null;
        
        // Test function to verify script is working
        window.testLeaderboard = function() {
        }
        
        // Initialize Supabase when the module loads
        async function initSupabase() {
            try {
                supabaseModule = await import('./js/supabase.js');
                await supabaseModule.initializeAuth();
                
                // Update any waiting submission forms
                const statusEl = document.getElementById('submissionStatus');
                if (statusEl && statusEl.textContent.includes('not ready')) {
                    statusEl.innerHTML = '';
                }
            } catch (error) {
                console.error('Failed to initialize Supabase:', error);
                // Show error in submission status if visible
                const statusEl = document.getElementById('submissionStatus');
                if (statusEl) {
                    statusEl.innerHTML = '<span style="color: #ff4444;">Leaderboard service unavailable</span>';
                }
            }
        }
        
        // Call this when the game starts
        initSupabase();
        
        // Add event listeners when elements become visible
        function setupLeaderboardListeners() {
            
            // Only set up the username input Enter key listener
            // The buttons already have onclick attributes, so we don't need to add more listeners
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput && !usernameInput.hasListener) {
                usernameInput.hasListener = true;
                usernameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        window.submitToLeaderboard();
                    }
                });
            }
            
        }
        
        // Try to set up listeners on page load and when respawn overlay is shown
        document.addEventListener('DOMContentLoaded', setupLeaderboardListeners);
        
        // Also expose it globally so we can call it when the overlay is shown
        window.setupLeaderboardListeners = setupLeaderboardListeners;
        
        // Submit score to leaderboard
        window.submitToLeaderboard = async function() {
            playUISound();
            
            // Visual feedback
            const submitBtn = document.getElementById('submitScoreBtn');
            if (submitBtn) {
                submitBtn.style.opacity = '0.7';
            }
            
            // Check if Supabase module is loaded
            if (!supabaseModule) {
                console.error('Supabase module not loaded');
                document.getElementById('submissionStatus').innerHTML = 
                    '<span style="color: #ff4444;">Leaderboard service not ready. Please try again.</span>';
                if (submitBtn) {
                    submitBtn.style.opacity = '1';
                }
                return;
            }
            
            // Check if already submitted
            if (leaderboardSubmitted) {
                return;
            }
            
            const usernameInput = document.getElementById('usernameInput');
            const username = usernameInput.value.trim();
            
            if (!username) {
                document.getElementById('submissionStatus').innerHTML = 
                    '<span style="color: #ff4444;">Please enter a username</span>';
                return;
            }
            
            // Check minimum play time
            // Time validation removed - allow immediate submission
            const playTime = gameSessionStartTime ? 
                Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0;
            
            // Store username for future use
            localStorage.setItem('lastUsername', username);
            
            // Reuse the submitBtn variable from earlier
            submitBtn.disabled = true;
            submitBtn.textContent = 'SUBMITTING...';
            
            document.getElementById('submissionStatus').innerHTML = 
                '<span style="color: #4ecdc4;">Submitting score...</span>';
            
            try {
                
                // Calculate play time in seconds
                const playTime = gameSessionStartTime ? 
                    Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0;
                
                console.log('Score data:', {
                    username,
                    score: Math.floor(playerSnake.score),
                    elements: playerDiscoveredElements.size,
                    playTime,
                    kills: playerSnake.kills
                });
                
                
                let result;
                try {
                    result = await supabaseModule.submitScore(
                        username,
                        Math.floor(playerSnake.score),
                        playerDiscoveredElements.size,
                        playTime,
                        playerSnake.kills
                    );
                    console.log('Submission result:', result);
                } catch (supabaseError) {
                    console.error('Supabase error details:', supabaseError);
                    
                    // Extract error message from Supabase error
                    let errorMsg = 'Score validation failed';
                    if (supabaseError.message) {
                        errorMsg = supabaseError.message;
                    }
                    if (supabaseError.details) {
                        errorMsg = supabaseError.details;
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // If we got here, submission was successful
                if (result !== null && result !== undefined) {
                    leaderboardSubmitted = true;
                    const rank = result.daily_rank || result.rank || result || 'Submitted';
                    const statusElement = document.getElementById('submissionStatus');
                    statusElement.innerHTML = 
                        `<div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.3) 0%, rgba(78, 205, 196, 0.1) 100%);
                                    border: 2px solid #4ecdc4;
                                    border-radius: 8px;
                                    padding: 15px;
                                    margin: 10px 0;
                                    text-align: center;
                                    animation: successPulse 0.5s ease-out;
                                    position: relative;
                                    z-index: 1000;">
                            <div style="font-size: 24px; margin-bottom: 5px;">✅</div>
                            <span style="color: #4ecdc4; font-size: 16px; font-weight: bold;">
                                Score Successfully Submitted!
                            </span>
                            <div style="color: #4ecdc4; font-size: 18px; margin-top: 8px;">
                                ${typeof rank === 'number' ? `🏆 Daily Rank: #${rank}` : ''}
                            </div>
                        </div>`;
                    
                    // Force immediate DOM update and ensure visibility
                    statusElement.style.display = 'block';
                    statusElement.style.visibility = 'visible';
                    statusElement.style.opacity = '1';
                    statusElement.style.position = 'relative';
                    statusElement.style.zIndex = '1000';
                    
                    // Force browser to recalculate styles
                    statusElement.offsetHeight;
                    
                    // Ensure parent container is visible
                    const submissionContainer = document.getElementById('leaderboardSubmission');
                    if (submissionContainer) {
                        submissionContainer.style.display = 'block';
                        submissionContainer.style.opacity = '1';
                        submissionContainer.style.visibility = 'visible';
                        submissionContainer.style.position = 'relative';
                        submissionContainer.style.zIndex = '1000';
                    }
                    
                    // Add success animation CSS if not already present
                    if (!document.getElementById('successAnimationStyle')) {
                        const style = document.createElement('style');
                        style.id = 'successAnimationStyle';
                        style.textContent = `
                            @keyframes successPulse {
                                0% { transform: scale(0.9); opacity: 0; }
                                50% { transform: scale(1.05); }
                                100% { transform: scale(1); opacity: 1; }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // Disable submit button to prevent double submission
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'SUBMITTED ✓';
                    submitBtn.style.opacity = '0.6';
                    submitBtn.style.background = '#4ecdc4';
                    submitBtn.style.color = '#000';
                    
                    // Hide submission form and show respawn timer after longer delay
                    setTimeout(() => {
                        document.getElementById('leaderboardSubmission').style.display = 'none';
                        document.getElementById('respawnTimerDiv').style.display = 'block';
                        document.getElementById('quickRespawnDiv').style.display = 'block';
                    }, 3000);
                } else {
                    throw new Error('No response from server');
                }
            } catch (error) {
                console.error('Leaderboard submission error:', error);
                
                // Check if it's a Supabase error with details
                let errorMessage = 'Score validation failed';
                if (error.message) {
                    errorMessage = error.message;
                }
                if (error.details) {
                    console.error('Error details:', error.details);
                }
                if (error.code) {
                    console.error('Error code:', error.code);
                }
                
                document.getElementById('submissionStatus').innerHTML = 
                    `<span style="color: #ff4444;">Failed to submit: ${errorMessage}</span>`;
                submitBtn.disabled = false;
                submitBtn.textContent = 'SUBMIT SCORE';
                submitBtn.style.opacity = '1';
            }
        }
        
        // Skip leaderboard submission
        window.skipLeaderboard = function() {
            console.log('skipLeaderboard called - Skip button clicked!');
            
            // Visual feedback
            const skipBtn = document.getElementById('skipScoreBtn');
            if (skipBtn) {
                skipBtn.style.opacity = '0.7';
            }
            
            leaderboardSubmitted = true;
            document.getElementById('leaderboardSubmission').style.display = 'none';
            document.getElementById('respawnTimerDiv').style.display = 'block';
            document.getElementById('quickRespawnDiv').style.display = 'block';
            
            console.log('Skip successful - showing respawn timer');
        }
        
        // Force immediate respawn
        window.forceRespawn = function() {
            playUISound();
            console.log('forceRespawn called');
            if (playerRespawnTimer > 0) {
                playerRespawnTimer = 100; // Set to almost 0 to trigger respawn
            }
        }
        
        // Handle revive or respawn button click
        window.handleReviveOrRespawn = function() {
            playUISound();
            
            if (revivesRemaining > 0) {
                // Use a revive
                revivesRemaining--;
                
                // Update button text
                const reviveBtn = document.getElementById('reviveBtn');
                if (reviveBtn) {
                    if (revivesRemaining > 0) {
                        reviveBtn.innerHTML = `REVIVE (<span id="revivesLeft">${revivesRemaining}</span>)`;
                    } else {
                        reviveBtn.innerHTML = 'RESPAWN';
                        reviveBtn.style.background = '#9c88ff';
                        reviveBtn.style.borderColor = '#9c88ff';
                        reviveBtn.style.boxShadow = '0 0 20px rgba(156, 136, 255, 0.5)';
                        document.getElementById('actionText').textContent = 'respawn';
                        const respawnPenaltyText = document.getElementById('respawnPenaltyText');
                        if (respawnPenaltyText) respawnPenaltyText.style.display = 'block';
                    }
                }
                
                // Set flag for revive (will be handled in respawn logic)
                window.isReviving = true;
            } else {
                // Normal respawn
                window.isReviving = false;
            }
            
            // Hide overlay and trigger respawn
            document.getElementById('respawnOverlay').style.display = 'none';
            playerRespawnTimer = 100; // Trigger respawn
        }
        
        // Return to main menu
        window.returnToMainMenu = function() {
            playUISound();
            
            // Reset game state
            location.reload(); // Simple reload to return to main menu
        }
        
        // Country code to flag emoji mapping
        const countryFlags = {
            'US': '🇺🇸', 'CA': '🇨🇦', 'GB': '🇬🇧', 'DE': '🇩🇪', 'FR': '🇫🇷',
            'JP': '🇯🇵', 'AU': '🇦🇺', 'BR': '🇧🇷', 'IN': '🇮🇳', 'CN': '🇨🇳',
            'RU': '🇷🇺', 'MX': '🇲🇽', 'IT': '🇮🇹', 'ES': '🇪🇸', 'KR': '🇰🇷',
            'NL': '🇳🇱', 'SE': '🇸🇪', 'NO': '🇳🇴', 'DK': '🇩🇰', 'FI': '🇫🇮',
            'PL': '🇵🇱', 'BE': '🇧🇪', 'AT': '🇦🇹', 'CH': '🇨🇭', 'IE': '🇮🇪',
            'PT': '🇵🇹', 'GR': '🇬🇷', 'CZ': '🇨🇿', 'HU': '🇭🇺', 'RO': '🇷🇴',
            'BG': '🇧🇬', 'HR': '🇭🇷', 'SK': '🇸🇰', 'SI': '🇸🇮', 'LT': '🇱🇹',
            'LV': '🇱🇻', 'EE': '🇪🇪', 'IS': '🇮🇸', 'TR': '🇹🇷', 'IL': '🇮🇱',
            'SA': '🇸🇦', 'AE': '🇦🇪', 'EG': '🇪🇬', 'ZA': '🇿🇦', 'NG': '🇳🇬',
            'KE': '🇰🇪', 'MA': '🇲🇦', 'TN': '🇹🇳', 'DZ': '🇩🇿', 'GH': '🇬🇭',
            'AR': '🇦🇷', 'CL': '🇨🇱', 'CO': '🇨🇴', 'PE': '🇵🇪', 'VE': '🇻🇪',
            'UY': '🇺🇾', 'PY': '🇵🇾', 'BO': '🇧🇴', 'EC': '🇪🇨', 'CR': '🇨🇷',
            'PA': '🇵🇦', 'GT': '🇬🇹', 'HN': '🇭🇳', 'SV': '🇸🇻', 'NI': '🇳🇮',
            'XX': '🌍', 'TH': '🇹🇭', 'VN': '🇻🇳', 'MY': '🇲🇾', 'SG': '🇸🇬', 
            'ID': '🇮🇩', 'PH': '🇵🇭', 'NZ': '🇳🇿', 'ZM': '🇿🇲', 'ZW': '🇿🇼'
        };
        
        function getCountryDisplay(countryCode) {
            const flag = countryFlags[countryCode] || '🌍';
            return `<span style="font-size: 18px; display: inline-block;">${flag}</span> <span style="font-size: 11px; color: #888;">${countryCode || 'XX'}</span>`;
        }
        
        // Leaderboard UI Functions
        let currentLeaderboardPeriod = 'daily';
        let leaderboardData = [];
        
        window.showLeaderboard = async function() {
            document.getElementById('leaderboardModal').style.display = 'block';
            await loadLeaderboard(currentLeaderboardPeriod);
        }
        
        window.closeLeaderboard = function() {
            document.getElementById('leaderboardModal').style.display = 'none';
        }
        
        window.switchLeaderboardPeriod = async function(period) {
            currentLeaderboardPeriod = period;
            
            // Update tab styles
            document.querySelectorAll('.leaderboard-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.style.color = '#888';
            });
            event.target.classList.add('active');
            event.target.style.color = '#4ecdc4';
            
            await loadLeaderboard(period);
        }
        
        // Load mini leaderboard for pause menu
        let currentPauseLBPeriod = 'daily';
        
        window.loadPauseLeaderboard = async function(period) {
            currentPauseLBPeriod = period;
            
            // Update mini tab styles
            document.querySelectorAll('.mini-lb-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.style.color = '#888';
            });
            event.target.classList.add('active');
            event.target.style.color = '#4ecdc4';
            
            if (!supabaseModule) return;
            
            const entriesDiv = document.getElementById('pauseLeaderboardEntries');
            entriesDiv.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Loading...</div>';
            
            try {
                const data = await supabaseModule.getLeaderboard(period, 10); // Top 10 only
                
                if (!data || data.length === 0) {
                    entriesDiv.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No scores yet. Be the first!</div>';
                    return;
                }
                
                const currentUsername = localStorage.getItem('lastUsername');
                
                entriesDiv.innerHTML = data.map(entry => {
                    const isPlayer = currentUsername && entry.username === currentUsername;
                    const rankClass = entry.rank <= 3 ? `rank-${entry.rank}` : '';
                    
                    return `
                        <div style="display: flex; justify-content: space-between; padding: 10px; 
                                    background: ${isPlayer ? 'rgba(78, 205, 196, 0.2)' : 'rgba(0, 0, 0, 0.2)'}; 
                                    margin-bottom: 5px; border: 2px solid ${isPlayer ? '#4ecdc4' : 'transparent'}; font-size: 14px;">
                            <span class="${rankClass}" style="font-weight: bold; font-size: 14px;">#${entry.rank}</span>
                            <span style="color: ${isPlayer ? '#4ecdc4' : '#FFF'}; flex: 1; margin: 0 10px; overflow: hidden; text-overflow: ellipsis; font-size: 14px;">${entry.username}</span>
                            <span style="color: #4ecdc4; font-size: 14px;">${entry.score.toLocaleString()}</span>
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                console.error('Failed to load pause leaderboard:', error);
                entriesDiv.innerHTML = '<div style="color: #ff4444; text-align: center; padding: 20px;">Failed to load</div>';
            }
        }
        
        async function loadLeaderboard(period) {
            if (!supabaseModule) return;
            
            const entriesDiv = document.getElementById('leaderboardEntries');
            entriesDiv.innerHTML = '<div style="color: #888; text-align: center; padding: 40px; font-family: monospace;">Loading leaderboard...</div>';
            
            try {
                leaderboardData = await supabaseModule.getLeaderboard(period, 100);
                
                if (!leaderboardData || leaderboardData.length === 0) {
                    entriesDiv.innerHTML = '<div style="color: #888; text-align: center; padding: 40px; font-family: monospace;">No scores yet. Be the first!</div>';
                    return;
                }
                
                // Get current player's username to highlight their entries
                const currentUsername = localStorage.getItem('lastUsername');
                
                entriesDiv.innerHTML = leaderboardData.map(entry => {
                    const isPlayer = currentUsername && entry.username === currentUsername;
                    const rankClass = entry.rank <= 3 ? `rank-${entry.rank}` : '';
                    
                    // Format time from seconds to MM:SS
                    const minutes = Math.floor(entry.play_time / 60);
                    const seconds = entry.play_time % 60;
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    // Get country display
                    const countryDisplay = getCountryDisplay(entry.country_code || 'XX');
                    
                    return `
                        <div class="leaderboard-entry ${isPlayer ? 'player-entry' : ''}">
                            <div class="${rankClass}" style="font-weight: bold;">#${entry.rank}</div>
                            <div>${countryDisplay}</div>
                            <div style="color: ${isPlayer ? '#4ecdc4' : '#FFF'}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${entry.username}</div>
                            <div style="color: #4ecdc4; text-align: right;">${entry.score.toLocaleString()}</div>
                            <div style="color: #FFD700; text-align: right;">${entry.elements_discovered || 0}</div>
                            <div style="color: #AAA; text-align: right;">${timeStr}</div>
                            <div style="color: #ff6b6b; text-align: right;">${entry.kills || 0}</div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Failed to load leaderboard:', error);
                entriesDiv.innerHTML = '<div style="color: #ff4444; text-align: center; padding: 40px; font-family: monospace;">Failed to load leaderboard. Please try again.</div>';
            }
        }
        
        function updateUI() {
            if (!playerSnake) return;
            
            // Handle dead player with respawn timer
            if (!playerSnake.alive && playerRespawnTimer > 0) {
                const respawnSeconds = Math.ceil(playerRespawnTimer / 1000);
                
                // Show respawn overlay
                const respawnOverlay = document.getElementById('respawnOverlay');
                if (respawnOverlay) {
                    respawnOverlay.style.display = 'block';
                    
                    // Update respawn stats
                    document.getElementById('respawnScore').textContent = Math.floor(playerSnake.score).toLocaleString();
                    // Use player discovery count
                    document.getElementById('respawnDiscoveries').textContent = playerDiscoveredElements.size;
                    document.getElementById('respawnKills').textContent = playerSnake.kills;
                    
                    // Load and display all-time best stats
                    const bestScore = parseInt(localStorage.getItem('bestScore') || '0');
                    const bestDiscoveries = parseInt(localStorage.getItem('bestDiscoveries') || '0');
                    const bestKills = parseInt(localStorage.getItem('bestKills') || '0');
                    
                    document.getElementById('bestScore').textContent = bestScore.toLocaleString();
                    document.getElementById('bestDiscoveries').textContent = bestDiscoveries;
                    document.getElementById('bestKills').textContent = bestKills;
                    
                    // Update best stats if current game is better
                    if (Math.floor(playerSnake.score) > bestScore) {
                        localStorage.setItem('bestScore', Math.floor(playerSnake.score));
                    }
                    if (playerDiscoveredElements.size > bestDiscoveries) {
                        localStorage.setItem('bestDiscoveries', playerDiscoveredElements.size);
                    }
                    if (playerSnake.kills > bestKills) {
                        localStorage.setItem('bestKills', playerSnake.kills);
                    }
                    
                    // Update revive button state
                    const reviveBtn = document.getElementById('reviveBtn');
                    const respawnPenaltyText = document.getElementById('respawnPenaltyText');
                    if (reviveBtn) {
                        if (revivesRemaining > 0) {
                            reviveBtn.innerHTML = `REVIVE (<span id="revivesLeft">${revivesRemaining}</span>)`;
                            reviveBtn.style.background = '#4ecdc4';
                            reviveBtn.style.borderColor = '#4ecdc4';
                            reviveBtn.style.boxShadow = '0 0 20px rgba(78, 205, 196, 0.5)';
                            document.getElementById('actionText').textContent = 'revive';
                            if (respawnPenaltyText) respawnPenaltyText.style.display = 'none';
                        } else {
                            reviveBtn.innerHTML = 'RESPAWN';
                            reviveBtn.style.background = '#9c88ff';
                            reviveBtn.style.borderColor = '#9c88ff';
                            reviveBtn.style.boxShadow = '0 0 20px rgba(156, 136, 255, 0.5)';
                            document.getElementById('actionText').textContent = 'respawn';
                            if (respawnPenaltyText) respawnPenaltyText.style.display = 'block';
                        }
                    }
                    
                    // Automatic leaderboard submission for infinite mode
                    console.log('[LEADERBOARD] Checking submission conditions:', {
                        gameMode: gameMode,
                        isInfinite: gameMode === 'infinite',
                        leaderboardSubmitted: leaderboardSubmitted,
                        playerScore: playerSnake.score,
                        hasScore: playerSnake.score > 0,
                        gameSessionStartTime: gameSessionStartTime,
                        currentTime: Date.now()
                    });
                    
                    if (gameMode === 'infinite' && !leaderboardSubmitted && playerSnake.score > 0) {
                        const playTime = gameSessionStartTime ? 
                            Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0;
                        
                        console.log('[LEADERBOARD] Play time:', playTime, 'seconds');
                        
                        // Only submit if played for at least 5 seconds (reduced from 10)
                        if (playTime >= 5) {
                            // Get player name
                            const playerName = localStorage.getItem('playerName') || window.nameGenerator.generateRandomName();
                            
                            console.log('[LEADERBOARD] Submitting score automatically:', {
                                name: playerName,
                                score: Math.floor(playerSnake.score),
                                discoveries: playerDiscoveredElements.size,
                                kills: playerSnake.kills,
                                playTime: playTime
                            });
                            
                            // Submit score automatically
                            if (window.supabaseModule && window.supabaseModule.submitScore) {
                                console.log('[LEADERBOARD] Supabase module found, submitting...');
                                window.supabaseModule.submitScore(
                                    playerName,
                                    Math.floor(playerSnake.score),
                                    playerDiscoveredElements.size,
                                    playerSnake.kills
                                ).then(result => {
                                    console.log('[LEADERBOARD] Submission result:', result);
                                    if (result && result.success && result.rank) {
                                        // Update global rank display
                                        const globalRankEl = document.getElementById('globalRank');
                                        if (globalRankEl) {
                                            globalRankEl.textContent = `#${result.rank}`;
                                        }
                                        console.log('[LEADERBOARD] Score submitted successfully! Rank:', result.rank);
                                        // Only mark as submitted on success
                                        leaderboardSubmitted = true;
                                    } else {
                                        console.error('[LEADERBOARD] Submission returned but was not successful:', result);
                                    }
                                }).catch(error => {
                                    console.error('[LEADERBOARD] Failed to submit score:', error);
                                    // Don't mark as submitted on failure so it can retry
                                });
                            } else {
                                console.error('[LEADERBOARD] Supabase module not available!', {
                                    module: window.supabaseModule,
                                    submitScore: window.supabaseModule?.submitScore
                                });
                            }
                        }
                    }
                }
                
                return; // Don't update other UI elements while dead
            } else {
                // Hide respawn overlay when alive
                const respawnOverlay = document.getElementById('respawnOverlay');
                if (respawnOverlay) {
                    respawnOverlay.style.display = 'none';
                }
                // Also hide quick respawn div
                const quickRespawnDiv = document.getElementById('quickRespawnDiv');
                if (quickRespawnDiv) {
                    quickRespawnDiv.style.display = 'none';
                }
            }
            
            // Update player info box
            document.getElementById('playerScore').textContent = Math.floor(playerSnake.score).toLocaleString();
            
            // Update discoveries count - use player discoveries only
            const discoveryCount = playerDiscoveredElements.size;
            const discoveriesElement = document.getElementById('playerDiscoveries');
            if (discoveriesElement) {
                discoveriesElement.textContent = discoveryCount.toString();
            }
            
            // Update high score display if current score is higher
            if (playerSnake.score > highScore) {
                highScore = playerSnake.score;
                localStorage.setItem('highScore', Math.floor(highScore).toString());
            }
            
            // Dispatch periodic score update event (every 5 seconds)
            if (!window.lastScoreUpdateTime) window.lastScoreUpdateTime = 0;
            if (Date.now() - window.lastScoreUpdateTime > 5000) {
                window.lastScoreUpdateTime = Date.now();
                dispatchGameEvent('scoreUpdate', {
                    score: Math.floor(playerSnake.score),
                    highScore: Math.floor(highScore),
                    discoveries: discoveryCount,
                    kills: playerSnake.kills
                });
            }
            
            // Update game time
            const gameTime = Date.now() - gameStartTime;
            const minutes = Math.floor(gameTime / 60000);
            const seconds = Math.floor((gameTime % 60000) / 1000);
            document.getElementById('playerTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update best rank (only after 60 seconds to make it meaningful)
            const bestRankElement = document.getElementById('playerBestRank');
            if (gameTime >= 60000) { // 60 seconds
                const playerRank = snakes.filter(s => s.alive).findIndex(s => s === playerSnake) + 1;
                if (playerRank > 0 && (bestRank === 0 || playerRank < bestRank)) {
                    bestRank = playerRank;
                    bestRankElement.textContent = `#${bestRank}`;
                }
                
                // Dispatch first place achievement if applicable (only once per game)
                if (playerRank === 1 && snakes.filter(s => s.alive).length > 1) {
                    if (!window.firstPlaceAchievedThisGame) {
                        window.firstPlaceAchievedThisGame = true;
                        dispatchGameEvent('firstPlace', {
                            alivePlayers: snakes.filter(s => s.alive).length,
                            score: playerSnake.score
                        });
                    }
                }
            } else {
                // Show placeholder before 60 seconds
                bestRankElement.textContent = '-';
            }
            
            // Update kills
            document.getElementById('playerKills').textContent = playerSnake.kills;
            
            // Update AlchemyVision timer
            const timerElement = document.getElementById('alchemyVisionTimer');
            if (alchemyVisionActive && alchemyVisionTimer > 0) {
                timerElement.style.display = 'block';
                const seconds = Math.ceil(alchemyVisionTimer / 1000);
                document.getElementById('alchemyTime').textContent = seconds;
            } else {
                timerElement.style.display = 'none';
            }
            
            // Update boost bar
            updateBoostBar();
            
            // Check victory condition (only once)
            if (!gameWon) {
                if (gameMode === 'discovery' && discoveryCount >= gameTarget) {
                    gameWon = true;
                    showVictoryScreen('discovery', gameTarget);
                } else if (gameMode === 'points' && playerSnake.score >= gameTarget) {
                    gameWon = true;
                    showVictoryScreen('points', gameTarget);
                }
            }
            
            // Update leaderboard
            updateLeaderboard();
            
            // Update element collection bar (MMO skill bar style)
            const elementBar = document.getElementById('elementBar');
            elementBar.innerHTML = '';
            
            // Check if we're animating a combination
            const isCombining = playerSnake.isAnimatingCombination && playerSnake.combiningIndices;
            
            // Create slots based on the current elementBankSlots (starts at 6, can expand to 12)
            // Safety check: ensure we never try to render more than max elements
            const elementsToRender = Math.min(playerSnake.elements.length, elementBankSlots);
            
            // Debug logging for element bank issues
            if (playerSnake.elements.length < elementBankSlots && window.debugElementBank) {
            }
            
            for (let i = 0; i < elementBankSlots; i++) {
                const div = document.createElement('div');
                div.className = 'element-slot';
                
                if (i < elementsToRender) {
                    // Filled slot with element
                    const elementId = playerSnake.elements[i];
                    const element = window.elementLoader.elements.get(elementId);
                    if (element) {
                        div.classList.add('filled');
                        div.dataset.elementId = elementId; // Store element ID for boss damage checking
                        
                        // Highlight the active element
                        if (i === playerSnake.highlightedIndex) {
                            div.classList.add('highlighted-element');
                        }
                        
                        // Add glow/wobble effect for pending combinations (eaten element)
                        if (playerSnake.pendingCombinationIndex === i && 
                            Date.now() - playerSnake.pendingCombinationTime < 300) {
                            div.classList.add('glow-wobble');
                        }
                        
                        // Add glow/wobble effect for bank-to-bank combinations
                        if (playerSnake.glowWobbleIndices && playerSnake.glowWobbleIndices.includes(i) &&
                            Date.now() - playerSnake.glowWobbleTime < 600) {
                            div.classList.add('glow-wobble');
                        }
                        
                        // Add combination animation classes
                        if (isCombining) {
                            if (playerSnake.combiningIndices.includes(i)) {
                                div.classList.add('combining');
                                
                                // Add particle effects
                                const particleContainer = document.createElement('div');
                                particleContainer.className = 'combination-particles';
                                
                                // Create multiple particles
                                for (let p = 0; p < 8; p++) {
                                    const particle = document.createElement('div');
                                    particle.className = 'combination-particle';
                                    const angle = (p / 8) * Math.PI * 2;
                                    const distance = 30;
                                    particle.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                                    particle.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                                    particle.style.animationDelay = `${p * 0.05}s`;
                                    particleContainer.appendChild(particle);
                                }
                                
                                div.appendChild(particleContainer);
                            }
                        }
                        
                        // Check if this is a newly created element
                        if (combinationAnimationState.isAnimating && i === combinationAnimationState.newElementIndex) {
                            div.classList.add('new-element');
                        }
                        
                        const emoji = window.elementLoader.getEmojiForElement(elementId, element.e);
                        div.innerHTML += `<div class="emoji">${emoji}</div><div class="element-name">${element.n}</div>`;
                        div.title = element.n;
                    }
                } else {
                    // Empty slot
                    div.classList.add('empty');
                    // Clear any stale element ID to prevent phantom elements
                    delete div.dataset.elementId;
                }
                
                elementBar.appendChild(div);
            }
            
            // Reset animation state after animation completes
            if (combinationAnimationState.isAnimating && Date.now() - combinationAnimationState.animationStartTime > 600) {
                combinationAnimationState.isAnimating = false;
                combinationAnimationState.combiningIndices = [];
                combinationAnimationState.newElementIndex = -1;
                playerSnake.isAnimatingCombination = false;
                playerSnake.combiningIndices = null;
                playerSnake.glowWobbleIndices = null;
                playerSnake.pendingCombinationIndex = -1;
            }
        }
        
        function checkCollisions() {
            // Track snakes that have already died this frame to prevent multiple collisions
            const diedThisFrame = new Set();
            
            // Performance optimization: Use for loop instead of for-of
            for (let snakeIdx = 0; snakeIdx < snakes.length; snakeIdx++) {
                const snake = snakes[snakeIdx];
                if (!snake || !snake.alive || diedThisFrame.has(snake)) continue;
                
                // Check element collisions
                const activeElements = elementPool.getActiveElements();
                const activeElementsLength = activeElements.length;
                
                // Performance optimization: Cache frequently used values
                const snakeX = snake.x;
                const snakeY = snake.y;
                const collisionDistSq = (SEGMENT_SIZE + ELEMENT_SIZE) * (SEGMENT_SIZE + ELEMENT_SIZE);
                
                for (let elemIdx = 0; elemIdx < activeElementsLength; elemIdx++) {
                    const element = activeElements[elemIdx];
                    if (!element) continue; // Skip if element is undefined
                    
                    // Performance optimization: Use squared distance for initial check
                    const dx = element.x - snakeX;
                    const dy = element.y - snakeY;
                    const distSq = dx * dx + dy * dy;
                    
                    // For player snake, check if element will combine when eaten
                    if (snake.isPlayer) {
                        if (distSq < 22500 && snake.elements.length > 0) { // 150 * 150
                            // Check if this element can combine with any in the bank
                            element.pendingCombination = false;
                            const snakeElementsLength = snake.elements.length;
                            for (let i = 0; i < snakeElementsLength; i++) {
                                const bankElementId = snake.elements[i];
                                const comboKey = `${Math.min(element.id, bankElementId)}+${Math.max(element.id, bankElementId)}`;
                                if (window.elementLoader && window.elementLoader.combinations[comboKey]) {
                                    element.pendingCombination = true;
                                    element.combiningAnimation = 0.5; // Start animation immediately
                                    break;
                                }
                            }
                        } else if (distSq > 40000) { // 200 * 200
                            // Reset state for distant elements
                            element.pendingCombination = false;
                            element.combiningAnimation = 0;
                        }
                    }
                    
                    if (distSq < collisionDistSq) {
                        snake.consume(element);
                    }
                }
                
                // Check AlchemyVision power-up collision (player only)
                if (snake.isPlayer) {
                    for (let i = alchemyVisionPowerUps.length - 1; i >= 0; i--) {
                        const powerUp = alchemyVisionPowerUps[i];
                        // Performance optimization: Use squared distance
                        const dx = powerUp.x - snakeX;
                        const dy = powerUp.y - snakeY;
                        const collisionDist = SEGMENT_SIZE + powerUp.size;
                        if (dx * dx + dy * dy < collisionDist * collisionDist) {
                            // Activate Alchemy Vision
                            alchemyVisionActive = true;
                            alchemyVisionTimer = ALCHEMY_VISION_DURATION;
                            
                            // Remove collected power-up
                            alchemyVisionPowerUps.splice(i, 1);
                            
                            // Dispatch power-up collected event
                            dispatchGameEvent('powerupCollected', {
                                type: 'alchemyVision',
                                duration: 30000
                            });
                            
                            // Play alchemy vision sound (always player since only player can collect)
                            playAlchemyVisionSound(true);
                            
                            // Show notification
                            showMessage('🔮 Alchemy Vision Activated! 30s<br><small style="opacity: 0.8">Your eyes are opened to see all combinations</small>', 'success');
                            break; // Only collect one at a time
                        }
                    }
                }
                
                // Check Void Orb collision (all snakes can collect)
                for (let i = voidOrbs.length - 1; i >= 0; i--) {
                    const orb = voidOrbs[i];
                    // Performance optimization: Use squared distance
                    const dx = orb.x - snakeX;
                    const dy = orb.y - snakeY;
                    const collisionDist = SEGMENT_SIZE + orb.size;
                    if (dx * dx + dy * dy < collisionDist * collisionDist) {
                        // Consume the void orb
                        if (snake.elements.length > 0) {
                            const elementCount = snake.elements.length;
                            const points = elementCount * 100;
                            snake.score += points;
                            snake.elements = []; // Clear all elements
                            
                            // Visual feedback
                            if (snake.isPlayer) {
                                // Dispatch void orb collected event
                                dispatchGameEvent('powerupCollected', {
                                    type: 'voidOrb',
                                    elementsPurged: elementCount,
                                    pointsGained: points
                                });
                                
                                showMessage(`🌀 Void Orb consumed! +${points} points<br><small style="opacity: 0.8">Your elements have been purged to the void</small>`, 'info');
                            }
                            
                            // Play sound at appropriate volume
                            playVoidOrbSound(snake.isPlayer);
                            
                            // Create particle effect
                            for (let j = 0; j < 15; j++) {
                                const angle = (j / 15) * Math.PI * 2;
                                const speed = 2 + Math.random() * 3;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(orb.x, orb.y, vx, vy, 'rgba(100, 200, 255, 0.8)');
                            }
                            
                            // 50% chance to spawn a discovery element
                            if (Math.random() < 0.5) {
                                console.log('[VOID ORB] Attempting to spawn element...');
                                
                                // Get all available elements
                                let availableElements = [];
                                if (window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                                    // Get all elements and extract their keys
                                    const allElements = window.elementLoader.getAllElements();
                                    availableElements = allElements.map(elem => elem.key);
                                    console.log('[VOID ORB] Using element loader, found', availableElements.length, 'total elements');
                                } else {
                                    availableElements = Object.keys(elementDatabase);
                                    console.log('[VOID ORB] Using legacy database, found', availableElements.length, 'total elements');
                                }
                                
                                // Filter to only discovered elements (except base elements which are always available)
                                const spawnableElements = availableElements.filter(elemKey => {
                                    // Always allow base elements (first 4)
                                    const elemIndex = availableElements.indexOf(elemKey);
                                    if (elemIndex < 4) return true;
                                    
                                    // For other elements, only spawn if discovered
                                    return discoveredElements.has(elemKey);
                                });
                                
                                // Prioritize elements that can lead to new discoveries
                                const discoveryPotentialElements = spawnableElements.filter(elemKey => {
                                    // Check if this element can combine with carried elements for new discoveries
                                    let hasDiscoveryPotential = false;
                                    snake.elements.forEach(carried => {
                                        const result = window.elementLoader ? 
                                            window.elementLoader.getCombinationByKeys(elemKey, carried) :
                                            (combinations[`${elemKey}+${carried}`] || combinations[`${carried}+${elemKey}`]);
                                        if (result && !discoveredElements.has(result.key || result)) {
                                            hasDiscoveryPotential = true;
                                        }
                                    });
                                    return hasDiscoveryPotential;
                                });
                                
                                // Use discovery potential elements if available, otherwise use any spawnable element
                                const finalPool = discoveryPotentialElements.length > 0 ? discoveryPotentialElements : spawnableElements;
                                
                                console.log('[VOID ORB] Spawnable elements:', spawnableElements.length, 'Discovery potential:', discoveryPotentialElements.length, 'Final pool:', finalPool.length);
                                
                                if (finalPool.length > 0) {
                                    // Pick a random element
                                    const randomElement = finalPool[Math.floor(Math.random() * finalPool.length)];
                                    console.log('[VOID ORB] Selected element to spawn:', randomElement);
                                    
                                    // Spawn it at a random location near the void orb
                                    const spawnAngle = Math.random() * Math.PI * 2;
                                    const spawnDistance = 50 + Math.random() * 100;
                                    const spawnX = orb.x + Math.cos(spawnAngle) * spawnDistance;
                                    const spawnY = orb.y + Math.sin(spawnAngle) * spawnDistance;
                                    
                                    // Spawn the element with glow effect (using isCatalystSpawned for glow)
                                    elementPool.spawn(randomElement, spawnX, spawnY, true);
                                    
                                    // Show message if player collected the orb
                                    if (snake.isPlayer) {
                                        const elementData = window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded() 
                                            ? window.elementLoader.elements.get(randomElement)
                                            : elementDatabase[randomElement];
                                        if (elementData) {
                                            const emoji = window.elementLoader.getEmojiForElement(randomElement, elementData.e);
                                            const name = elementData.n;
                                            showMessage(`✨ The void reveals: ${emoji} ${name}!`, 'discovery');
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Remove void orb
                        voidOrbs.splice(i, 1);
                        break;
                    }
                }
                
                // Check Catalyst Gem collision (all snakes can collect)
                for (let i = catalystGems.length - 1; i >= 0; i--) {
                    const gem = catalystGems[i];
                    // Performance optimization: Use squared distance
                    const dx = gem.x - snake.x;
                    const dy = gem.y - snake.y;
                    const collisionDist = SEGMENT_SIZE + gem.size;
                    const collisionDistSq = collisionDist * collisionDist;
                    if (dx * dx + dy * dy < collisionDistSq) {
                        // Only activate if catalyst gem logic is ready
                        if (snake.isPlayer && window.elementLoader && window.elementLoader.isLoaded && window.elementLoader.isLoaded()) {
                            // NEW CATALYST LOGIC: Spawn 3 random elements NOT in the current spawn pool
                            // These are elements the player hasn't discovered yet
                            const allElements = window.elementLoader.elements;
                            const undiscoveredElements = [];
                            
                            // Find all elements that are NOT in the spawn pool (not discovered by player)
                            for (const [elemId, element] of allElements) {
                                const elemIdNum = typeof elemId === 'string' ? parseInt(elemId) : elemId;
                                const isBaseElement = elemIdNum >= 0 && elemIdNum <= 3;
                                
                                // Skip base elements and already discovered elements
                                if (!isBaseElement && !playerDiscoveredElements.has(elemIdNum)) {
                                    undiscoveredElements.push(elemIdNum);
                                }
                            }
                            
                            if (undiscoveredElements.length >= 3) {
                                // Randomly select 3 undiscovered elements
                                const shuffled = [...undiscoveredElements].sort(() => Math.random() - 0.5);
                                const elementsToSpawn = shuffled.slice(0, 3);
                                
                                // Spawn the three elements around the player in a triangle pattern
                                for (let j = 0; j < elementsToSpawn.length; j++) {
                                    const angle = (j / 3) * Math.PI * 2;
                                    const distance = 100 + Math.random() * 100;
                                    const spawnX = snake.x + Math.cos(angle) * distance;
                                    const spawnY = snake.y + Math.sin(angle) * distance;
                                    
                                    // Create the element with catalyst sparkle effect
                                    elementPool.spawn(elementsToSpawn[j], spawnX, spawnY, true);
                                }
                                
                                showMessage(`💎 Catalyst Gem: 3 Rare Elements Materialized!`, 'gold');
                            } else if (undiscoveredElements.length > 0) {
                                // Spawn whatever undiscovered elements are left
                                const elementsToSpawn = undiscoveredElements;
                                
                                // Spawn the elements
                                for (let j = 0; j < elementsToSpawn.length; j++) {
                                    const angle = (j / elementsToSpawn.length) * Math.PI * 2;
                                    const distance = 100 + Math.random() * 100;
                                    const spawnX = snake.x + Math.cos(angle) * distance;
                                    const spawnY = snake.y + Math.sin(angle) * distance;
                                    
                                    elementPool.spawn(elementsToSpawn[j], spawnX, spawnY, true);
                                }
                                
                                showMessage(`💎 Catalyst Gem: ${elementsToSpawn.length} Rare Elements Materialized!`, 'gold');
                            } else {
                                // Fallback: All elements discovered, spawn random elements
                                const allElementsList = Array.from(allElements.keys());
                                const shuffled = [...allElementsList].sort(() => Math.random() - 0.5);
                                const elementsToSpawn = shuffled.slice(0, 3);
                                
                                // Spawn the elements
                                for (let j = 0; j < elementsToSpawn.length; j++) {
                                    const angle = (j / elementsToSpawn.length) * Math.PI * 2;
                                    const distance = 100 + Math.random() * 100;
                                    const spawnX = snake.x + Math.cos(angle) * distance;
                                    const spawnY = snake.y + Math.sin(angle) * distance;
                                    
                                    elementPool.spawn(elementsToSpawn[j], spawnX, spawnY, true);
                                }
                                
                                showMessage(`💎 Catalyst Gem: 3 Elements Materialized!`, 'gold');
                            }
                            
                            // Play catalyst gem sound at appropriate volume
                            playCatalystGemSound(true);
                            
                            // Dispatch catalyst gem collected event
                            dispatchGameEvent('powerupCollected', {
                                type: 'catalyst',
                                elementsSpawned: 3
                            });
                            
                            // Create particle effect
                            for (let j = 0; j < 20; j++) {
                                const angle = (j / 20) * Math.PI * 2;
                                const speed = 3 + Math.random() * 4;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(gem.x, gem.y, vx, vy, 'rgba(255, 165, 0, 0.8)');
                            }
                        } else if (!snake.isPlayer) {
                            // AI snakes get points instead
                            snake.score += 200;
                            
                            // Play catalyst gem sound at appropriate volume
                            playCatalystGemSound(false);
                            
                            // Create particle effect
                            for (let j = 0; j < 20; j++) {
                                const angle = (j / 20) * Math.PI * 2;
                                const speed = 3 + Math.random() * 4;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(gem.x, gem.y, vx, vy, 'rgba(255, 165, 0, 0.8)');
                            }
                        }
                        
                        // Remove catalyst gem
                        catalystGems.splice(i, 1);
                        break;
                    }
                }
                
                // Check snake collisions (skip if invincible)
                if (snake.invincibilityTimer > 0) continue;
                
                for (const otherSnake of snakes) {
                    if (snake === otherSnake || !otherSnake.alive || !snake.alive || diedThisFrame.has(otherSnake)) continue;
                    
                    // Skip collision if boss is stunned or invulnerable
                    if (otherSnake.isBoss && (otherSnake.stunTimer > 0 || otherSnake.invulnerabilityTimer > 0)) continue;
                    
                    // Skip collision check if snakes are too far apart (optimization for mobile)
                    const maxCollisionDistance = 500; // Maximum distance for collision checks
                    const dx = otherSnake.x - snake.x;
                    const dy = otherSnake.y - snake.y;
                    if (dx * dx + dy * dy > maxCollisionDistance * maxCollisionDistance) continue;
                    
                    // Check head collision with other snake's body
                    let collisionOccurred = false;
                    
                    // Calculate proper collision radius based on both snakes' sizes
                    const snakeSize = snake.size || 1;
                    const otherSnakeSize = otherSnake.size || 1;
                    const collisionRadius = SEGMENT_SIZE * (snakeSize + otherSnakeSize) / 2;
                    const collisionRadiusSq = collisionRadius * collisionRadius;
                    
                    // For body segments, check collision with all segments (including head and tail for bosses)
                    const startIndex = otherSnake.isBoss ? 0 : 3; // Boss collision includes all segments
                    for (let i = startIndex; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        // Performance optimization: Use squared distance
                        const dx = segment.x - snake.x;
                        const dy = segment.y - snake.y;
                        if (dx * dx + dy * dy < collisionRadiusSq) {
                            // Track collision for near-miss prevention
                            if (snake.isPlayer) {
                                snake.recentCollisions.add(otherSnake);
                            }
                            if (otherSnake.isPlayer) {
                                otherSnake.recentCollisions.add(snake);
                            }
                            snake.explode(otherSnake);
                            diedThisFrame.add(snake);
                            collisionOccurred = true;
                            break;
                        }
                    }
                    
                    // Skip further collision checks if this snake died
                    if (collisionOccurred || !snake.alive) break;
                    
                    // Check head-to-head collision
                    if (snake.alive && otherSnake.alive) {
                        // Performance optimization: Use squared distance
                        const hdx = otherSnake.x - snake.x;
                        const hdy = otherSnake.y - snake.y;
                        if (hdx * hdx + hdy * hdy < collisionRadiusSq) {
                            // Smaller snake explodes, or both if same size
                            if (snake.length < otherSnake.length) {
                                snake.explode(otherSnake);
                                diedThisFrame.add(snake);
                            } else if (otherSnake.length < snake.length) {
                                otherSnake.explode(snake);
                                diedThisFrame.add(otherSnake);
                            } else {
                                // Same size - both explode, no points awarded
                                snake.die();
                                otherSnake.die();
                                diedThisFrame.add(snake);
                                diedThisFrame.add(otherSnake);
                            }
                            break;
                        }
                    }
                }
            }
            
            // Near-miss detection (only for player snake, runs separately from collision)
            if (playerSnake && playerSnake.alive) {
                const now = Date.now();
                
                // Clean up old collision records
                for (const snake of playerSnake.recentCollisions) {
                    if (!snake.alive) {
                        playerSnake.recentCollisions.delete(snake);
                    }
                }
                
                for (const otherSnake of snakes) {
                    if (otherSnake === playerSnake || !otherSnake.alive) continue;
                    
                    // Skip if we recently collided with this snake
                    if (playerSnake.recentCollisions.has(otherSnake)) continue;
                    
                    // Calculate closest distance to any part of the other snake
                    let closestDistance = Infinity;
                    
                    // Check body segments
                    let closestDistanceSq = Infinity;
                    for (let i = 0; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        // Performance optimization: Use squared distance
                        const dx = segment.x - playerSnake.x;
                        const dy = segment.y - playerSnake.y;
                        const distSq = dx * dx + dy * dy;
                        closestDistanceSq = Math.min(closestDistanceSq, distSq);
                    }
                    
                    // Check head separately
                    const hdx = otherSnake.x - playerSnake.x;
                    const hdy = otherSnake.y - playerSnake.y;
                    const headDistSq = hdx * hdx + hdy * hdy;
                    closestDistanceSq = Math.min(closestDistanceSq, headDistSq);
                    closestDistance = Math.sqrt(closestDistanceSq);
                    
                    // Get previous tracking data
                    const trackingData = playerSnake.nearMissTracking.get(otherSnake) || {
                        wasClose: false,
                        lastAwardTime: 0,
                        minDistance: Infinity
                    };
                    
                    // Update minimum distance seen
                    trackingData.minDistance = Math.min(trackingData.minDistance, closestDistance);
                    
                    // Calculate collision radius based on sizes
                    const playerSize = playerSnake.size || 1;
                    const otherSize = otherSnake.size || 1;
                    const collisionRadius = SEGMENT_SIZE * (playerSize + otherSize) / 2;
                    
                    // Define near-miss zone accounting for snake sizes
                    const isClose = closestDistance <= collisionRadius + 30; // Within collision radius + 30 pixels
                    const isSafe = closestDistance > collisionRadius + 10; // At least collision radius + 10 pixels away (no collision)
                    
                    // Detect near miss: was close, now moving away, and didn't collide
                    if (trackingData.wasClose && !isClose && isSafe && 
                        trackingData.minDistance > collisionRadius && // Never got closer than collision distance
                        trackingData.minDistance <= collisionRadius + 20 && // But got pretty close
                        now - trackingData.lastAwardTime > 3000) { // 3 second cooldown per snake
                        
                        // Award near miss points
                        playerSnake.score += 250;
                        showMessage('Phew, Near Miss! +250', 'info');
                        trackingData.lastAwardTime = now;
                        trackingData.minDistance = Infinity; // Reset for next near miss
                    }
                    
                    // Update tracking state
                    trackingData.wasClose = isClose;
                    if (!isClose) {
                        trackingData.minDistance = Infinity; // Reset when we move away
                    }
                    
                    playerSnake.nearMissTracking.set(otherSnake, trackingData);
                }
                
                // Clean up tracking for dead snakes
                for (const [snake, data] of playerSnake.nearMissTracking) {
                    if (!snake.alive) {
                        playerSnake.nearMissTracking.delete(snake);
                    }
                }
            }
        }
        
        function drawBorders() {
            // Save context state
            ctx.save();
            
            // Ensure borders are fully opaque
            ctx.globalAlpha = 1;
            
            // Draw world borders with subtle pixel grid
            const borderThickness = isMobile ? 120 : 60; // Much thicker on mobile
            const leftBorder = (-camera.x) * cameraZoom + canvas.width / 2;
            const rightBorder = (WORLD_SIZE - camera.x) * cameraZoom + canvas.width / 2;
            const topBorder = (-camera.y) * cameraZoom + canvas.height / 2;
            const bottomBorder = (WORLD_SIZE - camera.y) * cameraZoom + canvas.height / 2;
            
            // Pulsating effect for barriers
            const pulsePhase = Math.floor((animationTime * 2) % 4);
            const pixelSize = isMobile ? 16 : 8; // Larger pixels on mobile for visibility
            const warningLineThickness = isMobile ? 12 : 6; // Thicker warning lines on mobile
            
            // Left border barrier
            if (leftBorder > -borderThickness) {
                const borderWidth = Math.min(borderThickness, leftBorder);
                if (borderWidth > 0) {
                    if (isMobile) {
                        // Solid gradient for mobile with increased opacity
                        const gradient = ctx.createLinearGradient(0, 0, borderWidth, 0);
                        gradient.addColorStop(0, 'rgba(128, 64, 255, 0.9)');
                        gradient.addColorStop(0.7, 'rgba(128, 64, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(128, 64, 255, 0.1)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, borderWidth, canvas.height);
                        
                        // Solid warning line
                        ctx.fillStyle = '#8844FF';
                        ctx.fillRect(Math.max(2, leftBorder - warningLineThickness/2), 0, warningLineThickness, canvas.height);
                    } else {
                        // Draw subtle grid pattern for desktop
                        for (let y = 0; y < canvas.height; y += pixelSize * 2) {
                            for (let x = 0; x < borderWidth; x += pixelSize * 2) {
                                const fadeAlpha = 1 - (x / borderThickness);
                                const pulse = (pulsePhase === 0 || pulsePhase === 2) ? 0.8 : 0.4;
                                ctx.fillStyle = `rgba(64, 32, 128, ${fadeAlpha * pulse})`;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                        
                        // Warning line
                        ctx.fillStyle = '#6633CC';
                        const lineX = Math.max(10, leftBorder);
                        for (let y = 0; y < canvas.height; y += pixelSize * 4) {
                            ctx.fillRect(lineX - 2, y, 4, pixelSize * 2);
                        }
                    }
                }
            }
            
            // Right border barrier
            if (rightBorder < canvas.width + borderThickness) {
                const startX = Math.max(0, rightBorder - borderThickness);
                const borderWidth = canvas.width - startX;
                if (borderWidth > 0) {
                    if (isMobile) {
                        // Solid gradient for mobile
                        const gradient = ctx.createLinearGradient(startX, 0, canvas.width, 0);
                        gradient.addColorStop(0, 'rgba(128, 64, 255, 0.1)');
                        gradient.addColorStop(0.3, 'rgba(128, 64, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(128, 64, 255, 0.9)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(startX, 0, borderWidth, canvas.height);
                        
                        // Solid warning line
                        ctx.fillStyle = '#8844FF';
                        ctx.fillRect(Math.min(canvas.width - warningLineThickness - 2, rightBorder - warningLineThickness/2), 0, warningLineThickness, canvas.height);
                    } else {
                        // Draw subtle grid pattern for desktop
                        for (let y = 0; y < canvas.height; y += pixelSize * 2) {
                            for (let x = Math.max(rightBorder - borderThickness, rightBorder); x < canvas.width; x += pixelSize * 2) {
                                const fadeAlpha = 1 - ((canvas.width - x) / borderThickness);
                                const pulse = (pulsePhase === 0 || pulsePhase === 2) ? 0.8 : 0.4;
                                ctx.fillStyle = `rgba(64, 32, 128, ${fadeAlpha * pulse})`;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                        
                        // Warning line
                        ctx.fillStyle = '#6633CC';
                        for (let y = 0; y < canvas.height; y += pixelSize * 4) {
                            ctx.fillRect(rightBorder - 2, y, 4, pixelSize * 2);
                        }
                    }
                }
            }
            
            // Top border barrier
            if (topBorder > -borderThickness) {
                const borderHeight = Math.min(borderThickness, topBorder);
                if (borderHeight > 0) {
                    if (isMobile) {
                        // Solid gradient for mobile
                        const gradient = ctx.createLinearGradient(0, 0, 0, borderHeight);
                        gradient.addColorStop(0, 'rgba(128, 64, 255, 0.9)');
                        gradient.addColorStop(0.7, 'rgba(128, 64, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(128, 64, 255, 0.1)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, borderHeight);
                        
                        // Solid warning line
                        ctx.fillStyle = '#8844FF';
                        ctx.fillRect(0, Math.max(2, topBorder - warningLineThickness/2), canvas.width, warningLineThickness);
                    } else {
                        // Draw subtle grid pattern for desktop
                        for (let y = 0; y < borderHeight; y += pixelSize * 2) {
                            for (let x = 0; x < canvas.width; x += pixelSize * 2) {
                                const fadeAlpha = 1 - (y / borderThickness);
                                const pulse = (pulsePhase === 0 || pulsePhase === 2) ? 0.8 : 0.4;
                                ctx.fillStyle = `rgba(64, 32, 128, ${fadeAlpha * pulse})`;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                        
                        // Warning line
                        ctx.fillStyle = '#6633CC';
                        const lineY = Math.max(10, topBorder);
                        for (let x = 0; x < canvas.width; x += pixelSize * 4) {
                            ctx.fillRect(x, lineY - 2, pixelSize * 2, 4);
                        }
                    }
                }
            }
            
            // Bottom border barrier
            if (bottomBorder < canvas.height + borderThickness) {
                const startY = Math.max(0, bottomBorder - borderThickness);
                const borderHeight = canvas.height - startY;
                if (borderHeight > 0) {
                    if (isMobile) {
                        // Solid gradient for mobile
                        const gradient = ctx.createLinearGradient(0, startY, 0, canvas.height);
                        gradient.addColorStop(0, 'rgba(128, 64, 255, 0.1)');
                        gradient.addColorStop(0.3, 'rgba(128, 64, 255, 0.6)');
                        gradient.addColorStop(1, 'rgba(128, 64, 255, 0.9)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, startY, canvas.width, borderHeight);
                        
                        // Solid warning line
                        ctx.fillStyle = '#8844FF';
                        ctx.fillRect(0, Math.min(canvas.height - warningLineThickness - 2, bottomBorder - warningLineThickness/2), canvas.width, warningLineThickness);
                    } else {
                        // Draw subtle grid pattern for desktop
                        for (let y = Math.max(bottomBorder - borderThickness, bottomBorder); y < canvas.height; y += pixelSize * 2) {
                            for (let x = 0; x < canvas.width; x += pixelSize * 2) {
                                const fadeAlpha = 1 - ((canvas.height - y) / borderThickness);
                                const pulse = (pulsePhase === 0 || pulsePhase === 2) ? 0.8 : 0.4;
                                ctx.fillStyle = `rgba(64, 32, 128, ${fadeAlpha * pulse})`;
                                ctx.fillRect(x, y, pixelSize, pixelSize);
                            }
                        }
                        
                        // Warning line
                        ctx.fillStyle = '#6633CC';
                        for (let x = 0; x < canvas.width; x += pixelSize * 4) {
                            ctx.fillRect(x, bottomBorder - 2, pixelSize * 2, 4);
                        }
                    }
                }
            }
            
            // Restore context state
            ctx.restore();
        }
        
        function drawBackground() {
            // Deep space background
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ALWAYS draw borders first (for both mobile and desktop)
            drawBorders();
            
            // Use optimized mobile renderer if available
            if (isMobile) {
                if (window.renderMobileBackground) {
                    // Use new optimized mobile background
                    renderMobileBackground(ctx, camera);
                } else {
                    // Fallback: Just draw minimal stars for mobile
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < 20; i++) {
                        const x = (i * 137 + camera.x * 0.1) % canvas.width;
                        const y = (i * 241 + camera.y * 0.1) % canvas.height;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
                return; // Skip desktop background effects
            }
            
            // Initialize grid pattern cache if needed (desktop only)
            if (!window.gridPatternCanvas) {
                window.gridPatternCanvas = document.createElement('canvas');
                window.gridPatternCanvas.width = 128;
                window.gridPatternCanvas.height = 128;
                const gridCtx = window.gridPatternCanvas.getContext('2d');
                gridCtx.strokeStyle = '#001122';
                gridCtx.lineWidth = 1;
                const gridSize = 64;
                
                // Draw grid pattern
                for (let x = 0; x < 128; x += gridSize) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(x, 0);
                    gridCtx.lineTo(x, 128);
                    gridCtx.stroke();
                }
                
                for (let y = 0; y < 128; y += gridSize) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(128, y);
                    gridCtx.stroke();
                }
            }
            
            // Draw pixel star layers with parallax
            pixelStarLayers.forEach((layer, layerIndex) => {
                layer.stars.forEach(star => {
                    const x = (star.x - camera.x * layer.speed) % WORLD_SIZE;
                    const y = (star.y - camera.y * layer.speed) % WORLD_SIZE;
                    
                    const screen = worldToScreen(x, y);
                    const screenX = screen.x;
                    const screenY = screen.y;
                    
                    // Skip if off-screen
                    if (screenX < -10 || screenX > canvas.width + 10 ||
                        screenY < -10 || screenY > canvas.height + 10) return;
                    
                    // Twinkle effect
                    star.twinkle += 0.03; // Slower, more subtle twinkling
                    const brightness = 0.5 + Math.sin(star.twinkle) * 0.5;
                    
                    ctx.fillStyle = layer.color;
                    ctx.globalAlpha = brightness;
                    ctx.fillRect(
                        Math.floor(screenX / 2) * 2,
                        Math.floor(screenY / 2) * 2,
                        layer.size * 2,
                        layer.size * 2
                    );
                });
            });
            ctx.globalAlpha = 1;
            
            // Draw pixel nebulae BEFORE grid
            drawPixelNebulae();
            
            // Draw pixel planets BEFORE grid
            drawPixelPlanets();
            
            // Draw pixel asteroids
            drawPixelAsteroids();
            
            // Draw pixel grid using cached pattern - optimized
            const gridSize = 64;
            const offsetX = (camera.x * 0.05) % gridSize;
            const offsetY = (camera.y * 0.05) % gridSize;
            
            // Use the cached grid pattern
            ctx.save();
            ctx.translate(-offsetX, -offsetY);
            
            // Draw the cached grid canvas tiled across the screen
            const tilesX = Math.ceil((canvas.width + gridSize) / 128);
            const tilesY = Math.ceil((canvas.height + gridSize) / 128);
            
            for (let tx = 0; tx < tilesX; tx++) {
                for (let ty = 0; ty < tilesY; ty++) {
                    ctx.drawImage(window.gridPatternCanvas, tx * 128, ty * 128);
                }
            }
            
            ctx.restore()
            
            // Draw shooting stars (desktop only)
            if (!isMobile) {
                shootingStars.forEach(star => star.draw());
            }
            
            // Add scanline effect for retro monitor feel (desktop only)
            if (!isMobile) {
                ctx.fillStyle = 'rgba(0,255,0,0.02)';
                for (let y = 0; y < canvas.height; y += 4) {
                    if (y % 8 === 0) {
                        ctx.fillRect(0, y, canvas.width, 2);
                    }
                }
            }
        }
        
        // Draw pixel nebulae with parallax
        function drawPixelNebulae() {
            const pixelSize = 8;
            
            pixelNebulae.forEach((nebula, index) => {
                // Check if nebula is cached
                const cacheKey = `nebula_${index}`;
                let cachedCanvas = nebulaCanvases.get(cacheKey);
                
                // If not cached, render it once
                if (!cachedCanvas) {
                    // Initialize clusters if not already done
                    if (nebula.clusters.length === 0) {
                        // Create organic shape with multiple overlapping circular clusters
                        const clusterCount = 3 + Math.floor(Math.random() * 4);
                        const centerX = nebula.width / 2;
                        const centerY = nebula.height / 2;
                        
                        for (let i = 0; i < clusterCount; i++) {
                            // Create clusters that overlap near the center for more organic shapes
                            const angle = (i / clusterCount) * Math.PI * 2;
                            const distance = Math.random() * nebula.width * 0.2; // Keep clusters close to center
                            nebula.clusters.push({
                                cx: centerX + Math.cos(angle) * distance,
                                cy: centerY + Math.sin(angle) * distance,
                                radius: nebula.width * (0.4 + Math.random() * 0.3)
                            });
                        }
                    }
                    
                    // Create offscreen canvas
                    cachedCanvas = document.createElement('canvas');
                    cachedCanvas.width = nebula.width;
                    cachedCanvas.height = nebula.height;
                    const cacheCtx = cachedCanvas.getContext('2d');
                    
                    // Pre-calculate values for optimization
                    const centerX = nebula.width / 2;
                    const centerY = nebula.height / 2;
                    const maxRadius = Math.min(nebula.width, nebula.height) / 2;
                    const maxRadiusSquared = maxRadius * maxRadius;
                    
                    // Draw nebula once to cache
                    for (let nx = 0; nx < nebula.width; nx += pixelSize) {
                        for (let ny = 0; ny < nebula.height; ny += pixelSize) {
                            // Optimized distance check (squared distance to avoid sqrt)
                            const dx = nx - centerX;
                            const dy = ny - centerY;
                            const distFromCenterSquared = dx * dx + dy * dy;
                            if (distFromCenterSquared > maxRadiusSquared) continue;
                            
                            // Check if pixel is within any cluster
                            let inCluster = false;
                            let minDist = Infinity;
                            
                            for (const cluster of nebula.clusters) {
                                const cdx = nx - cluster.cx;
                                const cdy = ny - cluster.cy;
                                const distSquared = cdx * cdx + cdy * cdy;
                                const radiusSquared = cluster.radius * cluster.radius;
                                
                                if (distSquared < radiusSquared) {
                                    inCluster = true;
                                    const dist = Math.sqrt(distSquared);
                                    minDist = Math.min(minDist, dist / cluster.radius);
                                }
                            }
                            
                            if (inCluster) {
                                // More cloud-like density with smoother falloff
                                const density = nebula.density * (1 - minDist * minDist); // Quadratic falloff
                                if (Math.random() < density) {
                                    const opacity = 0.05 + (1 - minDist) * 0.3; // Lower opacity for more ethereal look
                                    
                                    cacheCtx.fillStyle = nebula.color;
                                    cacheCtx.globalAlpha = opacity;
                                    cacheCtx.fillRect(
                                        Math.floor(nx / pixelSize) * pixelSize,
                                        Math.floor(ny / pixelSize) * pixelSize,
                                        pixelSize,
                                        pixelSize
                                    );
                                }
                            }
                        }
                    }
                    
                    // Store in cache
                    nebulaCanvases.set(cacheKey, cachedCanvas);
                }
                
                // Calculate position with parallax
                const parallaxFactor = 0.2 + (index % 5) * 0.05;
                const x = nebula.x - camera.x * parallaxFactor + canvas.width / 2;
                const y = nebula.y - camera.y * parallaxFactor + canvas.height / 2;
                
                // Viewport culling with margin
                const margin = 200;
                if (x + nebula.width < -margin || x > canvas.width + margin ||
                    y + nebula.height < -margin || y > canvas.height + margin) return;
                
                // Draw the cached nebula
                ctx.drawImage(cachedCanvas, x, y);
            });
        }
        
        // Draw pixel planets with parallax
        function drawPixelPlanets() {
            pixelPlanets.forEach((planet, i) => {
                const parallaxFactor = 0.3 + i * 0.05; // Increased parallax for better visibility
                const x = planet.x - camera.x * parallaxFactor + canvas.width / 2;
                const y = planet.y - camera.y * parallaxFactor + canvas.height / 2;
                
                // Only draw if in viewport
                if (x < -planet.radius * 2 || x > canvas.width + planet.radius * 2 ||
                    y < -planet.radius * 2 || y > canvas.height + planet.radius * 2) return;
                
                drawPixelPlanet(x, y, planet.radius, planet.color1, planet.color2, planet.rings, planet.opacity);
            });
        }
        
        // Draw a single pixel planet
        function drawPixelPlanet(x, y, radius, color1, color2, hasRings, opacity = 1) {
            const pixelSize = 4;
            
            // Save context for opacity
            ctx.save();
            ctx.globalAlpha = opacity;
            
            // Create blocky circle - optimized with squared distance
            const radiusSquared = radius * radius;
            for (let py = -radius; py <= radius; py += pixelSize) {
                for (let px = -radius; px <= radius; px += pixelSize) {
                    const distSquared = px * px + py * py;
                    if (distSquared <= radiusSquared) {
                        // Determine color based on position for banding effect
                        const band = Math.floor((py + radius) / (radius * 0.4));
                        ctx.fillStyle = band % 2 === 0 ? color1 : color2;
                        
                        ctx.fillRect(
                            Math.floor((x + px) / pixelSize) * pixelSize,
                            Math.floor((y + py) / pixelSize) * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                }
            }
            
            // Shadow - optimized with squared distance
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            for (let py = -radius * 0.7; py <= radius * 0.7; py += pixelSize) {
                for (let px = radius * 0.3; px <= radius; px += pixelSize) {
                    const distSquared = px * px + py * py;
                    if (distSquared <= radiusSquared) {
                        ctx.fillRect(
                            Math.floor((x + px) / pixelSize) * pixelSize,
                            Math.floor((y + py) / pixelSize) * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                }
            }
            
            // Rings
            if (hasRings) {
                ctx.globalAlpha = opacity * 0.5; // Rings at 50% of planet's opacity
                ctx.strokeStyle = '#D2691E';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(x, y, radius * 1.5, radius * 0.5, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Ring segments
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const rx = x + Math.cos(angle) * radius * 1.5;
                    const ry = y + Math.sin(angle) * radius * 0.5;
                    ctx.fillStyle = i % 2 === 0 ? '#D2691E' : '#A0522D';
                    ctx.fillRect(rx - 2, ry - 2, 4, 4);
                }
            }
            
            // Restore context
            ctx.restore();
        }
        
        // Draw pixel asteroids with parallax
        function drawPixelAsteroids() {
            // Update asteroid positions
            pixelAsteroids.forEach(asteroid => {
                asteroid.x += asteroid.driftX;
                asteroid.y += asteroid.driftY;
                asteroid.rotation += asteroid.rotSpeed;
                
                // Wrap around world
                if (asteroid.x < 0) asteroid.x = WORLD_SIZE;
                if (asteroid.x > WORLD_SIZE) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = WORLD_SIZE;
                if (asteroid.y > WORLD_SIZE) asteroid.y = 0;
            });
            
            // Draw asteroids
            pixelAsteroids.forEach(asteroid => {
                const x = asteroid.x - camera.x * 0.15 + canvas.width / 2;
                const y = asteroid.y - camera.y * 0.15 + canvas.height / 2;
                
                // Only draw if in viewport
                if (x < -20 || x > canvas.width + 20 || y < -20 || y > canvas.height + 20) return;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(asteroid.rotation);
                
                // Irregular asteroid shape
                ctx.fillStyle = '#696969';
                ctx.fillRect(-asteroid.size/2, -asteroid.size/2, asteroid.size, asteroid.size);
                
                // Details
                ctx.fillStyle = '#808080';
                ctx.fillRect(-asteroid.size/2 + 2, -asteroid.size/2 + 2, 4, 4);
                ctx.fillRect(asteroid.size/2 - 6, asteroid.size/2 - 6, 4, 4);
                
                ctx.fillStyle = '#505050';
                ctx.fillRect(0, 0, 4, 4);
                
                ctx.restore();
            });
            
            // Draw asteroid clusters
            asteroidClusters.forEach(cluster => {
                cluster.asteroids.forEach(asteroid => {
                    // Update rotation
                    asteroid.rotation += asteroid.rotationSpeed;
                    
                    // Slow drift
                    asteroid.x += asteroid.driftX;
                    asteroid.y += asteroid.driftY;
                    
                    // Calculate screen position with parallax
                    const x = asteroid.x - camera.x * 0.15 + canvas.width / 2;
                    const y = asteroid.y - camera.y * 0.15 + canvas.height / 2;
                    
                    // Skip if off-screen
                    if (x < -10 || x > canvas.width + 10 || y < -10 || y > canvas.height + 10) return;
                    
                    // Draw small asteroid
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(asteroid.rotation);
                    
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(-asteroid.size/2, -asteroid.size/2, asteroid.size, asteroid.size);
                    
                    // Darker detail
                    ctx.fillStyle = '#525252';
                    ctx.fillRect(-asteroid.size/4, -asteroid.size/4, asteroid.size/2, asteroid.size/2);
                    
                    ctx.restore();
                });
            });
        }
        
        // Game functions
        function initializeStaticStars() {
            staticStars = [];
            // Reduce stars on mobile for better performance
            const starCount = isMobile ? 50 : 200; // Much fewer stars on mobile
            
            for (let i = 0; i < starCount; i++) {
                staticStars.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: Math.random() * 2 + 1, // 1-3px
                    opacity: Math.random() * 0.2 + 0.1, // 0.1-0.3 opacity
                    color: Math.random() > 0.5 ? '#ffffff' : '#e0e8ff' // white or pale blue
                });
            }
            
            // Initialize pixel star layers
            pixelStarLayers.forEach(layer => {
                layer.stars = [];
                for (let i = 0; i < layer.count; i++) {
                    layer.stars.push({
                        x: Math.random() * WORLD_SIZE,
                        y: Math.random() * WORLD_SIZE,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            });
            
            // Initialize pixel asteroids - many small ones
            pixelAsteroids.length = 0;
            for (let i = 0; i < 50; i++) {
                pixelAsteroids.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: 4 + Math.random() * 8, // Smaller asteroids
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.05,
                    driftX: (Math.random() - 0.5) * 0.2,
                    driftY: (Math.random() - 0.5) * 0.2
                });
            }
        }
        
        function initializeBorderParticles() {
            borderParticles = [];
            
            // Create particles along each border
            const particleSpacing = 30;
            
            // Left border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(Math.random() * 30, y, 'left'));
                }
            }
            
            // Right border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(canvas.width - Math.random() * 30, y, 'right'));
                }
            }
            
            // Top border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, Math.random() * 30, 'top'));
                }
            }
            
            // Bottom border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, canvas.height - Math.random() * 30, 'bottom'));
                }
            }
        }
        
        function startGame() {
            // Cancel any existing game loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Prevent multiple game instances
            if (gameStarted) {
                console.log('Game already running, ignoring start request');
                return;
            }
            
            // No need to lock orientation here - already locked on page load for mobile
            
            // Clear all game state to ensure fresh start
            snakes = [];
            elements = [];
            gameWon = false; // Reset victory flag
            particles = [];
            revivesRemaining = 3; // Reset revives for new game
            voidOrbs = [];
            catalystGems = [];
            alchemyVisionPowerUps = [];
            aiRespawnQueue = [];
            usedAISkins.clear();
            
            // ALWAYS start fresh - no saved discoveries affect spawning
            discoveredElements = new Set([0, 1, 2, 3]); // Only base elements in global pool
            playerDiscoveredElements = new Set([0, 1, 2, 3]); // Start with base elements for spawn system
            
            // Load saved discoveries for UI/journal only
            if (window.elementCompatibility) {
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                if (savedDiscovered && Object.keys(savedDiscovered).length > 0) {
                    // Keep track of all-time discoveries for journal
                    Object.keys(savedDiscovered).forEach(key => {
                        if (savedDiscovered[key] && allTimeDiscoveries) {
                            // Add to all-time discoveries but NOT to spawn pool
                            allTimeDiscoveries.set(key, savedDiscovered[key]);
                        }
                    });
                    console.log(`[GAME START] Loaded ${allTimeDiscoveries.size} all-time discoveries (spawn starts with base elements only)`);
                }
            }
            
            console.log(`[GAME START] Fresh spawn pool - only base elements can spawn initially`);
            
            // Reset game variables
            lastDiscoveredElement = null;
            alchemyVisionActive = false;
            alchemyVisionTimer = 0;
            bestRank = 0;
            playerSnake = null;
            
            // Reset game loop timing variables
            lastTime = 0;
            accumulator = 0;
            frameCount = 0;
            lastFpsUpdate = 0;
            
            // Reset spawn timers
            lastAlchemyVisionSpawn = Date.now();
            lastVoidOrbSpawn = Date.now();
            lastCatalystGemSpawn = Date.now();
            
            // Initialize discovery feed - starts empty
            const discoveryFeed = document.getElementById('discoveryFeed');
            if (discoveryFeed) {
                discoveryFeed.innerHTML = '';
                // Players must discover everything, even base elements
                
                // Discovery feed ready for new discoveries
            }
            
            // Start fresh game
            gameStarted = true;
            gameStartTime = Date.now();
            
            // Reset session flags
            window.firstPlaceAchievedThisGame = false;
            
            // Dispatch game start event
            dispatchGameEvent('gameStart', { timestamp: gameStartTime });
            
            // Create player snake
            console.log('[GAME START] Creating player snake...');
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            
            // Set player name
            const playerName = localStorage.getItem('playerName') || window.nameGenerator.generateRandomName();
            playerSnake.name = playerName;
            
            snakes.push(playerSnake);
            console.log('[GAME START] Player snake created. Total snakes:', snakes.length);
            
            // Initialize leaderboard session for infinite mode
            if (gameMode === 'infinite') {
                leaderboardSubmitted = false;
                gameSessionStartTime = Date.now();
                
                if (supabaseModule) {
                    supabaseModule.startGameSession().then(sessionId => {
                        currentGameSessionId = sessionId;
                    });
                }
            }
            
            // Create AI snakes
            for (let i = 0; i < MAX_AI_SNAKES; i++) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            
            
            // Spawn initial elements using grid distribution
            const baseElements = [0, 1, 2, 3]; // Earth, Water, Air, Fire IDs
            
            // Clear element grid
            elementGrid.clear();
            
            // Spawn elements to reach initial target count
            const initialSpawnCount = Math.floor(TARGET_ELEMENT_COUNT * 0.7); // Start with 70% of target
            
            // Track how many of each base element we spawn
            const baseElementCounts = {
                0: 0, // Earth
                1: 0, // Water
                2: 0, // Air
                3: 0  // Fire
            };
            
            for (let i = 0; i < initialSpawnCount; i++) {
                // ALL initial spawns should be base elements only
                const elementId = baseElements[i % 4];
                baseElementCounts[elementId]++;
                
                // Get random position using grid distribution
                const gridCellsX = Math.ceil(WORLD_SIZE / ELEMENT_GRID_SIZE);
                const gridCellsY = Math.ceil(WORLD_SIZE / ELEMENT_GRID_SIZE);
                const gx = Math.floor(Math.random() * gridCellsX);
                const gy = Math.floor(Math.random() * gridCellsY);
                
                const cellX = gx * ELEMENT_GRID_SIZE;
                const cellY = gy * ELEMENT_GRID_SIZE;
                
                // Random position within cell with margin
                const margin = 50;
                const x = cellX + margin + Math.random() * (ELEMENT_GRID_SIZE - margin * 2);
                const y = cellY + margin + Math.random() * (ELEMENT_GRID_SIZE - margin * 2);
                
                // Ensure within world bounds
                const finalX = Math.max(100, Math.min(WORLD_SIZE - 100, x));
                const finalY = Math.max(100, Math.min(WORLD_SIZE - 100, y));
                
                // Spawn specific base element at position
                spawnElement(elementId, finalX, finalY);
            }
            
            // Verify all base elements were spawned
            
            // Verify all 4 base elements are represented
            const missingElements = [];
            for (let i = 0; i < 4; i++) {
                if (baseElementCounts[i] === 0) {
                    missingElements.push(baseElements[i]);
                }
            }
            
            if (missingElements.length > 0) {
                console.warn('[BASE ELEMENT SPAWN] WARNING: Missing base elements:', missingElements);
                console.warn('[BASE ELEMENT SPAWN] This should not happen with proper distribution!');
            } else {
            }
            
            
            // Initialize music and sound effects
            initMusic();
            initSoundEffects();
            initPowerUpSounds();
            initCombinationSounds();
            
            // Update discovery log
            updateDiscoveryLog();
            
            // Initialize border particles (desktop only)
            if (!isMobile) {
                initializeBorderParticles();
            }
            
            // Initialize static stars
            initializeStaticStars();
            
            gameLoop();
        }
        
        function stopGame() {
            
            // Cancel the game loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Reset game state
            gameStarted = false;
            paused = false;
            
            // Keep orientation locked on mobile - no unlocking
            
            // Clear ALL game objects
            snakes = [];
            playerSnake = null;
            elements = [];
            particles = [];
            voidOrbs = [];
            catalystGems = [];
            alchemyVisionPowerUps = [];
            aiRespawnQueue = [];
            usedAISkins.clear();
            comboStreak = 0;
            playerRespawnTimer = 0;
            
            // Clear the canvas to prevent solid color issue
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
        }
        
        function togglePause() {
            if (!gameStarted) return;
            paused = !paused;
            document.getElementById('pauseOverlay').style.display = paused ? 'flex' : 'none';
            
            // Update music button state
            if (paused) {
                // Update music controls if they exist
                const muteButton = document.getElementById('muteButton');
                if (muteButton) {
                    muteButton.textContent = musicMuted ? '🔇 Unmute' : '🔊 Mute';
                }
                const volumeSlider = document.getElementById('volumeSlider');
                if (volumeSlider) {
                    volumeSlider.value = musicVolume * 100;
                }
                const volumeDisplay = document.getElementById('volumeDisplay');
                if (volumeDisplay) {
                    volumeDisplay.textContent = Math.round(musicVolume * 100) + '%';
                }
                
                // Update skin selection UI
                calculateAvailableUnlocks();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Update high score display
                document.getElementById('highScoreDisplay').textContent = Math.floor(highScore).toLocaleString();
                
                // Populate discovery journal
                populateDiscoveryJournal();
            }
        }
        
        // Helper function to play UI sound
        function playUISound() {
            try {
                const beepSound = new Audio('sounds/retro-arcade-beep.mp3');
                beepSound.volume = 0.3;
                beepSound.play().catch(() => {});
            } catch (e) {}
        }
        
        window.resumeGame = function() {
            playUISound();
            paused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
        }
        
        // Debug command for element bank issues
        window.debugElementBank = false;
        window.enableElementBankDebug = function() {
            window.debugElementBank = true;
            return 'Element bank debugging enabled';
        }
        
        
        // Tab switching for pause menu
        window.switchTab = function(tabName) {
            // Update button states
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'skins') {
                document.getElementById('skinsTab').classList.add('active');
            } else if (tabName === 'journal') {
                document.getElementById('journalTab').classList.add('active');
                // Populate the discovery journal when tab is opened
                populateDiscoveryJournal();
            } else if (tabName === 'howto') {
                document.getElementById('howtoTab').classList.add('active');
            } else if (tabName === 'leaderboard') {
                document.getElementById('leaderboardTab').classList.add('active');
                // Load leaderboard when tab is opened
                window.loadPauseLeaderboard(currentPauseLBPeriod);
            }
        }
        
        // Build skin selection UI with rarity-based tabs
        let currentRarityFilter = 'common';
        
        function buildSkinGrid() {
            const grid = document.getElementById('skinGrid');
            if (!grid) {
                console.error('Skin grid element not found!');
                return;
            }
            
            // Update the unlock count display for current rarity
            updateUnlockCountForRarity(currentRarityFilter);
            grid.innerHTML = '';
            
            // Get all skins and filter by rarity
            let skinsToDisplay = Object.keys(skinMetadata).filter(skinId => {
                const skin = skinMetadata[skinId];
                return skin && skin.rarity === currentRarityFilter;
            });
            
            // Sort skins by rarity order and then by name
            const rarityOrder = ['common', 'uncommon', 'rare', 'legendary', 'exotic', 'secret'];
            skinsToDisplay.sort((a, b) => {
                const skinA = skinMetadata[a];
                const skinB = skinMetadata[b];
                if (!skinA || !skinB) return 0;
                
                const rarityIndexA = rarityOrder.indexOf(skinA.rarity);
                const rarityIndexB = rarityOrder.indexOf(skinB.rarity);
                
                if (rarityIndexA !== rarityIndexB) {
                    return rarityIndexA - rarityIndexB;
                }
                return skinA.name.localeCompare(skinB.name);
            });
            
            skinsToDisplay.forEach(skinId => {
                const skinData = skinMetadata[skinId];
                if (!skinData) return;
                
                // Skip secret skins unless on secret tab or unlocked
                if (skinData.rarity === 'secret' && !skinData.unlocked && currentRarityFilter !== 'secret') {
                    return;
                }
                
                const div = document.createElement('div');
                div.className = 'skin-item';
                div.setAttribute('data-skin-id', skinId);
                div.setAttribute('data-rarity', skinData.rarity);
                
                // Add state classes
                if (skinId === currentPlayerSkin) {
                    div.classList.add('equipped');
                }
                
                if (!skinData.unlocked) {
                    div.classList.add('locked');
                    if (availableUnlocks > 0 && !skinData.isBoss) {
                        div.classList.add('unlockable');
                    }
                }
                
                // Create inner container
                const innerContainer = document.createElement('div');
                innerContainer.className = 'skin-item-inner';
                
                // Create image or placeholder
                if (skinData.isBoss && !skinData.unlocked) {
                    // Mystery placeholder for locked boss skins
                    const placeholder = document.createElement('div');
                    placeholder.className = 'skin-mystery';
                    placeholder.innerHTML = '❓';
                    innerContainer.appendChild(placeholder);
                } else {
                    const img = document.createElement('img');
                    img.className = 'skin-image';
                    img.src = skinData.isBoss ? `assets/boss-skins/${skinId}.png` : `skins/${skinId}.png`;
                    img.alt = skinData.name;
                    img.onerror = function() {
                        // Try webp fallback
                        const basePath = skinData.isBoss ? `assets/boss-skins/${skinId}` : `skins/${skinId}`;
                        this.src = `${basePath}.webp`;
                        this.onerror = null;
                    };
                    innerContainer.appendChild(img);
                }
                
                // Add rarity indicator
                const rarityIndicator = document.createElement('div');
                rarityIndicator.className = 'rarity-indicator';
                rarityIndicator.setAttribute('data-rarity', skinData.rarity);
                innerContainer.appendChild(rarityIndicator);
                
                // Add name (hidden for locked boss skins)
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = (skinData.isBoss && !skinData.unlocked) ? '???' : skinData.name;
                innerContainer.appendChild(name);
                
                // Add lock overlay if locked
                if (!skinData.unlocked) {
                    const lockOverlay = document.createElement('div');
                    lockOverlay.className = 'lock-overlay';
                    const lockIcon = document.createElement('div');
                    lockIcon.className = 'lock-icon';
                    lockIcon.innerHTML = '🔒';
                    lockOverlay.appendChild(lockIcon);
                    innerContainer.appendChild(lockOverlay);
                }
                
                // Add equipped indicator
                if (skinId === currentPlayerSkin) {
                    const equippedBadge = document.createElement('div');
                    equippedBadge.className = 'equipped-badge';
                    equippedBadge.textContent = 'EQUIPPED';
                    innerContainer.appendChild(equippedBadge);
                }
                
                div.appendChild(innerContainer);
                
                // Click handler - open preview modal
                div.onclick = () => openSkinPreview(skinId);
                
                grid.appendChild(div);
            });
        }
        
        // Handle skin selection
        function selectSkin(skinId) {
            const skinData = skinMetadata[skinId];
            
            if (skinData.unlocked) {
                // Already unlocked - just select it
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    // Boss skins are in a different directory
                    if (skinMetadata[skinId].isBoss) {
                        portrait.src = `assets/boss-skins/${skinId}.png`;
                    } else {
                        portrait.src = `skins/${skinId}.png`;
                    }
                }
                saveSkinData();
                buildSkinGrid();
            } else if (availableUnlocks > 0) {
                // Unlock the skin
                skinData.unlocked = true;
                unlockedSkins.add(skinId);
                availableUnlocks--;
                
                // Select the newly unlocked skin
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    // Boss skins are in a different directory
                    if (skinMetadata[skinId].isBoss) {
                        portrait.src = `assets/boss-skins/${skinId}.png`;
                    } else {
                        portrait.src = `skins/${skinId}.png`;
                    }
                }
                
                saveSkinData();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Show unlock message
                showMessage(`Unlocked: ${skinData.name}!`, true);
            }
        }
        
        // Update unlock display
        function updateUnlockDisplay() {
            // Update based on current rarity filter
            if (currentRarityFilter) {
                updateUnlockCountForRarity(currentRarityFilter);
            } else {
                const display = document.getElementById('availableUnlocks');
                if (display) {
                    display.textContent = `Available Unlocks: ${availableUnlocks}`;
                    if (availableUnlocks > 0) {
                        display.style.color = '#4ecdc4';
                    } else {
                        display.style.color = '#AAA';
                    }
                }
            }
        }
        
        // Update unlock count for specific rarity
        function updateUnlockCountForRarity(rarity) {
            const display = document.getElementById('availableUnlocks');
            if (!display) return;
            
            // Count unlocked and total skins for this rarity
            let unlockedCount = 0;
            let totalCount = 0;
            
            Object.entries(skinMetadata).forEach(([skinId, skinData]) => {
                if (skinData.rarity === rarity) {
                    totalCount++;
                    if (skinData.unlocked) {
                        unlockedCount++;
                    }
                }
            });
            
            // Format rarity name
            const rarityName = rarity.charAt(0).toUpperCase() + rarity.slice(1);
            display.textContent = `${rarityName} Skins: ${unlockedCount}/${totalCount} Unlocked`;
            display.style.color = '#4ecdc4';
        }
        
        // Custom event dispatching helper
        function dispatchGameEvent(eventName, detail = {}) {
            const event = new CustomEvent(eventName, { detail });
            window.dispatchEvent(event);
            console.log(`[Game Event] ${eventName}`, detail);
        }
        
        // Rarity tab functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Re-merge skin data after all scripts are loaded
            if (window.SKIN_DATA && window.skinIdConverter) {
                const mergedMetadata = {};
                
                Object.keys(skinMetadata).forEach(oldId => {
                    mergedMetadata[oldId] = { ...skinMetadata[oldId] };
                    const newId = window.skinIdConverter.toNewId(oldId);
                    if (newId && window.SKIN_DATA[newId]) {
                        mergedMetadata[oldId] = {
                            ...mergedMetadata[oldId],
                            ...window.SKIN_DATA[newId],
                            colors: skinMetadata[oldId].colors,
                            unlocked: skinMetadata[oldId].unlocked
                        };
                    }
                });
                
                Object.keys(window.SKIN_DATA).forEach(newId => {
                    const oldId = window.skinIdConverter.toOldId(newId);
                    if (!oldId || !mergedMetadata[oldId]) {
                        mergedMetadata[newId] = {
                            ...window.SKIN_DATA[newId],
                            unlocked: false,
                            colors: window.SKIN_DATA[newId].colors || ['#888888', '#666666']
                        };
                    }
                });
                
                skinMetadata = mergedMetadata;
            }
            
            const rarityTabs = document.querySelectorAll('.rarity-tab');
            rarityTabs.forEach(tab => {
                // Add rarity-specific class for styling
                const rarity = tab.getAttribute('data-rarity');
                tab.classList.add(rarity);
                
                tab.addEventListener('click', function() {
                    playUISound();
                    // Update active tab
                    rarityTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update filter and rebuild grid
                    currentRarityFilter = this.getAttribute('data-rarity');
                    buildSkinGrid();
                    
                    // Update unlock count display
                    updateUnlockCountForRarity(currentRarityFilter);
                });
            });
            
            // Initialize player stats and unlock manager
            if (window.PlayerStats) {
                window.PlayerStats.initialize();
            }
            if (window.unlockManager) {
                window.unlockManager.initialize();
            }
        });
        
        // Open skin preview modal
        function openSkinPreview(skinId) {
            const skinData = skinMetadata[skinId];
            if (!skinData) return;
            
            // Play beep sound when opening modal
            try {
                const beepSound = new Audio('sounds/retro-arcade-beep.mp3');
                beepSound.volume = 0.3;
                beepSound.play().catch(() => {});
            } catch (e) {}
            
            const modal = document.getElementById('skinPreviewModal');
            const nameEl = document.getElementById('previewSkinName');
            const rarityEl = document.getElementById('previewRarity');
            const bioEl = document.getElementById('previewBio');
            const unlockCriteriaEl = document.getElementById('previewUnlockCriteria');
            const unlockTextEl = document.getElementById('unlockText');
            const progressBarEl = document.getElementById('unlockProgress');
            const progressTextEl = document.getElementById('progressText');
            const equipButton = document.getElementById('equipButton');
            const unlockButton = document.getElementById('unlockButton');
            
            // Update modal content
            nameEl.textContent = (skinData.isBoss && !skinData.unlocked) ? '???' : skinData.name;
            
            // Update rarity badge
            const rarityBadge = rarityEl.querySelector('.rarity-text');
            const rarityStars = rarityEl.querySelector('.rarity-stars');
            if (skinData.rarity && window.RARITY_CONFIG) {
                const rarityConfig = window.RARITY_CONFIG[skinData.rarity];
                rarityBadge.textContent = skinData.rarity.charAt(0).toUpperCase() + skinData.rarity.slice(1);
                rarityEl.style.backgroundColor = rarityConfig.color;
                rarityStars.textContent = '★'.repeat(rarityConfig.stars);
            }
            
            bioEl.textContent = (skinData.isBoss && !skinData.unlocked) ? 'Defeat this boss to unlock their skin!' : skinData.bio;
            
            // Handle unlock criteria display
            if (skinData.unlocked) {
                // Show unlock criteria even for unlocked skins, but hide progress bar
                unlockCriteriaEl.style.display = 'block';
                equipButton.style.display = 'block';
                unlockButton.style.display = 'none';
                
                // Show unlock description without progress
                if (skinData.unlockCriteria && skinData.unlockCriteria.description) {
                    unlockTextEl.textContent = skinData.unlockCriteria.description;
                }
                
                // Hide progress bar and text for unlocked skins
                const progressContainer = unlockCriteriaEl.querySelector('.progress-bar');
                const progressText = document.getElementById('progressText');
                if (progressContainer) progressContainer.style.display = 'none';
                if (progressText) progressText.style.display = 'none';
                
                if (skinId === currentPlayerSkin) {
                    equipButton.textContent = 'Equipped';
                    equipButton.disabled = true;
                } else {
                    equipButton.textContent = 'Equip';
                    equipButton.disabled = false;
                    equipButton.onclick = () => {
                        // Play beep sound when equipping
                        try {
                            const beepSound = new Audio('sounds/retro-arcade-beep.mp3');
                            beepSound.volume = 0.3;
                            beepSound.play().catch(() => {});
                        } catch (e) {}
                        
                        selectSkin(skinId);
                        equipButton.textContent = 'Equipped';
                        equipButton.disabled = true;
                        buildSkinGrid();
                    };
                }
            } else {
                unlockCriteriaEl.style.display = 'block';
                
                // Show progress bar and text for locked skins
                const progressContainer = unlockCriteriaEl.querySelector('.progress-bar');
                const progressText = document.getElementById('progressText');
                if (progressContainer) progressContainer.style.display = 'block';
                if (progressText) progressText.style.display = 'block';
                
                if (window.unlockManager) {
                    // Try to get unlock criteria description
                    let unlockDescription = 'Complete challenge to unlock';
                    if (skinData.unlockCriteria && skinData.unlockCriteria.description) {
                        unlockDescription = skinData.unlockCriteria.description;
                    }
                    
                    unlockTextEl.textContent = unlockDescription;
                    
                    const progress = window.unlockManager.getUnlockProgress(skinId);
                    
                    if (progress && progress.max > 0) {
                        progressBarEl.style.width = `${(progress.current / progress.max) * 100}%`;
                        progressTextEl.textContent = `${progress.current}/${progress.max}`;
                    } else {
                        progressBarEl.style.width = '0%';
                        progressTextEl.textContent = '0/0';
                    }
                } else {
                    unlockTextEl.textContent = 'Unlock system not available';
                }
                
                equipButton.style.display = 'none';
                
                // Show unlock button if we have tokens and it's not a boss skin
                if (availableUnlocks > 0 && !skinData.isBoss) {
                    unlockButton.style.display = 'block';
                    unlockButton.onclick = () => {
                        selectSkin(skinId);
                        modal.style.display = 'none';
                    };
                } else {
                    unlockButton.style.display = 'none';
                }
            }
            
            // Draw skin preview
            drawSkinPreview(skinId);
            
            // Show modal
            modal.style.display = 'flex';
            
            // Close modal handlers
            const closeBtn = modal.querySelector('.modal-close');
            closeBtn.onclick = () => modal.style.display = 'none';
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Show unlock notification
        function showUnlockNotification(skinId) {
            const skinData = skinMetadata[skinId];
            if (!skinData) return;
            
            const container = document.getElementById('unlockNotificationContainer');
            const notification = document.createElement('div');
            notification.className = `unlock-notification ${skinData.rarity}`;
            
            notification.innerHTML = `
                <div class="unlock-content">
                    <div class="unlock-header">
                        <span class="unlock-icon">🔓</span>
                        <span class="unlock-title">NEW SKIN UNLOCKED!</span>
                    </div>
                    <div class="unlock-skin-info">
                        <img src="${skinData.isBoss ? `assets/boss-skins/${skinId}.png` : `skins/${skinId}.png`}" 
                             alt="${skinData.name}" class="unlock-skin-image">
                        <div class="unlock-details">
                            <h3 class="unlock-skin-name">${skinData.name}</h3>
                            <div class="unlock-rarity ${skinData.rarity}">
                                <span class="rarity-stars">${'★'.repeat(window.RARITY_CONFIG[skinData.rarity].stars)}</span>
                                <span class="rarity-text">${skinData.rarity.toUpperCase()}</span>
                            </div>
                            <p class="unlock-bio">${skinData.bio}</p>
                        </div>
                    </div>
                </div>
            `;
            
            container.appendChild(notification);
            
            // Auto-remove after animation
            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 500);
            }, 5000);
            
            // Play unlock sound based on rarity
            if (window.playUnlockSound) {
                window.playUnlockSound(skinData.rarity);
            }
        }
        
        // Listen for unlock events from UnlockManager
        window.addEventListener('skinUnlocked', (event) => {
            showUnlockNotification(event.detail.skinId);
            
            // Refresh the skin grid if the pause menu is open
            const pauseMenu = document.getElementById('pauseMenu');
            if (pauseMenu && pauseMenu.style.display !== 'none') {
                // Reload skin data to sync with UnlockManager
                loadSkinData();
                // Rebuild the skin grid to show newly unlocked skin
                buildSkinGrid();
            }
        });
        
        // Draw animated skin preview
        function drawSkinPreview(skinId) {
            const canvas = document.getElementById('skinPreviewCanvas');
            const ctx = canvas.getContext('2d');
            const skinData = skinMetadata[skinId];
            
            if (!skinData || (skinData.isBoss && !skinData.unlocked)) {
                // Draw mystery placeholder for locked boss skins
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('❓', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Load and draw the skin image with rotation animation
            const img = new Image();
            img.src = skinData.isBoss ? `assets/boss-skins/${skinId}.png` : `skins/${skinId}.png`;
            
            let rotation = 0;
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(rotation);
                
                if (img.complete && img.naturalHeight !== 0) {
                    const size = Math.min(canvas.width, canvas.height) * 0.8;
                    ctx.drawImage(img, -size / 2, -size / 2, size, size);
                }
                
                ctx.restore();
                rotation += 0.01;
                
                if (document.getElementById('skinPreviewModal').style.display === 'flex') {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }
        
        // Populate discovery journal with discovered elements
        function populateDiscoveryJournal() {
            const grid = document.getElementById('discoveryGrid');
            if (!grid) {
                console.error('Discovery grid element not found!');
                return;
            }
            
            grid.innerHTML = '';
            
            // Check if element loader is ready
            if (!window.elementLoader || !window.elementLoader.elements) {
                console.error('Element loader not ready');
                return;
            }
            
            // Update discovery count
            const countElement = document.getElementById('discoveryCount');
            if (countElement) {
                countElement.textContent = `Total Discoveries: ${allTimeDiscoveries.size}`;
            }
            
            // Use allTimeDiscoveries for persistent journal
            const sortedDiscoveries = Array.from(allTimeDiscoveries.entries()).sort((a, b) => {
                const elementA = window.elementLoader.elements.get(parseInt(a[0]));
                const elementB = window.elementLoader.elements.get(parseInt(b[0]));
                const nameA = elementA?.n || 'Unknown';
                const nameB = elementB?.n || 'Unknown';
                return nameA.localeCompare(nameB);
            });
            
            sortedDiscoveries.forEach(([elementId, recipe]) => {
                const elementData = window.elementLoader.elements.get(parseInt(elementId));
                if (!elementData) return;
                
                const div = document.createElement('div');
                div.className = 'discovery-item';
                div.dataset.name = elementData.n.toLowerCase();
                div.dataset.recipe = recipe.toLowerCase();
                
                // Element emoji/symbol
                const symbol = document.createElement('div');
                symbol.className = 'element-symbol';
                symbol.textContent = window.elementLoader.getEmojiForElement(parseInt(elementId), elementData.e);
                
                // Element name
                const name = document.createElement('div');
                name.className = 'element-name';
                name.textContent = elementData.n;
                
                // Recipe tooltip
                const recipeTooltip = document.createElement('div');
                recipeTooltip.className = 'recipe';
                recipeTooltip.textContent = recipe;
                
                div.appendChild(symbol);
                div.appendChild(name);
                div.appendChild(recipeTooltip);
                
                grid.appendChild(div);
            });
        }
        
        // filterDiscoveries function removed - search bar no longer present
        
        // Fixed timestep constants
        const FIXED_TIMESTEP = 1000 / 60; // 60 FPS fixed timestep (16.67ms)
        const MAX_UPDATES = 5; // Prevent spiral of death
        
        function gameLoop(currentTime) {
            if (!gameStarted) {
                animationFrameId = null;
                return;
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
            
            if (paused) return;
            
            // Don't render if canvas is not visible
            if (canvas.style.opacity === '0') return;
            
            // Initialize lastTime on first frame
            if (lastTime === 0) {
                lastTime = currentTime;
                return;
            }
            
            // Calculate elapsed time
            const elapsed = currentTime - lastTime;
            
            // Calculate frame time
            if (!isFinite(currentTime)) {
                console.error('currentTime is not finite:', currentTime);
                return;
            }
            const frameTime = Math.min(elapsed, 250); // Cap at 250ms (4 FPS min)
            lastTime = currentTime;
            
            // Add to accumulator
            accumulator += frameTime;
            
            // Check for NaN
            if (!isFinite(accumulator) || !isFinite(frameTime)) {
                console.error('Accumulator or frameTime became NaN! frameTime:', frameTime, 'currentTime:', currentTime, 'lastTime:', lastTime, 'accumulator:', accumulator);
                accumulator = 0;
                lastTime = currentTime;
                return;
            }
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) { // Update every second
                currentFPS = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
                
                // Update FPS display
                const fpsElement = document.getElementById('fpsCounter');
                if (fpsElement) {
                    fpsElement.textContent = `FPS: ${currentFPS}`;
                }
            }
            
            // Update animation time for border effects
            animationTime = currentTime * 0.001; // Convert to seconds
            
            // Fixed timestep updates
            let updates = 0;
            while (accumulator >= FIXED_TIMESTEP && updates < MAX_UPDATES) {
                // Update game objects with fixed timestep (1.0 = one 60fps frame)
                // Update all snakes - staggering removed due to complexity
                for (let i = 0; i < snakes.length; i++) {
                    const snake = snakes[i];
                    if (snake.alive) {
                        snake.update(1.0);
                    }
                }
                elementPool.update(1.0);
                particlePool.update(1.0);
                
                // Update border particles (desktop only)
                if (!isMobile) {
                    borderParticles.forEach(particle => particle.update(1.0));
                }
                
                // Update shooting stars (desktop only)
                if (!isMobile) {
                    shootingStars = shootingStars.filter(star => star.update(1.0));
                    
                    // Spawn shooting star occasionally (3-5 seconds)
                    if (currentTime - lastShootingStarTime > (3000 + Math.random() * 2000) && shootingStars.length < 3) {
                        shootingStars.push(new ShootingStar());
                        lastShootingStarTime = currentTime;
                    }
                }
                
                // Check collisions
                checkCollisions();
                
                // Store AI snake data before removing dead snakes
                snakes.forEach(snake => {
                    if (!snake.alive && !snake.isPlayer) {
                        // Store AI snake data for respawning with score
                        const snakeId = snake.name || `AI_${Date.now()}`;
                        aiSnakeDataMap.set(snakeId, {
                            score: snake.score,
                            kills: snake.kills,
                            discoveries: snake.discoveries,
                            elementCapacity: snake.elementCapacity,
                            personality: snake.personality,
                            name: snake.name,
                            skin: snake.skin
                        });
                    }
                });
                
                // Remove dead snakes
                snakes = snakes.filter(snake => snake.alive);
                
                // Spawn new elements to maintain target count (increased during boss battles)
                const currentElementCount = elementPool.getActiveCount();
                // Special case for Osseus - limit to 2x spawn rate
                let bossSpawnMultiplier = 1;
                if (bossEncounterActive) {
                    if (currentBoss && currentBoss.elementId === 0) { // Osseus (Earth element)
                        bossSpawnMultiplier = 2; // Cap at 2x for Osseus
                    } else {
                        bossSpawnMultiplier = 3; // 3x for other bosses
                    }
                }
                
                if (currentElementCount < TARGET_ELEMENT_COUNT - 20) {
                    // Only spawn if significantly below target
                    const elementsToSpawn = Math.min(2 * bossSpawnMultiplier, Math.floor((TARGET_ELEMENT_COUNT - currentElementCount) / 10));
                    for (let i = 0; i < elementsToSpawn; i++) {
                        if (Math.random() < 0.8) { // 80% chance per spawn
                            if (bossEncounterActive && currentBoss && Math.random() < 0.15) {
                                // Reduced from 50% to 15% chance to spawn boss's element type during boss battles
                                spawnElement(currentBoss.elementId);
                            } else {
                                spawnElementWithGridDistribution();
                            }
                        }
                    }
                } else if (Math.random() < (0.05 * bossSpawnMultiplier) && currentElementCount < TARGET_ELEMENT_COUNT) {
                    // Occasional spawns to replace consumed elements (increased during boss battles)
                    if (bossEncounterActive && currentBoss && Math.random() < 0.15) {
                        // Reduced from 50% to 15% chance to spawn boss's element type during boss battles
                        spawnElement(currentBoss.elementId);
                    } else {
                        spawnElementWithGridDistribution();
                    }
                }
                
                // Update AlchemyVision timer
                if (alchemyVisionActive) {
                    alchemyVisionTimer -= FIXED_TIMESTEP;
                    if (alchemyVisionTimer <= 0) {
                        alchemyVisionActive = false;
                        alchemyVisionTimer = 0;
                        // Clear any remaining power-ups when one expires
                        alchemyVisionPowerUps = [];
                    }
                }
                
                // AlchemyVision power-ups removed
                // if (alchemyVisionPowerUps.length === 0 && Date.now() - lastAlchemyVisionSpawn >= ALCHEMY_VISION_SPAWN_INTERVAL) {
                //     // Spawn multiple power-ups spread across the map
                //     for (let i = 0; i < ALCHEMY_VISION_SPAWN_COUNT; i++) {
                //         // Divide the map into sections to spread out spawns
                //         const sectionWidth = WORLD_SIZE / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT));
                //         const sectionHeight = WORLD_SIZE / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT));
                //         
                //         // Random position within each section
                //         const sectionX = (i % Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT))) * sectionWidth;
                //         const sectionY = Math.floor(i / Math.ceil(Math.sqrt(ALCHEMY_VISION_SPAWN_COUNT))) * sectionHeight;
                //         
                //         const x = sectionX + 100 + Math.random() * (sectionWidth - 200);
                //         const y = sectionY + 100 + Math.random() * (sectionHeight - 200);
                //         
                //         alchemyVisionPowerUps.push(new AlchemyVision(x, y));
                //     }
                //     lastAlchemyVisionSpawn = Date.now();
                // }
                
                // Update AlchemyVision power-ups (keeping for existing ones to expire)
                alchemyVisionPowerUps.forEach(powerUp => powerUp.update(1.0));
                
                // Spawn Void Orbs to maintain count
                if (voidOrbs.length < VOID_ORB_SPAWN_COUNT && Date.now() - lastVoidOrbSpawn >= VOID_ORB_SPAWN_INTERVAL / VOID_ORB_SPAWN_COUNT) {
                    const x = 100 + Math.random() * (WORLD_SIZE - 200);
                    const y = 100 + Math.random() * (WORLD_SIZE - 200);
                    voidOrbs.push(new VoidOrb(x, y));
                    lastVoidOrbSpawn = Date.now();
                }
                
                // Update Void Orbs
                voidOrbs.forEach(orb => orb.update(1.0));
                
                // Spawn Catalyst Gems to maintain count (more spread out)
                if (catalystGems.length < CATALYST_GEM_SPAWN_COUNT && Date.now() - lastCatalystGemSpawn >= CATALYST_GEM_SPAWN_INTERVAL / CATALYST_GEM_SPAWN_COUNT) {
                    // Divide map into sections for better spread
                    const sectionWidth = WORLD_SIZE / CATALYST_GEM_SPAWN_COUNT;
                    const sectionIndex = catalystGems.length;
                    const sectionX = sectionIndex * sectionWidth;
                    
                    const x = sectionX + 100 + Math.random() * (sectionWidth - 200);
                    const y = 100 + Math.random() * (WORLD_SIZE - 200);
                    catalystGems.push(new CatalystGem(x, y));
                    lastCatalystGemSpawn = Date.now();
                }
                
                // Update Catalyst Gems
                catalystGems.forEach(gem => gem.update(1.0));
                
                // Boss spawn check (infinite mode only)
                if (gameMode === 'infinite' && !bossEncounterActive && playerSnake && playerSnake.alive) {
                    // Check if player score is in boss spawn range
                    if (nextBossSpawnIndex < bossSpawnRanges.length) {
                        const range = bossSpawnRanges[nextBossSpawnIndex];
                        if (playerSnake.score >= range.min && playerSnake.score <= range.max) {
                            spawnBoss();
                            nextBossSpawnIndex++;
                        }
                    } else {
                        // After 600k, spawn at 100k intervals
                        const nextMilestone = 600000 + ((nextBossSpawnIndex - bossSpawnRanges.length + 1) * 100000);
                        if (playerSnake.score >= nextMilestone && playerSnake.score <= nextMilestone + 100000) {
                            spawnBoss();
                            nextBossSpawnIndex++;
                        }
                    }
                }
                
                // Update boss encounter
                if (bossEncounterActive && currentBoss) {
                    // Update boss projectiles
                    updateBossProjectiles(1.0);
                    updateShockwaves(1.0);
                    updateBossFissures(1.0);
                    
                    // Update damage numbers
                    updateDamageNumbers(1.0);
                    
                    // Update element vacuum
                    if (elementVacuumActive) {
                        elementVacuumTimer -= 1.0;
                        if (elementVacuumTimer <= 0) {
                            endElementVacuum();
                        } else {
                            // Update vacuum effect
                            updateElementVacuum(1.0);
                        }
                    }
                    
                    // Update screen shake
                    if (bossScreenShakeTimer > 0) {
                        bossScreenShakeTimer -= 1.0;
                    }
                    
                    // Check for elemental resonance damage
                    if (currentBoss.alive && currentBoss.stunTimer <= 0) {
                        checkBossElementalDamage();
                    }
                }
                
                accumulator -= FIXED_TIMESTEP;
                updates++;
            }
            
            // Handle AI snake respawning with cooldown
            const aiSnakes = snakes.filter(s => !s.isPlayer && s.alive).length;
            
            // Process respawn queue
            aiRespawnQueue = aiRespawnQueue.filter(respawnTime => {
                if (currentTime >= respawnTime && aiSnakes < MAX_AI_SNAKES) {
                    // Spawn new AI snake
                    const x = 200 + Math.random() * (WORLD_SIZE - 400);
                    const y = 200 + Math.random() * (WORLD_SIZE - 400);
                    const newAISnake = new Snake(x, y, false);
                    
                    // Try to restore data from a dead AI snake
                    if (aiSnakeDataMap.size > 0) {
                        // Get the first available AI snake data
                        const [snakeId, snakeData] = aiSnakeDataMap.entries().next().value;
                        
                        // Restore the AI snake's score and stats (no penalty for AI)
                        newAISnake.score = snakeData.score;
                        newAISnake.kills = snakeData.kills;
                        newAISnake.discoveries = snakeData.discoveries;
                        newAISnake.elementCapacity = snakeData.elementCapacity;
                        // Only restore personality if not a boss (safety check)
                        if (!newAISnake.isBoss && snakeData.personality) {
                            newAISnake.personality = snakeData.personality;
                        }
                        newAISnake.name = snakeData.name;
                        newAISnake.skin = snakeData.skin;
                        
                        // Remove used data
                        aiSnakeDataMap.delete(snakeId);
                    }
                    
                    snakes.push(newAISnake);
                    return false; // Remove from queue
                }
                return true; // Keep in queue
            });
            
            // Check if we need to add dead snakes to respawn queue
            if (aiSnakes < MAX_AI_SNAKES) {
                const deadAICount = MAX_AI_SNAKES - aiSnakes - aiRespawnQueue.length;
                for (let i = 0; i < deadAICount; i++) {
                    aiRespawnQueue.push(currentTime + AI_RESPAWN_COOLDOWN);
                }
            }
            
            // Handle player respawn
            if (playerSnake && !playerSnake.alive) {
                if (playerRespawnTimer <= 0) {
                    // Start respawn timer
                    playerRespawnTimer = 10000; // 10 seconds
                    comboStreak = 0; // Reset combo streak on death
                    
                    // Save snake state for potential revive
                    savedSnakeLength = playerSnake.segments.length;
                    savedSnakeScore = playerSnake.score;
                    
                    // Set random death message (only once on death)
                    const deathMessageEl = document.getElementById('deathMessage');
                    if (deathMessageEl && window.nameGenerator) {
                        deathMessageEl.textContent = window.nameGenerator.getRandomDeathMessage();
                    }
                    
                    // Dispatch player death event
                    dispatchGameEvent('playerDeath', {
                        score: playerSnake.score,
                        discoveries: playerSnake.discoveries,
                        kills: playerSnake.kills,
                        length: playerSnake.segments.length,
                        playTime: gameSessionStartTime ? Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0
                    });
                    
                    // Also dispatch game end event
                    dispatchGameEvent('gameEnd', {
                        score: playerSnake.score,
                        discoveries: playerSnake.discoveries,
                        kills: playerSnake.kills,
                        playTime: gameSessionStartTime ? Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0,
                        finalRank: snakes.filter(s => s.alive).length + 1
                    });
                    
                    // Track death event
                    if (supabaseModule && supabaseModule.addGameEvent) {
                        supabaseModule.addGameEvent('death', {
                            score: playerSnake.score,
                            discoveries: playerSnake.discoveries,
                            kills: playerSnake.kills,
                            length: playerSnake.segments.length,
                            play_time: gameSessionStartTime ? Math.floor((Date.now() - gameSessionStartTime) / 1000) : 0
                        });
                    }
                }
                
                // Update respawn timer
                playerRespawnTimer -= frameTime;
                
                if (playerRespawnTimer <= 0) {
                    // Store previous score before creating new snake
                    const previousScore = playerSnake.score;
                    const previousCapacity = playerSnake.elementCapacity;
                    const previousDiscoveries = playerSnake.discoveries;
                    const previousKills = playerSnake.kills;
                    
                    // Debug logging
                    
                    // Remove ALL player snakes from array (in case of duplicates)
                    const oldPlayerCount = snakes.filter(snake => snake.isPlayer).length;
                    snakes = snakes.filter(snake => !snake.isPlayer);
                    
                    // Double check that playerSnake is cleared
                    if (snakes.some(s => s.isPlayer)) {
                        console.error('[RESPAWN] ERROR: Player snake still exists after cleanup!');
                        snakes = snakes.filter(snake => !snake.isPlayer);
                    }
                    
                    
                    // Respawn player at center
                    playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
                    
                    // Set player name
                    const playerName = localStorage.getItem('playerName') || window.nameGenerator.generateRandomName();
                    playerSnake.name = playerName;
                    
                    // Check if this is a revive or respawn
                    if (window.isReviving && revivesRemaining >= 0) {
                        // Revive: restore full score and length
                        playerSnake.score = savedSnakeScore;
                        
                        // Restore snake to saved length
                        const targetLength = Math.max(5, savedSnakeLength); // Minimum 5 segments
                        while (playerSnake.segments.length < targetLength) {
                            const tail = playerSnake.segments[playerSnake.segments.length - 1];
                            playerSnake.segments.push({
                                x: tail.x,
                                y: tail.y
                            });
                        }
                        
                        // Restore full game state
                        playerSnake.elementCapacity = previousCapacity;
                        playerSnake.discoveries = previousDiscoveries;
                        playerSnake.kills = previousKills;
                        
                        window.isReviving = false;
                    } else {
                        // Normal respawn: apply penalties
                        playerSnake.score = Math.floor(previousScore * 0.75);
                        playerSnake.elementCapacity = Math.max(4, Math.floor(previousCapacity * 0.5));
                        playerSnake.discoveries = Math.floor(previousDiscoveries * 0.5);
                        playerSnake.kills = Math.floor(previousKills * 0.5);
                    }
                    
                    // Grant 3 seconds of invincibility on respawn
                    playerSnake.invincibilityTimer = 3000;
                    
                    // Add back to snakes array
                    snakes.push(playerSnake);
                    
                    
                    // Set camera to new player position to prevent jumping
                    camera.x = WORLD_SIZE / 2;
                    camera.y = WORLD_SIZE / 2;
                    
                    // Reset respawn timer
                    playerRespawnTimer = 0;
                    
                    // Reset leaderboard submission flag for next death
                    leaderboardSubmitted = false;
                    
                    // Only reset game session start time if it's null (first spawn)
                    if (!gameSessionStartTime) {
                        gameSessionStartTime = Date.now();
                    }
                    
                    // Start a new game session for proper server-side validation
                    if (gameMode === 'infinite' && supabaseModule) {
                        supabaseModule.startGameSession().then(sessionId => {
                            currentGameSessionId = sessionId;
                        });
                    }
                }
            }
            
            // Update UI
            updateUI();
            
            // Update boost bar every frame for real-time feedback
            updateBoostBar();
            
            // Calculate interpolation factor for smooth rendering
            const interpolation = accumulator / FIXED_TIMESTEP;
            
            // Update camera to follow player with interpolation
            if (playerSnake && playerSnake.alive && playerSnake.segments.length > 0) {
                const head = playerSnake.segments[0];
                
                // Interpolate player position for camera
                let playerX = playerSnake.x;
                let playerY = playerSnake.y;
                
                if (playerSnake.prevX !== undefined && playerSnake.prevY !== undefined) {
                    playerX = playerSnake.prevX + (playerSnake.x - playerSnake.prevX) * interpolation;
                    playerY = playerSnake.prevY + (playerSnake.y - playerSnake.prevY) * interpolation;
                }
                
                // Ensure camera coordinates stay within world bounds
                // Allow camera to reach edges so player can see the entire map
                camera.x = Math.max(0, Math.min(WORLD_SIZE, playerX));
                camera.y = Math.max(0, Math.min(WORLD_SIZE, playerY));
                
                // Additional check for NaN or Infinity
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            } else if (playerSnake && !playerSnake.alive) {
                // Keep camera at last known position when player is dead
                // This prevents camera jumping during respawn
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            }
            
            // Apply screen shake if active
            let screenShakeActive = false;
            if (bossScreenShakeTimer > 0) {
                screenShakeActive = true;
                ctx.save();
                const shakeX = (Math.random() - 0.5) * bossScreenShakeIntensity;
                const shakeY = (Math.random() - 0.5) * bossScreenShakeIntensity;
                ctx.translate(shakeX, shakeY);
                bossScreenShakeTimer--;
            }
            
            // Draw everything
            drawBackground();
            
            // Draw elements (element pool handles viewport culling)
            elementPool.draw();
            
            // Draw AlchemyVision power-ups (with viewport culling)
            for (let i = 0; i < alchemyVisionPowerUps.length; i++) {
                const powerUp = alchemyVisionPowerUps[i];
                if (isInViewport(powerUp.x, powerUp.y, 100)) {
                    powerUp.draw();
                }
            }
            
            // Draw Void Orbs (with viewport culling)
            for (let i = 0; i < voidOrbs.length; i++) {
                const orb = voidOrbs[i];
                if (isInViewport(orb.x, orb.y, 100)) {
                    orb.draw();
                }
            }
            
            // Draw Catalyst Gems (with viewport culling)
            for (let i = 0; i < catalystGems.length; i++) {
                const gem = catalystGems[i];
                if (isInViewport(gem.x, gem.y, 100)) {
                    gem.draw();
                }
            }
            
            // Draw boss projectiles
            if (bossEncounterActive) {
                drawBossFissures(); // Draw fissures first (under everything else)
                drawBossProjectiles();
                drawShockwaves();
                drawDamageNumbers();
            }
            
            // Draw snakes (they already have internal viewport culling)
            for (let i = 0; i < snakes.length; i++) {
                const snake = snakes[i];
                if (snake.alive) {
                    snake.draw(interpolation);
                }
            }
            
            // Draw boss skull indicator
            if (currentBoss && currentBoss.alive) {
                drawBossSkullIndicator();
            }
            
            // Draw particles (particle pool handles viewport culling)
            particlePool.draw();
            
            // Draw boss damage flash
            if (bossDamageFlashTimer > 0) {
                ctx.save();
                ctx.globalAlpha = bossDamageFlashTimer / 20 * 0.3;
                ctx.fillStyle = currentBoss ? currentBoss.color : '#fff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                bossDamageFlashTimer--;
                
                // Redraw player on top of the damage flash to ensure visibility
                if (playerSnake && playerSnake.alive) {
                    // Save context state before redrawing to ensure clean state
                    ctx.save();
                    ctx.globalAlpha = 1; // Ensure full opacity
                    playerSnake.draw(interpolation);
                    ctx.restore();
                }
            }
            
            // Update boss damage cooldown
            if (bossDamageCooldown > 0) {
                bossDamageCooldown--;
            }
            
            // Restore context if screen shake was active
            if (screenShakeActive) {
                ctx.restore();
            }
        }
        
        // Initialize mobile controls
        function initMobileControls() {
            if (!isMobile) return;
            
            // Add mobile class to body
            document.body.classList.add('mobile');
            
            // Make leaderboard collapsible on mobile
            const leaderboardBox = document.querySelector('.leaderboard-box');
            if (leaderboardBox) {
                leaderboardBox.addEventListener('click', function(e) {
                    // Only toggle if clicking on the box itself or header, not entries
                    if (e.target === leaderboardBox || e.target.classList.contains('leaderboard-header')) {
                        this.classList.toggle('collapsed');
                    }
                });
                
                // Start collapsed on mobile
                leaderboardBox.classList.add('collapsed');
            }
            
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const boostBtn = document.getElementById('boostButton');
            
            let joystickTouch = null;
            
            // Joystick controls
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouch === null && e.changedTouches.length > 0) {
                    joystickTouch = e.changedTouches[0].identifier;
                    joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    joystickBase.x = rect.left + rect.width / 2;
                    joystickBase.y = rect.top + rect.height / 2;
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouch) {
                        const dx = touch.clientX - joystickBase.x;
                        const dy = touch.clientY - joystickBase.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = 40; // Max knob travel distance
                        
                        let knobX = dx;
                        let knobY = dy;
                        
                        if (distance > maxDistance) {
                            knobX = (dx / distance) * maxDistance;
                            knobY = (dy / distance) * maxDistance;
                        }
                        
                        // Update knob position
                        knob.style.left = `${50 + (knobX / 60) * 50}%`;
                        knob.style.top = `${50 + (knobY / 60) * 50}%`;
                        
                        // Update mouse angle for game controls
                        if (distance > 10) { // Dead zone
                            mouseAngle = Math.atan2(dy, dx);
                        }
                        break;
                    }
                }
            });
            
            const resetJoystick = () => {
                joystickActive = false;
                joystickTouch = null;
                knob.style.left = '50%';
                knob.style.top = '50%';
            };
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouch) {
                        resetJoystick();
                        break;
                    }
                }
            });
            
            joystick.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                resetJoystick();
            });
            
            // Boost button controls
            boostBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouseDown = true;
                boostBtn.classList.add('active');
            });
            
            boostBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            boostBtn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            // Prevent scrolling on game canvas
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            });
        }
        
        // Enhanced mobile experience JavaScript
        document.addEventListener('DOMContentLoaded', function() {
            
            // Apply mobile class more accurately
            if (isTabletOrMobile()) {
                document.body.classList.add('mobile');
                
                // Force landscape orientation immediately on mobile
                lockToLandscape();
                
                // Monitor orientation changes
                window.addEventListener('orientationchange', checkAndShowRotateMessage);
                window.addEventListener('resize', checkAndShowRotateMessage);
                
                // Initial check
                checkAndShowRotateMessage();
            }
            
            // Handle orientation changes
            function handleOrientationChange() {
                const orientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
                document.body.setAttribute('data-orientation', orientation);
                
                // Adjust UI scale for better visibility
                if (orientation === 'portrait' && window.innerWidth < 600) {
                    document.querySelector('meta[name="viewport"]').setAttribute('content', 
                        'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
                }
                
                // Update UI positions using the UI Manager
                if (window.mobileUIManager) {
                    window.mobileUIManager.updatePositions(orientation);
                }
            }
            
            // Mobile UI Manager for dynamic positioning
            window.mobileUIManager = {
                updatePositions: function(orientation) {
                    if (!isTabletOrMobile()) return;
                    
                    const root = document.documentElement;
                    
                    if (orientation === 'landscape') {
                        // Landscape positions - UI at top
                        root.style.setProperty('--mobile-scorecard-top', '10px');
                        root.style.setProperty('--mobile-scorecard-left', '10px');
                        root.style.setProperty('--mobile-scorecard-bottom', 'unset');
                        root.style.setProperty('--mobile-scorecard-right', 'auto');
                        root.style.setProperty('--mobile-leaderboard-top', '10px');
                        root.style.setProperty('--mobile-leaderboard-right', '10px');
                        root.style.setProperty('--mobile-leaderboard-bottom', 'unset');
                        root.style.setProperty('--mobile-leaderboard-left', 'auto');
                        root.style.setProperty('--mobile-boost-bar-height', '20px');
                        root.style.setProperty('--mobile-discovery-scale', '0.75');
                        root.style.setProperty('--mobile-discovery-opacity', '0.6');
                    } else {
                        // Portrait positions - UI at top with more spacing
                        root.style.setProperty('--mobile-scorecard-top', '50px');
                        root.style.setProperty('--mobile-scorecard-left', '10px');
                        root.style.setProperty('--mobile-scorecard-bottom', 'unset');
                        root.style.setProperty('--mobile-scorecard-right', 'auto');
                        root.style.setProperty('--mobile-leaderboard-top', '50px');
                        root.style.setProperty('--mobile-leaderboard-right', '10px');
                        root.style.setProperty('--mobile-leaderboard-bottom', 'unset');
                        root.style.setProperty('--mobile-leaderboard-left', 'auto');
                        root.style.setProperty('--mobile-boost-bar-height', '18px');
                        root.style.setProperty('--mobile-discovery-scale', '0.7');
                        root.style.setProperty('--mobile-discovery-opacity', '0.5');
                    }
                    
                    // Update control translucency
                    root.style.setProperty('--mobile-joystick-opacity', '0.3');
                    root.style.setProperty('--mobile-boost-opacity', '0.6');
                },
                
                applyMobileOptimizations: function() {
                    // Apply additional mobile-specific optimizations
                    const discoveryFeed = document.querySelector('.discovery-feed');
                    if (discoveryFeed && isTabletOrMobile()) {
                        discoveryFeed.style.pointerEvents = 'none'; // Make it non-interactive
                        discoveryFeed.style.userSelect = 'none';
                    }
                }
            }
            
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('resize', handleOrientationChange);
            handleOrientationChange(); // Initial check
            
            // Initialize discovery feed gradients
            function initDiscoveryFeedGradients() {
                const discoveryFeed = document.querySelector('.discovery-feed');
                if (!discoveryFeed) return;
                
                if (isTabletOrMobile()) {
                    // Lighter gradients for mobile
                    discoveryFeed.classList.add('mobile-gradient');
                } else {
                    // Desktop gradients with hover effects
                    discoveryFeed.classList.add('desktop-gradient');
                    
                    // Add interactive fade on mouse proximity
                    document.addEventListener('mousemove', (e) => {
                        const rect = discoveryFeed.getBoundingClientRect();
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - rect.left, 2) + 
                            Math.pow(e.clientY - (rect.top + rect.height/2), 2)
                        );
                        
                        if (distance < 300) {
                            discoveryFeed.classList.add('fading');
                        } else {
                            discoveryFeed.classList.remove('fading');
                        }
                    });
                }
            }
            
            // Call gradient initialization
            initDiscoveryFeedGradients();
            
            // Apply mobile optimizations
            if (isTabletOrMobile() && window.mobileUIManager) {
                window.mobileUIManager.applyMobileOptimizations();
            }
            
            // Ensure leaderboard is tappable on mobile
            const leaderboardBox = document.querySelector('.leaderboard-box');
            if (leaderboardBox && isTabletOrMobile()) {
                leaderboardBox.style.cursor = 'pointer';
                
                // Use touch events for better mobile response
                let touchStartTime;
                leaderboardBox.addEventListener('touchstart', function(e) {
                    touchStartTime = Date.now();
                });
                
                leaderboardBox.addEventListener('touchend', function(e) {
                    const touchDuration = Date.now() - touchStartTime;
                    if (touchDuration < 200) { // Quick tap
                        e.preventDefault();
                        this.classList.toggle('collapsed');
                        localStorage.setItem('leaderboardCollapsed', this.classList.contains('collapsed'));
                    }
                });
                
                // Restore collapsed state from localStorage
                if (localStorage.getItem('leaderboardCollapsed') === 'true') {
                    leaderboardBox.classList.add('collapsed');
                }
            }
        });
        
        // Initialize
        Promise.all([loadElements(), loadSnakeNames()]).then(() => {
            
            // Sync discovered elements from new system if available
            if (window.elementLoader && window.elementCompatibility) {
                // Load previously discovered elements
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                if (savedDiscovered && savedDiscovered.size > 0) {
                    // Merge with existing discovered elements
                    for (const elementKey of savedDiscovered) {
                        discoveredElements.add(elementKey);
                    }
                }
            }
            
            // Load skin data
            loadSkinData();
            preloadSkins();
            
            // Expose skin functions to window for UnlockManager access
            window.loadSkinData = loadSkinData;
            window.saveSkinData = saveSkinData;
            window.skinMetadata = skinMetadata;
            window.unlockedSkins = unlockedSkins;
            
            // Sync with UnlockManager's unlocked skins
            if (window.unlockManager) {
                const unlockManagerSkins = window.unlockManager.getUnlockedSkins();
                for (const skinId of unlockManagerSkins) {
                    // Add to main game's unlockedSkins set
                    unlockedSkins.add(skinId);
                    
                    // Also add the old ID if it exists
                    if (window.skinIdConverter) {
                        const oldId = window.skinIdConverter.toOldId(skinId);
                        if (oldId && oldId !== skinId) {
                            unlockedSkins.add(oldId);
                        }
                    }
                }
                
                // Save and reload to ensure consistency
                saveSkinData();
                loadSkinData();
            }
            
            // Load all-time discoveries
            loadAllTimeDiscoveries();
            
            // Initialize mobile controls if needed
            initMobileControls();
        });
        
        // Persistent stars animation for all screens
        document.addEventListener('DOMContentLoaded', function() {
            const persistentCanvas = document.getElementById('persistentStarsCanvas');
            const ctx = persistentCanvas.getContext('2d');
            
            // Resize canvas
            function resizeCanvas() {
                persistentCanvas.width = window.innerWidth;
                persistentCanvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Stars array (shared between both screens)
            const stars = [];
            const shootingStars = [];
            let lastShootingStarTime = 0;
            
            // Initialize stars
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            
            // Shooting star class for splash
            class SplashShootingStar {
                constructor() {
                    // Start from screen edge
                    const edge = Math.floor(Math.random() * 4);
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    switch(edge) {
                        case 0: // Top
                            this.x = Math.random() * width;
                            this.y = -10;
                            break;
                        case 1: // Right
                            this.x = width + 10;
                            this.y = Math.random() * height;
                            break;
                        case 2: // Bottom
                            this.x = Math.random() * width;
                            this.y = height + 10;
                            break;
                        case 3: // Left
                            this.x = -10;
                            this.y = Math.random() * height;
                            break;
                    }
                    
                    // Aim towards screen center area
                    const targetX = width * (0.3 + Math.random() * 0.4);
                    const targetY = height * (0.3 + Math.random() * 0.4);
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    const speed = 3 + Math.random() * 2;
                    
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.trail = [];
                    this.maxTrailLength = 30;
                    this.life = 1.0;
                }
                
                update() {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.01;
                    
                    return this.life > 0 && this.x > -50 && this.x < window.innerWidth + 50 && 
                           this.y > -50 && this.y < window.innerHeight + 50;
                }
                
                draw(ctx) {
                    // Draw trail
                    ctx.save();
                    this.trail.forEach((point, index) => {
                        const alpha = (index / this.trail.length) * this.life * 0.3;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ffffff';
                        const size = (index / this.trail.length) * 2;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw star
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Animation loop
            function animateStars(timestamp) {
                // Clear canvas
                ctx.clearRect(0, 0, persistentCanvas.width, persistentCanvas.height);
                
                // Draw static stars with twinkling
                stars.forEach(star => {
                    star.opacity += Math.sin(timestamp * star.twinkleSpeed) * 0.05;
                    star.opacity = Math.max(0.1, Math.min(0.8, star.opacity));
                    
                    ctx.globalAlpha = star.opacity;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Update and draw shooting stars
                shootingStars.forEach((star, index) => {
                    if (!star.update()) {
                        shootingStars.splice(index, 1);
                    } else {
                        star.draw(ctx);
                    }
                });
                
                // Spawn new shooting star occasionally
                if (timestamp - lastShootingStarTime > 3000 + Math.random() * 4000) {
                    shootingStars.push(new SplashShootingStar());
                    lastShootingStarTime = timestamp;
                }
                
                ctx.globalAlpha = 1;
                requestAnimationFrame(animateStars);
            }
            
            // Start animation
            requestAnimationFrame(animateStars);
        });
        
        // Try to play music on first user interaction
        document.addEventListener('click', function playMusicOnInteraction() {
            console.log('[AUDIO] First user interaction detected');
            
            // Try to play current track if paused
            if (currentTrack && currentTrack.paused && gameStarted && !musicMuted) {
                console.log('[AUDIO] Attempting to play music on first interaction');
                currentTrack.play().then(() => {
                    console.log('[AUDIO] Music started successfully on user interaction');
                }).catch(error => {
                    console.error('[AUDIO] Failed to start music on user interaction:', error);
                });
            }
            
            // Also try pending music track if any
            if (window.pendingMusicTrack && gameStarted && !musicMuted) {
                console.log('[AUDIO] Attempting to play pending music track');
                window.pendingMusicTrack.play().then(() => {
                    console.log('[AUDIO] Pending music started successfully');
                    window.pendingMusicTrack = null;
                }).catch(error => {
                    console.error('[AUDIO] Failed to start pending music:', error);
                });
            }
        }, { once: true });
    </script>
    
    <!-- Skin Unlock System Scripts -->
    <script src="js/skinData.js"></script>
    <script src="js/skinIdMapping.js"></script>
    <script src="js/playerStats.js"></script>
    <script src="js/unlockManager.js"></script>
    <script src="js/nameGenerator.js"></script>
</body>
</html>