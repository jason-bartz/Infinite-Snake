<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Infinite Snake - Craft the Cosmos | Free Element Crafting Snake Game</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" id="Viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta property="og:description" content="Infinite Snake combines classic snake gameplay with element crafting. Discover endless combinations, unlock unique skins, and craft the cosmos in this free browser game!" />
    <meta name="keywords" content="infinite snake, snake game, element crafting, craft game, single player snake, browser game, free game, online snake, element combinations, discovery game, alchemy game, snake.io, slither.io, google snake, infinite craft snake, crafting game" />
    
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Infinite Snake - Craft the Cosmos" />
    <meta property="og:site_name" content="Infinite Snake" />
    <meta property="og:image" content="https://infinitesnake.io/assets/snake-logo.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="A snake game where you craft elements and rebuild the cosmos" />
    <meta property="og:locale" content="en_US" />
    
    <meta name="twitter:title" content="Infinite Snake - Craft the Cosmos" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="Combine elements, grow your snake, and discover endless combinations in this unique twist on the classic snake game. Free to play in your browser and mobile!">
    <meta name="twitter:image" content="https://infinitesnake.io/assets/snake-logo.png">
    
    <meta name='robots' content='index,follow' />
    <meta name="twitter:url" content="https://infinitesnake.io" />
    <meta property="og:url" content="https://infinitesnake.io" />
    <meta name="url" content="https://infinitesnake.io" />
    <link rel="canonical" href="https://infinitesnake.io">
    
    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <!-- Schema.org structured data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org/",
        "@type": "Game",
        "image": "https://infinitesnake.io/assets/snake-logo.png",
        "name": "Infinite Snake",
        "url": "https://infinitesnake.io",
        "description": "A unique snake game featuring element crafting mechanics. Combine fire, water, earth, and air to discover endless elements while growing your snake and rebuilding the cosmos.",
        "genre": "Arcade, Puzzle, Strategy, Casual",
        "gamePlatform": ["Web Browser", "Mobile Web"],
        "operatingSystem": "Any",
        "applicationCategory": "Game",
        "inLanguage": "en",
        "author": {
            "@type": "Person",
            "name": "Jason Bartz"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.6",
            "bestRating": "5",
            "ratingCount": "2847"
        }
    }
    </script>
    
    <!-- FAQ Schema -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [{
                "@type": "Question",
                "name": "What is Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake is a free browser game that combines classic snake gameplay with element crafting mechanics. Collect elements, combine them to discover new ones, and grow your snake while rebuilding the cosmos."
                }
            },
            {
                "@type": "Question",
                "name": "How do I play Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use your mouse or touchpad to guide your snake on desktop, or touch controls on mobile. Collect elemental orbs and combine them in your snake's body to discover new elements. Avoid collisions with other snakes and borders while growing larger."
                }
            },
            {
                "@type": "Question",
                "name": "Is Infinite Snake free to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is completely free to play in your web browser on both desktop and mobile. No download or installation required - just visit infinitesnake.io and start playing instantly."
                }
            },
            {
                "@type": "Question",
                "name": "How many elements can I discover in Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "There are hundreds of unique elements to discover through combinations, ranging from basic elements like fire and water to complex creations like dragons, technology, and cosmic entities. New combinations are added regularly!"
                }
            },
            {
                "@type": "Question",
                "name": "Can I play Infinite Snake on mobile?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Infinite Snake is fully optimized for mobile devices with intuitive touch controls. Simply visit infinitesnake.io on your mobile browser to play."
                }
            },
            {
                "@type": "Question",
                "name": "What makes Infinite Snake different from other snake games?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Infinite Snake uniquely combines snake gameplay with element crafting mechanics inspired by games like Little Alchemy and Infinite Craft. As you consume elements, they combine in your snake's body to create new discoveries, adding a strategic puzzle element to the classic snake formula."
                }
            },
            {
                "@type": "Question",
                "name": "Do I need to create an account to play?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "No account required! Your discoveries and progress are saved locally in your browser, allowing you to jump in and play immediately without any registration."
                }
            },
            {
                "@type": "Question",
                "name": "What are the controls for Infinite Snake?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "On desktop, use your mouse to guide your snake - it will follow your cursor. Click and hold to boost. On mobile devices, use the virtual joystick to direct your snake and the boost button to speed up. Press P to pause the game at any time on desktop."
                }
            }
        ]
    }
    </script>
    
    <!-- Additional SEO -->
    <meta name="author" content="Jason Bartz">
    <meta name="theme-color" content="#4ecdc4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Mobile optimization tags -->
    <meta name="HandheldFriendly" content="true">
    <meta name="format-detection" content="telephone=no">
    
    <!-- Alternate language versions -->
    <link rel="alternate" hreflang="en" href="https://infinitesnake.io" />
    <link rel="alternate" hreflang="x-default" href="https://infinitesnake.io" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            opacity: 1;
        }
        
        /* Splash Screen */
        #splashScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            z-index: 1000;
            transition: opacity 1s;
        }
        
        #splashStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #splashContent {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #splashScreen img {
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        #splashScreen p {
            max-width: 600px;
            text-align: center;
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
            margin: 20px;
        }
        
        #startButton {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        #startButton:hover {
            transform: scale(1.1);
        }
        
        #splashTitle {
            font-size: 60px;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: none;
        }
        
        /* Game Mode Selection */
        #gameModeSelect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            display: none;
            z-index: 50;
        }
        
        #gameModeStarsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #gameModeContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #444;
            max-width: 800px;
            width: 90%;
            z-index: 1;
        }
        
        #gameModeSelect h3 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 20px;
        }
        
        .modeSection {
            margin-bottom: 30px;
        }
        
        .modeSection h4 {
            color: #AAA;
            font-size: 18px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #gameModeSelect button {
            margin: 5px;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4B79A1, #283E51);
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            min-width: 180px;
        }
        
        #gameModeSelect button:hover {
            background: linear-gradient(135deg, #5B89B1, #384E61);
            transform: scale(1.05);
        }
        
        /* Victory Mode Layout */
        #victoryButtons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .victory-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .victory-column h5 {
            color: #FFD700;
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .victory-infinite {
            grid-column: span 2;
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        /* Discovery Mode Buttons */
        .btn-discovery {
            background: linear-gradient(135deg, #2E7D32, #1B5E20) !important;
            border: 1px solid #4CAF50 !important;
        }
        
        .btn-discovery:hover {
            background: linear-gradient(135deg, #388E3C, #2E7D32) !important;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        
        /* Points Mode Buttons */
        .btn-points {
            background: linear-gradient(135deg, #D32F2F, #B71C1C) !important;
            border: 1px solid #F44336 !important;
        }
        
        .btn-points:hover {
            background: linear-gradient(135deg, #E53935, #D32F2F) !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.5);
        }
        
        /* Infinite Mode Button */
        .btn-infinite {
            background: linear-gradient(135deg, #7B1FA2, #4A148C) !important;
            border: 1px solid #9C27B0 !important;
            min-width: 250px !important;
            font-size: 18px !important;
            padding: 15px 30px !important;
        }
        
        .btn-infinite:hover {
            background: linear-gradient(135deg, #8E24AA, #6A1B9A) !important;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.6);
        }
        
        #loadingIndicator {
            display: none;
            margin: 10px 0;
            color: #FFD700;
            font-size: 14px;
        }
        
        /* Canvas */
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Discovery Sidebar */
        #discoveryLog {
            display: none; /* Hidden - replaced by discovery feed */
        }
        
        #discoveryLog h3 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #FFD700;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        
        .discovery-item {
            margin: 8px 0;
            font-size: 14px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s;
        }
        
        .discovery-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }
        
        .discovery-item .emoji {
            font-size: 24px;
        }
        
        .discovery-item .info {
            flex: 1;
        }
        
        .discovery-item .name {
            font-weight: bold;
            color: white;
        }
        
        .discovery-item .tier {
            font-size: 11px;
            color: #AAA;
        }
        
        .discovery-item.new {
            animation: newItemGlow 2s ease-out;
            background: rgba(255, 215, 0, 0.2);
        }
        
        @keyframes newItemGlow {
            0% {
                background: rgba(255, 215, 0, 0.5);
                transform: translateX(10px);
            }
            100% {
                background: rgba(255, 215, 0, 0.2);
                transform: translateX(0);
            }
        }
        
        /* Main UI overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #score {
            display: none; /* Hidden - score shown in leaderboard */
        }
        
        #discoveries {
            display: none; /* Hidden - discoveries shown in sidebar */
        }
        
        /* Bottom UI Bar (MMO-style) */
        .bottom-ui {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: auto;
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.7) 10%,
                rgba(10, 10, 26, 0.95) 30%,
                rgba(10, 10, 26, 0.98) 100%
            );
            padding-top: 20px;
            border-top: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 -10px 30px rgba(138, 43, 226, 0.2);
        }
        
        /* Element Collection Bar (Skill Bar Style) */
        .element-collection-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
            margin-bottom: 10px;
            gap: 4px;
        }
        
        .element-slot {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.9) 0%,
                rgba(30, 30, 50, 0.8) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.4);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .element-slot.empty {
            background: linear-gradient(135deg, 
                rgba(10, 10, 20, 0.6) 0%,
                rgba(20, 20, 30, 0.5) 100%
            );
            border-color: rgba(100, 100, 120, 0.3);
            border-style: dashed;
        }
        
        .element-slot.filled {
            background: linear-gradient(135deg, 
                rgba(40, 40, 60, 0.9) 0%,
                rgba(50, 50, 70, 0.8) 100%
            );
            border-color: rgba(138, 43, 226, 0.6);
        }
        
        .element-slot.tail-element {
            border-color: #FFD700;
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5),
                       inset 0 0 10px rgba(255, 215, 0, 0.2);
            animation: tailPulse 2s ease-in-out infinite;
        }
        
        @keyframes tailPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .element-slot:hover:not(.empty) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4),
                       inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .element-slot .emoji {
            font-size: 28px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }
        
        .element-slot .element-name {
            font-size: 9px;
            color: #AAA;
            text-align: center;
            margin-top: 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Boost Bar (Mana Bar Style) */
        .boost-bar-container {
            width: 60%;
            max-width: 800px;
            margin: 0 auto 15px;
            padding: 0 20px;
        }
        
        .boost-bar-frame {
            height: 24px;
            background: linear-gradient(to bottom, 
                rgba(0, 0, 0, 0.8) 0%,
                rgba(10, 10, 20, 0.9) 100%
            );
            border: 2px solid rgba(100, 100, 120, 0.5);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.8);
        }
        
        .boost-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, 
                #00a8ff 0%,
                #00d4ff 50%,
                #00a8ff 100%
            );
            background-size: 200% 100%;
            position: relative;
            animation: boostShimmer 3s linear infinite;
        }
        
        @keyframes boostShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .boost-bar-fill.low {
            background: linear-gradient(90deg, #ff4444, #ff6666);
            animation: none;
        }
        
        .boost-bar-fill.boosting {
            background: linear-gradient(90deg, #44ff44, #66ff66);
            animation: boostShimmer 1s linear infinite;
        }
        
        .boost-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            color: white;
        }
        
        #elementQueue {
            display: none; /* Hidden - replaced by bottom element bar */
        }
        
        .element-square {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            padding: 2px;
        }
        
        .element-square .element-name {
            font-size: 7px;
            color: #AAA;
            text-align: center;
            margin-top: 2px;
            line-height: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 46px;
        }
        
        .element-square.empty {
            background: rgba(255,255,255,0.05);
            border: 1px dashed rgba(255,255,255,0.1);
        }
        
        .element-square.filled {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .element-square.tail-element {
            border: 2px solid #FFD700;
            background: rgba(255,215,0,0.1);
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
            animation: tailGlow 2s ease-in-out infinite;
        }
        
        @keyframes tailGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255,215,0,0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(255,215,0,0.8);
            }
        }
        
        .element-square:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        /* Message Popups (Over Element Bar) */
        #recentDiscovery {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, 
                rgba(255, 215, 0, 0.95) 0%,
                rgba(255, 140, 0, 0.95) 100%
            );
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 3px solid #FFD700;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 
                       inset 0 0 20px rgba(255, 255, 255, 0.2);
            opacity: 0;
            transition: all 0.5s;
            animation: none;
            z-index: 25;
        }
        
        #recentDiscovery.show {
            animation: popupBounce 0.5s ease-out;
        }
        
        /* Mobile popup adjustments */
        body.mobile #recentDiscovery {
            bottom: 120px;
            font-size: 14px;
            padding: 10px 20px;
            max-width: 80%;
        }
        
        @keyframes popupBounce {
            0% {
                transform: translateX(-50%) scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) scale(1.1) rotate(5deg);
            }
            100% {
                transform: translateX(-50%) scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        #recentDiscovery.combo {
            background: linear-gradient(135deg, 
                rgba(78, 205, 196, 0.95) 0%,
                rgba(69, 183, 170, 0.95) 100%
            );
            border-color: #4ecdc4;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.8), 
                       inset 0 0 20px rgba(255, 255, 255, 0.2);
        }
        
        #recentDiscovery small {
            display: block;
            margin-top: 5px;
            font-size: 14px;
            font-weight: normal;
            font-style: italic;
            opacity: 0.9;
        }
        
        /* Player Info Box (Bottom Left) */
        .player-info-box {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 280px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 30, 50, 0.9) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 10px;
            padding: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .player-info-header {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .player-portrait {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, 
                rgba(40, 40, 60, 0.9) 0%,
                rgba(50, 50, 70, 0.8) 100%
            );
            border: 2px solid #FFD700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .player-portrait img {
            width: 56px;
            height: 56px;
            image-rendering: pixelated;
        }
        
        .player-stats {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
        }
        
        .stat-line {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        
        .stat-label {
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }
        
        /* Leaderboard (Bottom Right) */
        .leaderboard-box {
            position: absolute;
            bottom: 120px;
            right: 20px;
            width: 280px;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 30, 50, 0.9) 100%
            );
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 10px;
            padding: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .leaderboard-header {
            font-size: 16px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }
        
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .leaderboard-entry:hover {
            background: rgba(138, 43, 226, 0.2);
            transform: translateX(4px);
        }
        
        .leaderboard-entry.leader {
            background: linear-gradient(90deg, 
                rgba(255, 215, 0, 0.2) 0%,
                rgba(255, 215, 0, 0.1) 100%
            );
            border-left: 3px solid #FFD700;
        }
        
        .leaderboard-entry.player {
            background: linear-gradient(90deg, 
                rgba(78, 205, 196, 0.2) 0%,
                rgba(78, 205, 196, 0.1) 100%
            );
            border-left: 3px solid #4ecdc4;
        }
        
        .leaderboard-name {
            flex: 1;
            font-weight: bold;
        }
        
        .leaderboard-stats {
            text-align: right;
            font-size: 11px;
            color: #AAA;
        }
        
        /* Discovery Feed (Left Side Chat-style) */
        .discovery-feed {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 300px;
            max-height: 60vh;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            overflow: hidden;
        }
        
        .discovery-feed-inner {
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(138, 43, 226, 0.3) transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar {
            width: 4px;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .discovery-feed-inner::-webkit-scrollbar-thumb {
            background: rgba(138, 43, 226, 0.3);
            border-radius: 2px;
        }
        
        .discovery-message {
            background: linear-gradient(90deg, 
                rgba(20, 20, 40, 0.8) 0%,
                rgba(20, 20, 40, 0.4) 80%,
                transparent 100%
            );
            border-left: 3px solid #FFD700;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 0 8px 8px 0;
            font-size: 14px;
            animation: slideInLeft 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .discovery-message .emoji {
            font-size: 20px;
        }
        
        .discovery-message .discovery-text {
            flex: 1;
        }
        
        .discovery-message .discovery-name {
            color: #FFD700;
            font-weight: bold;
        }
        
        .discovery-message .discovery-combo {
            font-size: 12px;
            color: #AAA;
            margin-top: 2px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            pointer-events: none;
            z-index: 50;
        }
        
        body.mobile .mobile-controls {
            display: block;
        }
        
        .virtual-joystick {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            transition: none;
            transform: translate(-50%, -50%);
            left: 50%;
            top: 50%;
        }
        
        .boost-button {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            background: rgba(78, 205, 196, 0.3);
            border: 3px solid #4ecdc4;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .boost-button.active {
            background: rgba(78, 205, 196, 0.6);
            transform: scale(0.95);
        }
        
        .pause-button-mobile {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .mute-button-mobile {
            position: absolute;
            top: 20px;
            right: 80px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        /* Mobile UI Inversions */
        body.mobile .bottom-ui {
            top: 0;
            bottom: auto;
            padding-bottom: 20px;
            padding-top: 20px;
            border-top: none;
            border-bottom: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.2);
            background: linear-gradient(to top, 
                rgba(0, 0, 0, 0) 0%,
                rgba(0, 0, 0, 0.7) 10%,
                rgba(10, 10, 26, 0.95) 30%,
                rgba(10, 10, 26, 0.98) 100%
            );
        }
        
        body.mobile .player-info-box {
            display: none; /* Hide entirely on mobile */
        }
        
        body.mobile .leaderboard-box {
            top: 100px;
            bottom: auto;
            right: 10px;
            width: 180px;
            background: rgba(20, 20, 40, 0.6);
            padding: 8px;
            font-size: 11px;
        }
        
        body.mobile .leaderboard-header {
            font-size: 13px;
            margin-bottom: 5px;
        }
        
        body.mobile .leaderboard-entry {
            padding: 4px 6px;
            margin: 2px 0;
            font-size: 11px;
        }
        
        body.mobile .leaderboard-stats {
            font-size: 9px;
        }
        
        body.mobile .discovery-feed {
            top: 50%;
            transform: translateY(-50%);
        }
        
        body.mobile .message-popup {
            top: auto;
            bottom: 220px;
            font-size: 14px;
            padding: 8px 16px;
            border-radius: 6px;
            border-width: 2px;
        }
        
        body.mobile #pauseText,
        body.mobile #fpsCounter {
            top: 170px;
        }
        
        /* Touch-specific optimizations */
        body.mobile {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body.mobile .desktop-only {
            display: none;
        }
        
        /* Mobile splash screen adjustments */
        @media (max-width: 800px) and (orientation: landscape) {
            #splashContent {
                padding: 10px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            #splashLogo {
                width: 150px !important;
                max-width: 150px !important;
                margin-bottom: 5px !important;
            }
            
            #splashScreen p {
                font-size: 11px;
                margin: 5px;
                line-height: 1.3;
                max-height: 80px;
                overflow-y: auto;
            }
            
            #startButton {
                margin-top: 5px;
                margin-bottom: 5px;
                padding: 6px 20px;
                font-size: 14px;
            }
            
            #splashTitle {
                font-size: 24px;
                margin-bottom: 5px;
            }
        }
        
        /* Portrait mobile adjustments */
        @media (max-width: 600px) and (orientation: portrait) {
            #splashScreen img {
                width: 300px !important;
            }
            
            #splashScreen p {
                font-size: 16px;
            }
        }
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .player-info-box,
            .leaderboard-box {
                width: 240px;
                font-size: 12px;
            }
            
            .element-slot {
                width: 48px;
                height: 48px;
            }
            
            .element-slot .emoji {
                font-size: 24px;
            }
            
            .discovery-feed {
                width: 250px;
            }
        }
        
        @media (max-width: 800px) {
            .player-info-box,
            .leaderboard-box {
                bottom: 100px;
                width: 200px;
            }
            
            body.mobile .player-info-box,
            body.mobile .leaderboard-box {
                top: 100px;
            }
            
            .discovery-feed {
                display: none; /* Hide on mobile */
            }
            
            .element-slot {
                width: 42px;
                height: 42px;
            }
            
            .boost-bar-container {
                width: 80%;
            }
            
            .virtual-joystick {
                width: 100px;
                height: 100px;
                left: 20px;
                bottom: 20px;
            }
            
            .boost-button {
                width: 70px;
                height: 70px;
                right: 20px;
                bottom: 20px;
                font-size: 14px;
            }
            
            .joystick-knob {
                width: 40px;
                height: 40px;
            }
        }
        
        /* Victory Overlay */
        #victoryOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #victoryPopup {
            position: relative;
            background: linear-gradient(135deg, 
                rgba(20, 20, 40, 0.98) 0%,
                rgba(40, 20, 60, 0.98) 100%
            );
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            border: 3px solid #FFD700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5),
                       inset 0 0 30px rgba(255, 215, 0, 0.1);
            animation: victoryPulse 2s ease-in-out infinite;
        }
        
        @keyframes victoryPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 50px rgba(255, 215, 0, 0.5),
                           inset 0 0 30px rgba(255, 215, 0, 0.1);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 80px rgba(255, 215, 0, 0.7),
                           inset 0 0 40px rgba(255, 215, 0, 0.2);
            }
        }
        
        .victory-glow {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, 
                rgba(255, 215, 0, 0.2) 0%,
                transparent 70%
            );
            animation: rotate 20s linear infinite;
            pointer-events: none;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .victory-title {
            font-size: 48px;
            color: #FFD700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: victoryShine 2s ease-in-out infinite;
        }
        
        @keyframes victoryShine {
            0%, 100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { text-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }
        
        .victory-lore {
            font-size: 20px;
            color: #DDD;
            margin: 20px 0 30px;
            line-height: 1.6;
            font-style: italic;
        }
        
        .victory-stats {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 30px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #AAA;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .victory-button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
        }
        
        .victory-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(255, 215, 0, 0.5);
        }
        
        /* Mobile adjustments for victory popup */
        @media (max-width: 600px) {
            #victoryPopup {
                padding: 30px;
            }
            
            .victory-title {
                font-size: 36px;
            }
            
            .victory-lore {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 14px;
            }
            
            .stat-value {
                font-size: 20px;
            }
        }
        
        /* Pause Menu */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #pauseMenu {
            background: rgba(20,20,40,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            width: 900px;
            height: 700px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid rgba(138, 43, 226, 0.3);
            padding-bottom: 10px;
        }
        
        .tab-button {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 10px 10px 0 0;
            color: #AAA;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .tab-button:hover {
            background: rgba(138, 43, 226, 0.2);
            color: white;
        }
        
        .tab-button.active {
            background: rgba(138, 43, 226, 0.4);
            color: #FFD700;
            border-bottom: 2px solid #FFD700;
            transform: translateY(2px);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        
        .tab-content.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Discovery Journal */
        #discoveryJournal {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        
        .discovery-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-top: 20px;
            flex: 1;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
            max-width: 100%;
            min-height: 0;
        }
        
        .discovery-item {
            background: rgba(40, 40, 60, 0.6);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 5px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .discovery-item:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }
        
        
        .discovery-item .element-symbol {
            font-size: 20px;
            margin-bottom: 3px;
        }
        
        .discovery-item .element-name {
            font-size: 10px;
            color: #FFD700;
            word-break: break-word;
            line-height: 1.2;
        }
        
        
        /* How to Play Section */
        .howToPlay {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            text-align: left;
            font-size: 14px;
            color: #CCC;
            line-height: 1.6;
        }
        
        .howToPlay h5 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .howToPlay ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .howToPlay li {
            margin-bottom: 5px;
        }
        
        .howToPlay strong {
            color: #FFD700;
        }
        
        /* Skin Selection */
        #skinSelection {
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        #skinSelection h4 {
            color: #FFD700;
            margin-bottom: 10px;
            text-align: center;
        }
        
        #availableUnlocks {
            text-align: center;
            color: #4ecdc4;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        #skinGrid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin-top: 15px;
            flex: 1;
            align-content: start;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .skin-item {
            position: relative;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .skin-item:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }
        
        .skin-item.current {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .skin-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .skin-item.locked:hover {
            transform: none;
        }
        
        .skin-item.unlockable {
            border-color: #4ecdc4;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px #4ecdc4; }
            50% { box-shadow: 0 0 20px #4ecdc4, 0 0 30px #4ecdc4; }
        }
        
        .skin-image {
            width: 100%;
            height: 100%;
            max-width: 60px;
            max-height: 60px;
            margin: 0 auto 3px;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            object-fit: contain;
        }
        
        .skin-name {
            font-size: 10px;
            color: #CCC;
            margin-top: 3px;
            line-height: 1.2;
        }
        
        .skin-unlock-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
        }
    </style>
    <!-- New Element System Scripts -->
    <script src="elements/element-loader.js"></script>
    <script src="elements/compatibility-layer.js"></script>
    <script src="elements/integrate.js"></script>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen">
        <canvas id="splashStarsCanvas"></canvas>
        <div id="splashContent">
            <img src="assets/word-logo.webp" alt="Infinite Snake" id="splashLogo" style="width: 400px; max-width: 80%; margin-bottom: 30px;" onerror="this.style.display='none'; document.getElementById('splashTitle').style.display='block';">
            <h1 id="splashTitle">Infinite Snake</h1>
            <p>Reality has shattered. The elements of creation are scattered across the void.<br><br>
            You are the Infinite Snake - an ancient being born from chaos. Consume these fragments. Combine them within your endless serpentine coils. Forge new existence.<br><br>
            From fire and water to stars and civilizations, rebuild the Cosmos itself. The universe awaits.</p>
            <button id="startButton">Begin Your Journey</button>
        </div>
    </div>
    
    <!-- Game Mode Selection -->
    <div id="gameModeSelect">
        <canvas id="gameModeStarsCanvas"></canvas>
        <div id="gameModeContent">
            <h3>Game Setup</h3>
        
        <div class="modeSection">
            <h4>Victory Condition</h4>
            <div id="victoryButtons">
                <div class="victory-column">
                    <h5> Discovery Race</h5>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 100)">Discover 100 Elements</button>
                    <button class="btn-discovery" onclick="selectVictoryMode('discovery', 500)">Discover 500 Elements</button>
                </div>
                <div class="victory-column">
                    <h5> Points Race</h5>
                    <button class="btn-points" onclick="selectVictoryMode('points', 50000)">Score 50,000 Points</button>
                    <button class="btn-points" onclick="selectVictoryMode('points', 250000)">Score 250,000 Points</button>
                </div>
                <div class="victory-infinite">
                    <button class="btn-infinite" onclick="selectVictoryMode('infinite', 0)"> Infinite Mode</button>
                </div>
            </div>
        </div>
        </div>
    </div>
    
    <!-- Discovery Sidebar -->
    <div id="discoveryLog">
        <h3>Discoveries (0)</h3>
        <div id="discoveryList"></div>
    </div>
    
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div id="ui">
        <div id="recentDiscovery"></div>
        <div id="score">Score: 0</div>
        <div id="discoveries">Discoveries: 0</div>
        <div id="elementQueue"></div>
        
        <!-- Discovery Feed (Left Side) -->
        <div class="discovery-feed">
            <div class="discovery-feed-inner" id="discoveryFeed"></div>
        </div>
        
        <!-- Bottom UI Container -->
        <div class="bottom-ui">
            <!-- Element Collection Bar -->
            <div class="element-collection-bar" id="elementBar"></div>
            
            <!-- Boost Bar -->
            <div class="boost-bar-container">
                <div class="boost-bar-frame">
                    <div class="boost-bar-fill" id="boostBarFill" style="width: 100%"></div>
                    <div class="boost-bar-text">BOOST</div>
                </div>
            </div>
        </div>
        
        <!-- Alchemy Vision Timer (Above Player Info) -->
        <div id="alchemyVisionTimer" style="display: none; position: absolute; bottom: 220px; left: 20px; width: 280px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 140, 0, 0.2) 100%); border: 2px solid #FFD700; border-radius: 8px; padding: 10px; text-align: center; color: #FFD700; font-size: 18px; font-weight: bold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);">
             Alchemy Vision: <span id="alchemyTime">60</span>s
        </div>
        
        <!-- Player Info Box -->
        <div class="player-info-box">
            <div class="player-info-header">
                <div class="player-portrait">
                    <img id="playerPortrait" src="skins/snake-default-green.png" alt="Player">
                </div>
                <div class="player-stats">
                    <div class="stat-line">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="playerScore">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Discoveries</span>
                        <span class="stat-value" id="playerDiscoveries">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Best Rank</span>
                        <span class="stat-value" id="playerBestRank">-</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Kills</span>
                        <span class="stat-value" id="playerKills">0</span>
                    </div>
                    <div class="stat-line">
                        <span class="stat-label">Time</span>
                        <span class="stat-value" id="playerTime">0:00</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Leaderboard Box -->
        <div class="leaderboard-box">
            <div class="leaderboard-header">Leaderboard</div>
            <div id="leaderboardList"></div>
        </div>
        
        <!-- UI Info (Top Right) -->
        <div id="pauseText" style="position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; color: rgba(255, 255, 255, 0.4); pointer-events: none;">
            <div style="margin-bottom: 5px;" class="desktop-only">Press P for Pause Menu</div>
            <div style="margin-bottom: 5px;" class="desktop-only" id="muteText">M to Mute</div>
            <div id="fpsCounter">FPS: --</div>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="virtual-joystick" id="virtualJoystick">
            <div class="joystick-base">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
        </div>
        <div class="boost-button" id="boostButton">BOOST</div>
        <div class="pause-button-mobile" id="pauseButtonMobile" onclick="togglePause()"></div>
        <div class="mute-button-mobile" id="muteButtonMobile" onclick="toggleMusic()"></div>
    </div>
    
    <!-- Victory Overlay -->
    <div id="victoryOverlay" style="display: none;">
        <div id="victoryPopup">
            <div class="victory-glow"></div>
            <h1 class="victory-title"> Victory! </h1>
            <div class="victory-lore" id="victoryLore"></div>
            <div class="victory-stats">
                <div class="stat-item">
                    <span class="stat-label">Final Score</span>
                    <span class="stat-value" id="victoryScore">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Elements Discovered</span>
                    <span class="stat-value" id="victoryDiscoveries">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time to Complete</span>
                    <span class="stat-value" id="victoryTime">0:00</span>
                </div>
            </div>
            <button class="victory-button" onclick="location.reload()">Play Again</button>
        </div>
    </div>
    
    <!-- Pause Overlay -->
    <div id="pauseOverlay">
        <div id="pauseMenu">
            <h2>Game Paused</h2>
            <p style="color: #AAA; font-size: 14px; margin: 10px 0;">High Score: <span style="color: #FFD700;" id="highScoreDisplay">0</span></p>
            
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('skins')">Skins</button>
                <button class="tab-button" onclick="switchTab('journal')">Discovery Journal</button>
            </div>
            
            <!-- Skins Tab -->
            <div id="skinsTab" class="tab-content active">
                <div id="skinSelection">
                    <h4>Snake Skins</h4>
                    <div id="availableUnlocks">Available Unlocks: 0</div>
                    <div id="skinGrid"></div>
                </div>
            </div>
            
            <!-- Discovery Journal Tab -->
            <div id="journalTab" class="tab-content">
                <div id="discoveryJournal">
                    <h4 style="color: #FFD700; margin-bottom: 10px;">Discovery Journal</h4>
                    <div class="discovery-grid" id="discoveryGrid">
                        <!-- Discoveries will be populated here -->
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(138, 43, 226, 0.3);">
                <button onclick="resumeGame()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #4ecdc4; color: white; border: none; border-radius: 10px; cursor: pointer;">Resume</button>
                <button onclick="location.reload()" style="margin: 10px; padding: 10px 30px; font-size: 18px; background: #ff6b6b; color: white; border: none; border-radius: 10px; cursor: pointer;">New Game</button>
            </div>
        </div>
    </div>
    
    <script>
        // Mobile detection (needs to be before canvas setup)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                        || ('ontouchstart' in window && navigator.maxTouchPoints > 0);
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Emoji cache for performance
        const emojiCache = new Map();
        const MAX_CACHE_SIZE = 200; // Limit cache size
        
        function getCachedEmoji(emoji, size) {
            // Ensure size is valid
            const validSize = Math.max(1, Math.round(size) || 20);
            const key = `${emoji}_${validSize}`;
            
            if (emojiCache.has(key)) {
                return emojiCache.get(key);
            }
            
            // Create offscreen canvas
            const offscreenCanvas = document.createElement('canvas');
            const padding = 4; // Small padding for emoji rendering
            offscreenCanvas.width = validSize + padding * 2;
            offscreenCanvas.height = validSize + padding * 2;
            const offscreenCtx = offscreenCanvas.getContext('2d');
            
            // Draw emoji to offscreen canvas
            offscreenCtx.font = `${validSize}px Arial`;
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle';
            offscreenCtx.fillStyle = 'black';
            offscreenCtx.fillText(emoji, offscreenCanvas.width / 2, offscreenCanvas.height / 2);
            
            // Store in cache
            emojiCache.set(key, offscreenCanvas);
            
            // Clean up old entries if cache is too large
            if (emojiCache.size > MAX_CACHE_SIZE) {
                const firstKey = emojiCache.keys().next().value;
                emojiCache.delete(firstKey);
            }
            
            return offscreenCanvas;
        }
        
        // Make canvas fit full window
        function resizeCanvas() {
            // Use lower resolution on mobile for better performance
            const scale = isMobile ? 0.8 : 1;
            canvas.width = window.innerWidth * scale;
            canvas.height = window.innerHeight * scale;
            
            if (isMobile) {
                // Scale canvas to full size with CSS
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
            }
            
            // Clear emoji cache on resize as sizes might change
            emojiCache.clear();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game constants
        const WORLD_SIZE = 4000;
        const SEGMENT_SIZE = 15;
        const SNAKE_SPEED = 3.3; // Increased by 10%
        const TURN_SPEED = 0.08;
        const ELEMENT_SIZE = 20;
        
        // Viewport culling helper
        function isInViewport(x, y, margin = 100) {
            const screenX = x - camera.x + canvas.width / 2;
            const screenY = y - camera.y + canvas.height / 2;
            
            return screenX >= -margin && 
                   screenX <= canvas.width + margin && 
                   screenY >= -margin && 
                   screenY <= canvas.height + margin;
        }
        
        // Game state
        let gameStarted = false;
        let paused = false;
        let controlScheme = 'arrows';
        let gameMode = 'infinite'; // 'discovery', 'points', or 'infinite'
        let gameTarget = 0; // Target value for victory
        let camera = { x: WORLD_SIZE / 2, y: WORLD_SIZE / 2 };
        
        // Game loop timing variables
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 0;
        let accumulator = 0;
        let playerSnake = null;
        let snakes = [];
        let lastDiscoveredElement = null;
        let highScore = parseInt(localStorage.getItem('highScore') || '0');
        let gameStartTime = Date.now();
        let bestRank = 0;
        
        // Alchemy Vision power-up
        let alchemyVisionPowerUps = [];
        let alchemyVisionActive = false;
        let alchemyVisionTimer = 0;
        let lastAlchemyVisionSpawn = 0;
        const ALCHEMY_VISION_DURATION = 30000; // 30 seconds
        const ALCHEMY_VISION_SPAWN_INTERVAL = 120000; // 2 minutes
        const ALCHEMY_VISION_SPAWN_COUNT = 3; // Number of power-ups to spawn at once
        
        // Void Orb mechanic
        let voidOrbs = [];
        let lastVoidOrbSpawn = 0;
        const VOID_ORB_SPAWN_INTERVAL = 60000; // 60 seconds
        const VOID_ORB_SPAWN_COUNT = 4; // Number of void orbs to maintain on map
        
        // Catalyst Gem mechanic
        let catalystGems = [];
        let lastCatalystGemSpawn = 0;
        const CATALYST_GEM_SPAWN_INTERVAL = 90000; // 90 seconds (more rare than void orbs)
        const CATALYST_GEM_SPAWN_COUNT = 3; // Number of catalyst gems to maintain on map
        let catalystSpawnedElements = []; // Track elements spawned by catalyst for visual effect
        
        // Space effects
        let staticStars = [];
        let shootingStars = [];
        let lastShootingStarTime = 0;
        
        // Nebula border effect variables
        let borderParticles = [];
        let animationTime = 0;
        const MAX_BORDER_PARTICLES = isMobile ? 50 : 150; // Reduced for mobile
        
        // Element database
        let elementDatabase = {};
        let combinations = {};
        let discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
        
        // All-time discoveries (persistent across sessions)
        let allTimeDiscoveries = new Map(); // Map of element -> recipe
        
        // Snake names data
        let snakeNameData = null;
        
        // Skin system
        const skinMetadata = {
            'snake-default-green': { name: 'Basic Boy', unlocked: true, colors: ['#75d18e', '#6abf81'] },
            'neko': { name: 'Lil Beans (Beta Perk)', unlocked: true, colors: ['#c6c6cb', '#c3c3e7'] },
            '35mm': { name: 'Ansel 35', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'Frank': { name: 'Franklin', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'af-one': { name: "Scuffy", unlocked: false, colors: ['#e74c3c', '#e23b28'] },
            'barbi': { name: 'Margot', unlocked: false, colors: ['#ff69b4', '#ff1493'] },
            'boat-mcboatface': { name: 'Boaty McBoatface', unlocked: false, colors: ['#3498db', '#2980b9'] },
            'camera-guy': { name: 'The Resistance', unlocked: false, colors: ['#2c3e50', '#1a1a1a'] },
            'coffee': { name: 'Caffeine Fiend', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'controller': { name: 'Little Bro', unlocked: false, colors: ['#9b59b6', '#8e44ad'] },
            'diet-cola': { name: 'Cola Crusader', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'dog': { name: 'Good Boy', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'donut': { name: 'Sprinkles', unlocked: false, colors: ['#daa520', '#ff69b4'] },
            'flame': { name: 'Hot Head', unlocked: false, colors: ['#ff8c00', '#ffd700'] },
            'football': { name: 'MVP', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'fries': { name: 'Sir Dips-a-lot', unlocked: false, colors: ['#e74c3c', '#ffd700'] },
            'green-dragon': { name: 'World Muncher', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'handheld-game': { name: 'The Pocketeer', unlocked: false, colors: ['#393b32', '#6a7473'] },
            'hotdog': { name: 'Big Dawg', unlocked: false, colors: ['#f8c83f', '#f8c83f'] },
            'infinity-glove': { name: 'Snappy', unlocked: false, colors: ['#6c7dcd', '#6c7dcd'] },
            'kid-car': { name: 'Speed Demon Jr.', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'lovecraft': { name: 'Eldritch Horror', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'nyan': { name: 'Pastry Cat', unlocked: false, colors: ['#e74c3c', '#ff8c00', '#ffd700', '#2ecc71', '#3498db', '#9b59b6'] },
            'pizza': { name: 'Tony Pep', unlocked: false, colors: ['#f5bf48', '#f39c12'] },
            'potato': { name: 'Spud Bud', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'racer': { name: 'Speed Demon', unlocked: false, colors: ['#1f2d35', '#e1e7ea'] },
            'ramen': { name: 'Noodle Master', unlocked: false, colors: ['#f3c33e', '#f3c33e'] },
            'red-dragon': { name: 'Ralph', unlocked: false, colors: ['#e74c3c', '#c0392b'] },
            'robot': { name: 'Metal Boi', unlocked: false, colors: ['#95a5a6', '#7f8c8d'] },
            'santa': { name: 'Ho Ho Hose', unlocked: false, colors: ['#e34c4a', '#f2ede1'] },
            'saturn': { name: 'Ring Leader', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'skibidi': { name: 'Mr. Swirley', unlocked: false, colors: ['#ecf0f1', '#bdc3c7'] },
            'snake-2': { name: 'Snek II', unlocked: false, colors: ['#78a060', '#5f804c'] },
            'space-cadet': { name: 'Cosmic Ray', unlocked: false, colors: ['#34495e', '#2c3e50'] },
            'tornado': { name: 'Whirlwind', unlocked: false, colors: ['#1790ff', '#3b9cf6'] },
            'tv': { name: 'CRT Surfer', unlocked: false, colors: ['#89b6c7', '#bedeeb'] },
            'unicorn': { name: 'Tres Commas', unlocked: false, colors: ['#ff69b4', '#ffd700'] },
            'brick-man': { name: 'The Special', unlocked: false, colors: ['#ff8c00', '#ff6347'] },
            'buffalo': { name: "Billy Blue", unlocked: false, colors: ['#3498db', '#2980b9'] },
            'clock': { name: 'Time-Out', unlocked: false, colors: ['#8b4513', '#6b3410'] },
            'floral': { name: 'Bo Kay', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'gnome': { name: 'World Traveler', unlocked: false, colors: ['#2ecc71', '#27ae60'] },
            'mac': { name: 'Woz', unlocked: false, colors: ['#f5deb3', '#e6d7c3'] },
            'murica': { name: "'Murica", unlocked: false, colors: ['#ecf0f1', '#f2eeed'] },
            'pod-player': { name: 'Poddington', unlocked: false, colors: ['#87ceeb', '#5f9ea0'] },
            'whale': { name: 'Spout', unlocked: false, colors: ['#3498db', '#2980b9'] }
        };
        
        const aiSkins = Object.keys(skinMetadata); // All skins available for AI
        let currentPlayerSkin = 'snake-default-green';
        let unlockedSkins = new Set(['snake-default-green']);
        let availableUnlocks = 0;
        let skinImages = {}; // Cache for loaded skin images
        
        // Load skin system from localStorage
        function loadSkinData() {
            const saved = localStorage.getItem('unlockedSkins');
            if (saved) {
                unlockedSkins = new Set(JSON.parse(saved));
            }
            
            const savedCurrent = localStorage.getItem('currentSkin');
            if (savedCurrent && unlockedSkins.has(savedCurrent)) {
                currentPlayerSkin = savedCurrent;
                // Update player portrait on load
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${currentPlayerSkin}.png`;
                }
            }
            
            // Update metadata
            for (const skin of unlockedSkins) {
                if (skinMetadata[skin]) {
                    skinMetadata[skin].unlocked = true;
                }
            }
        }
        
        // Save skin data
        function saveSkinData() {
            localStorage.setItem('unlockedSkins', JSON.stringify(Array.from(unlockedSkins)));
            localStorage.setItem('currentSkin', currentPlayerSkin);
        }
        
        // Preload skin images
        function preloadSkins() {
            const allSkins = Object.keys(skinMetadata).concat(aiSkins);
            allSkins.forEach(skin => {
                const img = new Image();
                img.onerror = function() {
                    console.warn(`Failed to load skin: ${skin}.png`);
                    this.error = true;
                };
                img.src = `skins/${skin}.png`;
                skinImages[skin] = img;
            });
        }
        
        // Calculate available unlocks based on high score
        function calculateAvailableUnlocks() {
            let unlocks = 0;
            if (highScore >= 50000) unlocks++;
            if (highScore >= 100000) unlocks++;
            if (highScore >= 150000) unlocks++;
            if (highScore > 150000) {
                unlocks += Math.floor((highScore - 150000) / 250000);
            }
            
            // Subtract already unlocked skins (minus the default)
            const alreadyUnlocked = unlockedSkins.size - 1;
            availableUnlocks = Math.max(0, unlocks - alreadyUnlocked);
            return availableUnlocks;
        }
        
        // Load all-time discoveries from localStorage
        function loadAllTimeDiscoveries() {
            const saved = localStorage.getItem('allTimeDiscoveries');
            if (saved) {
                const data = JSON.parse(saved);
                allTimeDiscoveries = new Map(data);
            } else {
                // Initialize with base elements
                allTimeDiscoveries.set('fire', 'Base Element');
                allTimeDiscoveries.set('water', 'Base Element');
                allTimeDiscoveries.set('earth', 'Base Element');
                allTimeDiscoveries.set('air', 'Base Element');
                saveAllTimeDiscoveries();
            }
        }
        
        // Save all-time discoveries to localStorage
        function saveAllTimeDiscoveries() {
            const data = Array.from(allTimeDiscoveries.entries());
            localStorage.setItem('allTimeDiscoveries', JSON.stringify(data));
        }
        
        // Music system
        // Background music tracks - see CREDITS.md for full attribution
        // All tracks produced by ZapSplat under Standard License
        let currentTrack = null;
        let musicVolume = 0.3;
        let musicMuted = false;
        const musicTracks = [
            'bright-white-lights.mp3',
            'last-ones-standing.mp3', 
            'good-times.mp3',
            'summer-haze.mp3',
            'on-the-up.mp3',
            'headliner.mp3'
        ];
        let availableTracks = [];
        
        
        // Input handling
        const keys = {};
        let mouseAngle = 0;
        let mouseDown = false;
        
        // Mobile detection removed - using global definition
        
        // Mobile controls state
        let joystickActive = false;
        let joystickBase = { x: 0, y: 0 };
        let joystickKnob = { x: 0, y: 0 };
        
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleMusic();
            }
            
            // Resume pending music on first interaction
            if (window.pendingMusicTrack && !musicMuted) {
                window.pendingMusicTrack.play().then(() => {
                    console.log('Music resumed after user interaction');
                }).catch(err => {
                    console.error('Failed to resume music:', err);
                });
                window.pendingMusicTrack = null;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        window.addEventListener('mousemove', (e) => {
            if (controlScheme === 'mouse' && playerSnake) {
                const rect = canvas.getBoundingClientRect();
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                mouseAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
            }
        });
        
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = true;
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = false;
            }
        });
        
        // Splash screen
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('splashScreen').style.display = 'none';
                document.getElementById('gameModeSelect').style.display = 'block';
            }, 1000);
        });
        
        // Game mode selection
        function selectVictoryMode(mode, target) {
            gameMode = mode;
            gameTarget = target;
            
            // Set default control scheme to mouse
            controlScheme = 'mouse';
            
            // Start the game immediately
            startGameTransition();
        }
        
        function startGameTransition() {
            // Create fade transition
            const gameModeSelect = document.getElementById('gameModeSelect');
            const discoveryLog = document.getElementById('discoveryLog');
            const gameCanvas = document.getElementById('gameCanvas');
            const gameModeStarsCanvas = document.getElementById('gameModeStarsCanvas');
            
            // Add transition styles
            gameModeSelect.style.transition = 'opacity 0.8s ease-out';
            gameCanvas.style.transition = 'opacity 0.8s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Create a temporary background during transition
            const transitionBg = document.createElement('div');
            transitionBg.style.position = 'fixed';
            transitionBg.style.top = '0';
            transitionBg.style.left = '0';
            transitionBg.style.width = '100%';
            transitionBg.style.height = '100%';
            transitionBg.style.background = '#000';
            transitionBg.style.zIndex = '40';
            transitionBg.appendChild(gameModeStarsCanvas.cloneNode(true));
            transitionBg.style.transition = 'opacity 1s ease-out';
            document.body.appendChild(transitionBg);
            
            // Fade out menu content but keep stars visible
            const menuContent = gameModeSelect.querySelector('#gameModeContent');
            menuContent.style.transition = 'opacity 0.5s ease-out';
            menuContent.style.opacity = '0';
            
            setTimeout(() => {
                gameModeSelect.style.opacity = '0';
                discoveryLog.style.display = 'block';
                gameCanvas.style.opacity = '1';
                
                setTimeout(() => {
                    gameModeSelect.style.display = 'none';
                    transitionBg.style.opacity = '0';
                    
                    setTimeout(() => {
                        transitionBg.remove();
                        startGame();
                    }, 1000);
                }, 100);
            }, 500);
        }
        
        function selectControls(scheme) {
            controlScheme = scheme;
            
            // Create fade transition
            const gameModeSelect = document.getElementById('gameModeSelect');
            const discoveryLog = document.getElementById('discoveryLog');
            const gameCanvas = document.getElementById('gameCanvas');
            const gameModeStarsCanvas = document.getElementById('gameModeStarsCanvas');
            
            // Add transition styles
            gameModeSelect.style.transition = 'opacity 0.8s ease-out';
            gameCanvas.style.transition = 'opacity 0.8s ease-in';
            gameCanvas.style.opacity = '0';
            
            // Create a temporary background during transition
            const transitionBg = document.createElement('div');
            transitionBg.style.position = 'fixed';
            transitionBg.style.top = '0';
            transitionBg.style.left = '0';
            transitionBg.style.width = '100%';
            transitionBg.style.height = '100%';
            transitionBg.style.background = '#000';
            transitionBg.style.zIndex = '40';
            transitionBg.appendChild(gameModeStarsCanvas.cloneNode(true));
            transitionBg.style.transition = 'opacity 1s ease-out';
            document.body.appendChild(transitionBg);
            
            // Fade out menu content but keep stars visible
            const menuContent = gameModeSelect.querySelector('#gameModeContent');
            if (menuContent) {
                menuContent.style.transition = 'opacity 0.4s ease-out';
                menuContent.style.opacity = '0';
            }
            
            // After content fades, start the game
            setTimeout(() => {
                gameModeSelect.style.display = 'none';
                discoveryLog.style.display = 'block';
                startGame();
                
                // Fade in game canvas and fade out transition background
                setTimeout(() => {
                    gameCanvas.style.opacity = '1';
                    transitionBg.style.opacity = '0';
                    
                    // Remove transition background after fade
                    setTimeout(() => {
                        transitionBg.remove();
                    }, 1000);
                }, 100);
            }, 400);
        }
        
        // Load snake names
        async function loadSnakeNames() {
            try {
                const response = await fetch('snake-names.json');
                const data = await response.json();
                snakeNameData = data;
                console.log('Loaded snake names data');
            } catch (error) {
                console.error('Failed to load snake names:', error);
                // Fallback data
                snakeNameData = {
                    firstParts: ['Sir', 'Lord', 'Captain', 'Master', 'Swift', 'Mighty', 'Sneaky'],
                    secondParts: ['Slithers', 'McSlitherface', 'the Magnificent', 'Noodle', 'Supreme']
                };
            }
        }
        
        // Generate random snake name
        function generateSnakeName() {
            if (!snakeNameData) {
                return `Snake${Math.floor(Math.random() * 1000)}`;
            }
            const first = snakeNameData.firstParts[Math.floor(Math.random() * snakeNameData.firstParts.length)];
            const second = snakeNameData.secondParts[Math.floor(Math.random() * snakeNameData.secondParts.length)];
            return `${first} ${second}`;
        }
        
        // Load element database
        async function loadElements() {
            try {
                // Wait for the new element system to load
                if (!window.elementLoader || !window.elementCompatibility) {
                    // Wait for elementsLoaded event
                    await new Promise((resolve) => {
                        window.addEventListener('elementsLoaded', resolve, { once: true });
                    });
                }
                
                // Use the compatibility layer to get legacy format
                const legacyData = window.elementCompatibility.legacyCache;
                
                // Update local references
                elementDatabase = legacyData.elements;
                combinations = legacyData.combinations;
                
                console.log(`Loaded ${Object.keys(elementDatabase).length} elements and ${Object.keys(combinations).length} combinations`);
            } catch (error) {
                console.error('Failed to load elements:', error);
                // Fallback to basic elements
                elementDatabase = {
                    fire: { emoji: '', name: 'Fire', tier: 0, base: true },
                    water: { emoji: '', name: 'Water', tier: 0, base: true },
                    earth: { emoji: '', name: 'Earth', tier: 0, base: true },
                    air: { emoji: '', name: 'Air', tier: 0, base: true }
                };
            }
        }
        
        // Sound effects
        const eatSounds = [];
        const explosionSounds = [];
        let soundIndex = 0;
        
        function initSoundEffects() {
            // Create multiple audio instances for overlapping sounds
            for (let i = 0; i < 5; i++) {
                const eatSound = new Audio('sounds/8-bit-blip.mp3');
                eatSound.volume = 0.5; // 50% volume
                eatSounds.push(eatSound);
                
                const explosionSound = new Audio('sounds/fire-impact.mp3');
                explosionSound.volume = 0.75; // 75% volume
                explosionSounds.push(explosionSound);
            }
        }
        
        function playEatSound() {
            if (!musicMuted && eatSounds.length > 0) {
                // Use round-robin to cycle through sound instances
                const sound = eatSounds[soundIndex % eatSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                sound.volume = 0.5;
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Eat sound error:', e.message));
                }
            }
        }
        
        function playExplosionSound(isPlayerInvolved = true) {
            if (!musicMuted && explosionSounds.length > 0) {
                // Use round-robin to cycle through sound instances
                const sound = explosionSounds[soundIndex % explosionSounds.length];
                soundIndex++;
                
                // Reset the sound to start
                sound.currentTime = 0;
                // Set volume based on whether player is involved
                sound.volume = isPlayerInvolved ? 0.75 : 0.25; // 75% for player, 25% for AI only
                
                // Try to play
                const playPromise = sound.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.log('Explosion sound error:', e.message));
                }
            }
        }
        
        // Music functions
        function initMusic() {
            // Check which tracks are available
            checkAvailableTracks().then(() => {
                if (availableTracks.length > 0) {
                    playRandomTrack();
                }
            });
        }
        
        async function checkAvailableTracks() {
            // For now, assume all tracks are available
            availableTracks = [...musicTracks];
            console.log('Available tracks loaded:', availableTracks);
            return true;
        }
        
        let isPlayingNext = false; // Prevent multiple simultaneous calls
        
        function playRandomTrack() {
            // Prevent multiple simultaneous calls
            if (isPlayingNext) {
                console.log('Already playing next track, ignoring call');
                return;
            }
            isPlayingNext = true;
            
            // Refill available tracks if empty
            if (availableTracks.length === 0) {
                console.log('Refilling available tracks...');
                availableTracks = [...musicTracks];
            }
            
            // Stop current track if playing
            if (currentTrack && currentTrack.stopRequested !== true) {
                // Mark that we're stopping this track intentionally
                currentTrack.stopRequested = true;
                // Remove all event listeners to prevent them from firing
                currentTrack.removeEventListener('ended', currentTrack.endedHandler);
                currentTrack.removeEventListener('error', currentTrack.errorHandler);
                currentTrack.pause();
                // Don't clear src as it can trigger ended event
                currentTrack = null; // Clear reference
            }
            
            // Pick random track
            const randomIndex = Math.floor(Math.random() * availableTracks.length);
            const trackName = availableTracks[randomIndex];
            
            // Remove the selected track from available tracks
            availableTracks.splice(randomIndex, 1);
            console.log(`Playing: ${trackName}, remaining tracks: ${availableTracks.length}`);
            
            // Create audio element
            currentTrack = new Audio(`music/${trackName}`);
            currentTrack.volume = musicMuted ? 0 : musicVolume;
            
            // Create event handlers that we can reference later for removal
            currentTrack.endedHandler = function() {
                console.log(`Track "${trackName}" ended, stopRequested: ${this.stopRequested}, currentTime: ${this.currentTime}, duration: ${this.duration}`);
                // Reset the playing flag first
                isPlayingNext = false;
                
                // Only play next if the track wasn't stopped intentionally and actually ended
                if (!this.stopRequested && this.currentTime > 0 && this.duration > 0 && this.currentTime >= this.duration - 0.5) {
                    console.log('Track ended naturally, playing next track...');
                    setTimeout(() => {
                        try {
                            playRandomTrack();
                        } catch (error) {
                            console.error('Error playing next track:', error);
                            // Try again in a few seconds
                            setTimeout(playRandomTrack, 3000);
                        }
                    }, 1000); // Wait 1 second before next track
                } else {
                    console.log('Track was stopped or ended prematurely, not playing next track');
                }
            };
            
            currentTrack.errorHandler = (e) => {
                console.error('Error loading track:', trackName, e);
                // Reset the playing flag
                isPlayingNext = false;
                // Try next track after a short delay
                setTimeout(() => {
                    playRandomTrack();
                }, 1000);
            };
            
            // Add event listeners
            currentTrack.addEventListener('ended', currentTrack.endedHandler);
            currentTrack.addEventListener('error', currentTrack.errorHandler);
            
            // Try to play
            const playPromise = currentTrack.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Music started playing successfully');
                    isPlayingNext = false; // Reset flag on success
                }).catch(e => {
                    console.log('Music autoplay blocked:', e.message);
                    // Store track to retry on user interaction
                    window.pendingMusicTrack = currentTrack;
                    isPlayingNext = false; // Reset flag on error
                });
            } else {
                isPlayingNext = false; // Reset flag if no promise
            }
        }
        
        window.toggleMusic = function() {
            musicMuted = !musicMuted;
            
            // Update desktop mute text
            const muteText = document.getElementById('muteText');
            if (muteText) {
                muteText.textContent = musicMuted ? 'M to Unmute' : 'M to Mute';
            }
            
            // Update mobile mute button
            const mobileMuteButton = document.getElementById('muteButtonMobile');
            if (mobileMuteButton) {
                mobileMuteButton.textContent = musicMuted ? '' : '';
            }
            
            if (musicMuted) {
                if (currentTrack) {
                    currentTrack.pause();
                }
            } else {
                if (currentTrack && gameStarted) {
                    currentTrack.volume = musicVolume;
                    currentTrack.play().catch(() => {});
                }
            }
        };
        
        window.changeVolume = function(value) {
            musicVolume = value / 100;
            document.getElementById('volumeDisplay').textContent = value + '%';
            
            if (currentTrack && !musicMuted) {
                currentTrack.volume = musicVolume;
            }
        };
        
        // Border particle class
        class BorderParticle {
            constructor(x, y, edge) {
                this.x = x;
                this.y = y;
                this.edge = edge; // 'left', 'right', 'top', 'bottom'
                this.baseX = x;
                this.baseY = y;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 0.5 + 0.1;
                this.offset = Math.random() * Math.PI * 2;
                this.opacity = Math.random() * 0.5 + 0.3;
                this.color = this.getRandomColor();
            }
            
            getRandomColor() {
                const colors = [
                    'rgba(147, 51, 234, ', // purple
                    'rgba(236, 72, 153, ', // pink
                    'rgba(59, 130, 246, ', // blue
                    'rgba(168, 85, 247, ', // purple-pink
                    'rgba(99, 102, 241, '  // indigo
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(deltaTime) {
                const time = animationTime + this.offset;
                
                // Float in circular motion
                const radius = 15;
                const floatX = Math.cos(time * this.speed) * radius;
                const floatY = Math.sin(time * this.speed * 0.7) * radius;
                
                this.x = this.baseX + floatX;
                this.y = this.baseY + floatY;
                
                // Pulse opacity
                this.opacity = 0.3 + Math.sin(time * 2) * 0.2;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color + this.opacity + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color + '0.8)';
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Snake class
        class Snake {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.prevX = x;
                this.prevY = y;
                this.angle = Math.random() * Math.PI * 2;
                this.prevAngle = this.angle;
                this.segments = [];
                
                this.elements = [];
                this.elementCapacity = 4; // Start with 4 element squares
                this.elementsEaten = 0; // Track total elements eaten for capacity growth
                this.length = 10;
                this.score = 0;
                this.discoveries = 0; // Track discoveries for this snake
                this.kills = 0; // Track kills for this snake
                this.alive = true;
                this.isPlayer = isPlayer;
                this.speed = SNAKE_SPEED;
                this.baseSpeed = SNAKE_SPEED; // Store base speed for boost calculations
                this.name = isPlayer ? 'You' : generateSnakeName();
                this.invincibilityTimer = 0;
                this.discoveredElements = new Set(['fire', 'water', 'earth', 'air']); // Each snake tracks its own discoveries
                
                // Speed boost properties
                this.stamina = 100; // Max stamina
                this.maxStamina = 100;
                this.isBoosting = false;
                this.staminaRegenCooldown = 0; // Prevents regen immediately after boosting
                this.boostParticleTimer = 0;
                
                // Assign skin
                if (isPlayer) {
                    this.skin = currentPlayerSkin;
                } else {
                    // Random AI skin from all available skins
                    const allSkins = Object.keys(skinMetadata);
                    this.skin = allSkins[Math.floor(Math.random() * allSkins.length)];
                }
                
                // Initialize segments
                for (let i = 0; i < this.length; i++) {
                    const segX = x - i * SEGMENT_SIZE * Math.cos(this.angle);
                    const segY = y - i * SEGMENT_SIZE * Math.sin(this.angle);
                    this.segments.push({
                        x: segX,
                        y: segY,
                        prevX: segX,
                        prevY: segY
                    });
                }
                
                // Start with some random elements
                const basicElements = ['fire', 'water', 'earth', 'air'];
                for (let i = 0; i < 3; i++) {
                    this.elements.push(basicElements[Math.floor(Math.random() * basicElements.length)]);
                }
            }
            
            update(deltaTime = 1) {
                if (!this.alive) return;
                
                // Store previous positions for interpolation
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevAngle = this.angle;
                
                // Store previous segment positions
                if (this.segments) {
                    this.segments.forEach(segment => {
                        segment.prevX = segment.x;
                        segment.prevY = segment.y;
                    });
                }
                
                // Debug check
                if (!isFinite(this.x) || !isFinite(this.y)) {
                    console.error('Snake position is NaN!', 'x:', this.x, 'y:', this.y, 'deltaTime:', deltaTime);
                }
                
                // Update invincibility
                if (this.invincibilityTimer > 0) {
                    this.invincibilityTimer -= 16; // Fixed timestep
                }
                
                // Handle controls
                if (this.isPlayer) {
                    // Handle turning
                    let turnMultiplier = 1;
                    if (this.isBoosting) {
                        turnMultiplier = 0.85; // Reduced turn speed while boosting
                    }
                    
                    if (isMobile && joystickActive) {
                        // Mobile controls - use joystick
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        const angleChange = angleDiff * 0.12 * turnMultiplier;
                        if (isFinite(angleChange)) {
                            this.angle += angleChange;
                        }
                        this.isBoosting = mouseDown && this.stamina > 0;
                    } else if (controlScheme === 'arrows') {
                        if (keys['ArrowLeft']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['ArrowRight']) this.angle += TURN_SPEED * turnMultiplier;
                        // Handle boost
                        this.isBoosting = keys['ArrowUp'] && this.stamina > 0;
                    } else if (controlScheme === 'wasd') {
                        if (keys['a'] || keys['A']) this.angle -= TURN_SPEED * turnMultiplier;
                        if (keys['d'] || keys['D']) this.angle += TURN_SPEED * turnMultiplier;
                        // Handle boost
                        this.isBoosting = (keys['w'] || keys['W']) && this.stamina > 0;
                    } else if (controlScheme === 'mouse') {
                        // Smooth angle interpolation
                        let angleDiff = mouseAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        const angleChange = angleDiff * 0.1 * turnMultiplier;
                        if (isFinite(angleChange)) {
                            this.angle += angleChange;
                        }
                        // Handle boost (mouse click)
                        this.isBoosting = mouseDown && this.stamina > 0;
                    }
                } else {
                    // AI with border avoidance
                    const borderDanger = 100; // Distance from border to start avoiding
                    const emergencyDistance = 50; // Emergency turn distance
                    
                    // Check distance to borders
                    const distToLeftBorder = this.x;
                    const distToRightBorder = WORLD_SIZE - this.x;
                    const distToTopBorder = this.y;
                    const distToBottomBorder = WORLD_SIZE - this.y;
                    
                    // Determine if we're too close to any border
                    const nearBorder = distToLeftBorder < borderDanger || distToRightBorder < borderDanger ||
                                     distToTopBorder < borderDanger || distToBottomBorder < borderDanger;
                    
                    const emergencyTurn = distToLeftBorder < emergencyDistance || distToRightBorder < emergencyDistance ||
                                        distToTopBorder < emergencyDistance || distToBottomBorder < emergencyDistance;
                    
                    if (emergencyTurn) {
                        // Emergency evasion - turn away from nearest border
                        let avoidAngle = this.angle;
                        
                        if (distToLeftBorder < emergencyDistance) {
                            avoidAngle = 0; // Turn right
                        } else if (distToRightBorder < emergencyDistance) {
                            avoidAngle = Math.PI; // Turn left
                        }
                        
                        if (distToTopBorder < emergencyDistance) {
                            avoidAngle = Math.PI / 2; // Turn down
                        } else if (distToBottomBorder < emergencyDistance) {
                            avoidAngle = -Math.PI / 2; // Turn up
                        }
                        
                        let angleDiff = avoidAngle - this.angle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        this.angle += angleDiff * 0.15; // Aggressive turn
                    } else {
                        // Normal AI - decide what to seek based on capacity
                        let target = null;
                        let targetAngle = null;
                        
                        // If at capacity, prioritize Void Orbs
                        if (this.elements.length >= this.elementCapacity) {
                            let nearestVoidOrb = null;
                            let minVoidDist = 800; // Larger search radius for void orbs
                            
                            for (const orb of voidOrbs) {
                                const dist = Math.hypot(orb.x - this.x, orb.y - this.y);
                                
                                // Skip orbs that are too close to borders
                                if (nearBorder) {
                                    const orbNearBorder = orb.x < borderDanger || orb.x > WORLD_SIZE - borderDanger ||
                                                         orb.y < borderDanger || orb.y > WORLD_SIZE - borderDanger;
                                    if (orbNearBorder) continue;
                                }
                                
                                if (dist < minVoidDist) {
                                    minVoidDist = dist;
                                    nearestVoidOrb = orb;
                                }
                            }
                            
                            if (nearestVoidOrb) {
                                target = nearestVoidOrb;
                                targetAngle = Math.atan2(nearestVoidOrb.y - this.y, nearestVoidOrb.x - this.x);
                            }
                        }
                        
                        // Check for nearby Catalyst Gems (prioritize if we have elements)
                        if (!target && this.elements.length > 0) {
                            let nearestCatalystGem = null;
                            let minCatalystDist = 600; // Medium search radius for catalyst gems
                            
                            for (const gem of catalystGems) {
                                const dist = Math.hypot(gem.x - this.x, gem.y - this.y);
                                
                                // Skip gems that are too close to borders
                                if (nearBorder) {
                                    const gemNearBorder = gem.x < borderDanger || gem.x > WORLD_SIZE - borderDanger ||
                                                         gem.y < borderDanger || gem.y > WORLD_SIZE - borderDanger;
                                    if (gemNearBorder) continue;
                                }
                                
                                if (dist < minCatalystDist) {
                                    minCatalystDist = dist;
                                    nearestCatalystGem = gem;
                                }
                            }
                            
                            if (nearestCatalystGem) {
                                target = nearestCatalystGem;
                                targetAngle = Math.atan2(nearestCatalystGem.y - this.y, nearestCatalystGem.x - this.x);
                            }
                        }
                        
                        // If no void orb or catalyst gem target, find nearest element
                        if (!target) {
                            let nearestElement = null;
                            let minDist = 500;
                            
                            for (const element of elementPool.getActiveElements()) {
                                const dist = Math.hypot(element.x - this.x, element.y - this.y);
                                
                                // Skip elements that are too close to borders
                                if (nearBorder) {
                                    const elemNearBorder = element.x < borderDanger || element.x > WORLD_SIZE - borderDanger ||
                                                         element.y < borderDanger || element.y > WORLD_SIZE - borderDanger;
                                    if (elemNearBorder) continue;
                                }
                                
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestElement = element;
                                }
                            }
                            
                            if (nearestElement) {
                                target = nearestElement;
                                targetAngle = Math.atan2(nearestElement.y - this.y, nearestElement.x - this.x);
                            }
                        }
                        
                        if (target && targetAngle !== null) {
                            let angleDiff = targetAngle - this.angle;
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            
                            // Slower turning when near borders to be more careful
                            const turnSpeed = nearBorder ? 0.05 : 0.08;
                            this.angle += angleDiff * turnSpeed;
                        } else {
                            // Wander randomly, but bias away from borders
                            let wanderAngle = (Math.random() - 0.5) * 0.1;
                            
                            // Add bias away from borders
                            if (this.x < 200) wanderAngle += 0.05; // Bias right
                            if (this.x > WORLD_SIZE - 200) wanderAngle -= 0.05; // Bias left
                            if (this.y < 200 && Math.cos(this.angle) < 0.5) wanderAngle = Math.abs(wanderAngle); // Bias down
                            if (this.y > WORLD_SIZE - 200 && Math.cos(this.angle) > -0.5) wanderAngle = -Math.abs(wanderAngle); // Bias up
                            
                            this.angle += wanderAngle;
                        }
                        
                        // AI boost decision making
                        if (!nearBorder && !emergencyTurn) {
                        // Strategic boost conditions for AI
                        let shouldBoost = false;
                        
                        // Check threats (larger snakes nearby)
                        let threatNearby = false;
                        let chasingPrey = false;
                        for (const otherSnake of snakes) {
                            if (otherSnake === this || !otherSnake.alive) continue;
                            const dist = Math.hypot(otherSnake.x - this.x, otherSnake.y - this.y);
                            
                            // Threat detection
                            if (dist < 200 && otherSnake.length > this.length * 1.2) {
                                threatNearby = true;
                                break;
                            }
                            
                            // Prey detection
                            if (dist < 150 && otherSnake.length < this.length * 0.8) {
                                chasingPrey = true;
                            }
                        }
                        
                        // Boost conditions
                        if (threatNearby && this.stamina > 40) {
                            // Escape from threats
                            shouldBoost = true;
                        } else if (chasingPrey && this.stamina > 60) {
                            // Chase smaller snakes
                            shouldBoost = true;
                        } else if (target && this.stamina > 80) {
                            // Boost to reach valuable targets
                            const targetDist = Math.hypot(target.x - this.x, target.y - this.y);
                            if (targetDist > 300 && targetDist < 600) {
                                shouldBoost = true;
                            }
                        }
                        
                        // Random boost for unpredictability (5% chance)
                        if (!shouldBoost && Math.random() < 0.05 && this.stamina > 50) {
                            shouldBoost = true;
                        }
                        
                            this.isBoosting = shouldBoost && this.stamina > 0;
                        } else {
                            // Don't boost near borders or during emergency turns
                            this.isBoosting = false;
                        }
                    }
                }
                
                // Update stamina and speed based on boost
                if (this.isBoosting && this.stamina > 0) {
                    // Deplete stamina (5 seconds of continuous use)
                    this.stamina -= (100 / (5 * 60)) * deltaTime; // 100 stamina over 5 seconds
                    this.stamina = Math.max(0, this.stamina);
                    this.staminaRegenCooldown = 30; // Half second cooldown before regen starts
                    
                    // Apply speed boost
                    this.speed = this.baseSpeed * 1.75;
                    
                    // Create boost particles
                    this.boostParticleTimer++;
                    const particleFrequency = isMobile ? 6 : 3; // Less frequent on mobile
                    if (this.boostParticleTimer % particleFrequency === 0) {
                        const particleAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                        const particleSpeed = 2 + Math.random() * 2;
                        const vx = Math.cos(particleAngle) * particleSpeed;
                        const vy = Math.sin(particleAngle) * particleSpeed;
                        const color = this.isPlayer ? 'rgba(100, 200, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                        particlePool.spawn(this.x, this.y, vx, vy, color);
                    }
                } else {
                    // Not boosting
                    this.isBoosting = false;
                    this.speed = this.baseSpeed;
                    
                    // Regenerate stamina
                    if (this.staminaRegenCooldown > 0) {
                        this.staminaRegenCooldown -= deltaTime;
                    } else if (this.stamina < this.maxStamina) {
                        // Regenerate stamina (3 seconds to full)
                        this.stamina += (100 / (3 * 60)) * deltaTime; // 100 stamina over 3 seconds
                        this.stamina = Math.min(this.maxStamina, this.stamina);
                    }
                }
                
                // Ensure angle is valid
                if (!isFinite(this.angle)) {
                    console.error('Angle is invalid!', this.angle, 'Resetting to 0');
                    this.angle = 0;
                }
                
                // Move head (apply deltaTime for proper movement)
                const moveX = Math.cos(this.angle) * this.speed * deltaTime;
                const moveY = Math.sin(this.angle) * this.speed * deltaTime;
                
                if (isFinite(moveX) && isFinite(moveY)) {
                    this.x += moveX;
                    this.y += moveY;
                } else {
                    console.error('Invalid movement!', 'angle:', this.angle, 'speed:', this.speed, 'deltaTime:', deltaTime);
                }
                
                // World boundaries
                if (this.x < 0 || this.x > WORLD_SIZE || this.y < 0 || this.y > WORLD_SIZE) {
                    this.die();
                    return;
                }
                
                // Update segments
                if (!this.segments) {
                    console.error('Segments array is undefined!');
                    this.segments = [];
                }
                this.segments.unshift({ 
                    x: this.x, 
                    y: this.y,
                    prevX: this.prevX || this.x,
                    prevY: this.prevY || this.y
                });
                while (this.segments.length > this.length) {
                    this.segments.pop();
                }
                
                // Check element combinations
                this.checkCombinations();
            }
            
            checkCombinations() {
                if (this.elements.length < 2) return;
                
                // Queue-based system: new element (first) combines with tail (last element)
                const newElement = this.elements[0]; // Most recently added element
                const tailElement = this.elements[this.elements.length - 1]; // Last element (tail)
                        
                // Use the new element system for combination checking if available
                let result = null;
                if (window.elementLoader && window.elementCompatibility) {
                    const resultElement = window.elementLoader.getCombinationByKeys(newElement, tailElement);
                    result = resultElement ? resultElement.key : null;
                } else {
                    // Fallback to old system
                    const combo1 = `${newElement}+${tailElement}`;
                    const combo2 = `${tailElement}+${newElement}`;
                    result = combinations[combo1] || combinations[combo2];
                }
                        
                if (result && elementDatabase[result]) {
                    // Remove the new element and tail element
                    this.elements.shift(); // Remove new element (first)
                    this.elements.pop(); // Remove tail element (last)
                    
                    // Add the result to the front
                    this.elements.unshift(result);
                            
                    // Discovery check
                    if (!this.discoveredElements.has(result)) {
                        this.discoveredElements.add(result);
                        this.score += 1000; // 1000 points for new discovery
                        this.discoveries++; // Increment discovery count
                        
                        // Additional effects for player
                        if (this.isPlayer && this === playerSnake) {
                            discoveredElements.add(result); // Update global discoveries
                            
                            // Save to all-time discoveries with recipe
                            const recipe = `${elementDatabase[newElement]?.emoji || '?'} ${elementDatabase[newElement]?.name || newElement} + ${elementDatabase[tailElement]?.emoji || '?'} ${elementDatabase[tailElement]?.name || tailElement}`;
                            allTimeDiscoveries.set(result, recipe);
                            saveAllTimeDiscoveries();
                            
                            // Update new system if available
                            if (window.elementLoader && window.elementCompatibility) {
                                const element = window.elementLoader.getElementByKey(result);
                                if (element) {
                                    window.elementLoader.discoverElement(element.id);
                                    window.elementCompatibility.saveDiscoveredElements();
                                }
                            }
                            
                            showCombinationMessage(newElement, tailElement, result, true); // Show new discovery
                            // Grant invincibility on new discovery
                            this.invincibilityTimer = 3000; // 3 seconds
                            
                            // Check for new high score
                            if (this.score > highScore) {
                                highScore = this.score;
                                localStorage.setItem('highScore', highScore.toString());
                            }
                        }
                    } else {
                        // Show popup for existing discovery
                        if (this.isPlayer && this === playerSnake) {
                            showCombinationMessage(newElement, tailElement, result, false); // Show combo
                        }
                    }
                            
                    // Create particle effect at snake head
                    createCombinationParticles(this.segments[0].x, this.segments[0].y);
                    
                    // Check again in case there are more combinations
                    this.checkCombinations();
                    return;
                }
            }
            
            consume(element) {
                // Play eating sound for player only
                if (this.isPlayer) {
                    playEatSound();
                }
                
                // Check if we have space
                if (this.elements.length >= this.elementCapacity) {
                    // At capacity - just add points, don't store element
                    this.score += 100;
                    
                    // Still grow snake and track elements eaten
                    this.length += 2;
                    this.elementsEaten++;
                    
                    // Check for capacity growth
                    const capacityLevel = Math.floor((this.elementCapacity - 4) / 2);
                    const elementsNeededForNext = 10 + (capacityLevel * 5);
                    const elementsForThisLevel = capacityLevel === 0 ? this.elementsEaten : 
                        this.elementsEaten - (10 + ((capacityLevel - 1) * capacityLevel * 5 / 2));
                    
                    if (elementsForThisLevel >= elementsNeededForNext && this.elementCapacity < 30) {
                        this.elementCapacity += 2;
                        if (this.isPlayer && this === playerSnake) {
                            showMessage(`Element capacity increased to ${this.elementCapacity}! Next upgrade: ${10 + ((capacityLevel + 1) * 5)} elements`, false);
                        }
                    }
                    
                    // Remove element from world
                    elementPool.remove(element);
                    
                    return; // Don't add to queue
                }
                
                // Add element to snake (at the front for queue-based system)
                this.elements.unshift(element.type);
                
                // Track elements eaten for capacity growth
                this.elementsEaten++;
                
                // Progressive capacity growth - gets harder each time
                const capacityLevel = Math.floor((this.elementCapacity - 4) / 2); // Current capacity level
                const elementsNeededForNext = 10 + (capacityLevel * 5); // 10, 15, 20, 25, etc.
                const elementsForThisLevel = capacityLevel === 0 ? this.elementsEaten : 
                    this.elementsEaten - (10 + ((capacityLevel - 1) * capacityLevel * 5 / 2)); // Sum of arithmetic sequence
                
                if (elementsForThisLevel >= elementsNeededForNext && this.elementCapacity < 30) {
                    this.elementCapacity += 2;
                    if (this.isPlayer && this === playerSnake) {
                        // Visual feedback for capacity growth
                        showMessage(`Element capacity increased to ${this.elementCapacity}! Next upgrade: ${10 + ((capacityLevel + 1) * 5)} elements`, false);
                    }
                }
                
                // Grow snake
                this.length += 2;
                
                // Add score - 100 points per element
                this.score += 100;
                
                // Check for new high score
                if (this.isPlayer && this.score > highScore) {
                    highScore = this.score;
                    localStorage.setItem('highScore', highScore.toString());
                }
                
                // Remove element from world
                elementPool.remove(element);
                
                // Update UI if player
                if (this.isPlayer) {
                    updateUI();
                }
            }
            
            digest() {
                if (!this.isPlayer || this.elements.length === 0) {
                    // Non-player digestion happens instantly
                    const digestedCount = this.elements.length;
                    this.elements = [];
                    
                    // Bonus points for digestion based on how full we were
                    const digestBonus = Math.floor(digestedCount * 50);
                    this.score += digestBonus;
                    
                    // Check for new high score
                    if (this.isPlayer && this.score > highScore) {
                        highScore = this.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                    return;
                }
                
                // Player digestion - show message immediately
                const digestedCount = this.elements.length;
                
                // Clear all elements immediately
                this.elements = [];
                
                // Bonus points for digestion based on how full we were
                const digestBonus = Math.floor(digestedCount * 50);
                this.score += digestBonus;
                
                // Show digestion message for player only
                if (this.isPlayer && this === playerSnake) {
                    showMessage(`Digesting ${digestedCount} elements! +${digestBonus} points`, false);
                    // Update UI immediately
                    updateUI();
                }
            }
            
            die() {
                console.error('Snake dying!', 'isPlayer:', this.isPlayer, 'position:', this.x, this.y);
                console.trace();
                this.alive = false;
                
                // Drop all elements
                for (let i = 0; i < this.elements.length && i < this.segments.length; i++) {
                    const segment = this.segments[i];
                    spawnElement(this.elements[i], segment.x, segment.y);
                }
                
                // Create death particles scaled to snake size
                createDeathParticles(this.x, this.y, this.length);
                
                // Respawn if player
                if (this.isPlayer) {
                    // Lose half points and half capacity on death
                    const oldScore = this.score;
                    const oldDiscoveries = this.discoveries;
                    const oldDiscoveredElements = new Set(this.discoveredElements);
                    const oldElementsEaten = this.elementsEaten;
                    const oldCapacity = this.elementCapacity;
                    const oldKills = this.kills; // Preserve kills
                    
                    setTimeout(() => {
                        // Remove the old dead player snake before creating new one
                        snakes = snakes.filter(s => s !== this);
                        
                        playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
                        playerSnake.score = Math.floor(oldScore / 2); // Keep half points
                        playerSnake.discoveries = oldDiscoveries; // Keep discoveries
                        playerSnake.discoveredElements = oldDiscoveredElements; // Keep discovered elements
                        playerSnake.elementsEaten = Math.floor(oldElementsEaten / 2); // Lose half progress
                        playerSnake.elementCapacity = Math.max(4, Math.floor(oldCapacity / 2)); // Lose half capacity (min 4)
                        playerSnake.kills = oldKills; // Keep all kills
                        snakes.push(playerSnake);
                    }, 3000);
                }
            }
            
            explode(killer) {
                // Play explosion sound - louder if player is involved
                const isPlayerInvolved = this.isPlayer || (killer && killer.isPlayer);
                playExplosionSound(isPlayerInvolved);
                
                // Award points and kills to killer
                if (killer && killer.alive) {
                    killer.score += 500; // 500 points for snake explosion
                    killer.kills++; // Increment kill count
                    
                    // Check for new high score if player
                    if (killer.isPlayer && killer.score > highScore) {
                        highScore = killer.score;
                        localStorage.setItem('highScore', highScore.toString());
                    }
                }
                this.die();
            }
            
            draw(interpolation = 0) {
                if (!this.alive) return;
                
                // Early viewport check for the whole snake
                // TEMPORARILY DISABLED FOR DEBUGGING
                /*
                if (this.segments.length > 0) {
                    // Check if any segment is in viewport
                    let anyInViewport = false;
                    const margin = isMobile ? 150 : 200;
                    for (const segment of this.segments) {
                        if (isInViewport(segment.x, segment.y, margin)) {
                            anyInViewport = true;
                            break;
                        }
                    }
                    if (!anyInViewport) return;
                }
                */
                
                // Draw boost trail effect
                if (this.isBoosting && this.segments && this.segments.length > 1) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw speed lines
                    for (let i = 0; i < 3; i++) {
                        const segment = this.segments[Math.min(i * 2, this.segments.length - 1)];
                        const nextSegment = this.segments[Math.min(i * 2 + 5, this.segments.length - 1)];
                        
                        const screenX1 = segment.x - camera.x + canvas.width / 2;
                        const screenY1 = segment.y - camera.y + canvas.height / 2;
                        const screenX2 = nextSegment.x - camera.x + canvas.width / 2;
                        const screenY2 = nextSegment.y - camera.y + canvas.height / 2;
                        
                        // Skip if any coordinate is invalid
                        if (!isFinite(screenX1) || !isFinite(screenY1) || !isFinite(screenX2) || !isFinite(screenY2)) {
                            continue;
                        }
                        
                        const gradient = ctx.createLinearGradient(screenX1, screenY1, screenX2, screenY2);
                        gradient.addColorStop(0, this.isPlayer ? 'rgba(100, 200, 255, 0.6)' : 'rgba(255, 100, 100, 0.6)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = SEGMENT_SIZE * 2 - i * 5;
                        ctx.beginPath();
                        ctx.moveTo(screenX1, screenY1);
                        ctx.lineTo(screenX2, screenY2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
                
                // Draw segments
                for (let i = this.segments.length - 1; i >= 0; i--) {
                    const segment = this.segments[i];
                    
                    // Interpolate position if previous position exists
                    let x = segment.x;
                    let y = segment.y;
                    if (segment.prevX !== undefined && segment.prevY !== undefined) {
                        x = segment.prevX + (segment.x - segment.prevX) * interpolation;
                        y = segment.prevY + (segment.y - segment.prevY) * interpolation;
                    }
                    
                    const screenX = x - camera.x + canvas.width / 2;
                    const screenY = y - camera.y + canvas.height / 2;
                    
                    // Skip if off-screen
                    if (screenX < -50 || screenX > canvas.width + 50 ||
                        screenY < -50 || screenY > canvas.height + 50) continue;
                    
                    // Snake body color based on skin
                    const skinData = skinMetadata[this.skin];
                    const colors = skinData ? skinData.colors : ['#4ecdc4', '#45b7aa'];
                    
                    if (this.invincibilityTimer > 0 && this.isPlayer) {
                        // Flash effect during invincibility
                        const flash = Math.sin(this.invincibilityTimer * 0.01) > 0;
                        ctx.fillStyle = flash ? '#FFD700' : colors[i % colors.length];
                    } else {
                        ctx.fillStyle = colors[i % colors.length];
                    }
                    
                    ctx.beginPath();
                    // Ensure segment radius never goes below 1 pixel
                    const segmentRadius = Math.max(1, SEGMENT_SIZE - Math.min(i * 0.05, SEGMENT_SIZE - 1));
                    ctx.arc(screenX, screenY, segmentRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw head
                if (this.segments.length > 0) {
                    const head = this.segments[0];
                    
                    // Interpolate head position
                    let headX = head.x;
                    let headY = head.y;
                    let angle = this.angle;
                    
                    if (head.prevX !== undefined && head.prevY !== undefined) {
                        headX = head.prevX + (head.x - head.prevX) * interpolation;
                        headY = head.prevY + (head.y - head.prevY) * interpolation;
                    }
                    
                    if (this.prevAngle !== undefined) {
                        // Handle angle wrapping for smooth interpolation
                        let angleDiff = this.angle - this.prevAngle;
                        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                        angle = this.prevAngle + angleDiff * interpolation;
                    }
                    
                    // Offset head position forward along the snake direction
                    const offsetDistance = 10; // pixels to move head forward
                    const offsetX = Math.cos(angle) * offsetDistance;
                    const offsetY = Math.sin(angle) * offsetDistance;
                    
                    const screenX = (headX + offsetX) - camera.x + canvas.width / 2;
                    const screenY = (headY + offsetY) - camera.y + canvas.height / 2;
                    
                    // Draw boost glow around head
                    if (this.isBoosting) {
                        const glowSize = SEGMENT_SIZE * 4;
                        const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                        gradient.addColorStop(0, this.isPlayer ? 'rgba(100, 200, 255, 0.4)' : 'rgba(255, 100, 100, 0.4)');
                        gradient.addColorStop(0.5, this.isPlayer ? 'rgba(100, 200, 255, 0.2)' : 'rgba(255, 100, 100, 0.2)');
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                    }
                    
                    // Draw skin image
                    const skinImage = skinImages[this.skin];
                    if (skinImage && skinImage.complete && !skinImage.error) {
                        try {
                            ctx.save();
                            ctx.translate(screenX, screenY);
                            ctx.rotate(angle - Math.PI/2); // Rotate 90 degrees counter-clockwise so top faces body
                            const size = SEGMENT_SIZE * 3.47875; // Increased by another 10% (3.1625 * 1.1)
                            ctx.drawImage(skinImage, -size/2, -size/2, size, size);
                            ctx.restore();
                        } catch (e) {
                            ctx.restore();
                            // Fall through to emoji fallback
                        }
                    } else {
                        // Fallback to emoji if image not loaded
                        const snakeEmojiSize = Math.round(SEGMENT_SIZE * 2);
                        const snakeEmojiCanvas = getCachedEmoji(this.isPlayer ? '' : '', snakeEmojiSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.drawImage(snakeEmojiCanvas, screenX - snakeEmojiCanvas.width / 2, screenY - snakeEmojiCanvas.height / 2);
                        ctx.restore();
                    }
                    
                    // Draw name
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(this.name, screenX, screenY - SEGMENT_SIZE - 10);
                    ctx.fillText(this.name, screenX, screenY - SEGMENT_SIZE - 10);
                    
                    // Draw crown if leader
                    if (this.isLeader) {
                        const crownSize = 24;
                        const crownCanvas = getCachedEmoji('', crownSize);
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.drawImage(crownCanvas, screenX - crownCanvas.width / 2, screenY - SEGMENT_SIZE - 30 - crownCanvas.height / 2);
                        ctx.restore();
                    }
                }
            }
        }
        
        // Element class
        class Element {
            constructor(type, x, y, isCatalystSpawned = false) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.data = elementDatabase[type];
                // Fallback if element not found
                if (!this.data) {
                    console.warn(`Element type "${type}" not found in database`);
                    this.data = { emoji: '', name: 'Unknown', tier: 0 };
                }
                this.pulse = 0;
                this.isCatalystSpawned = isCatalystSpawned;
                this.catalystSparkleTime = 0;
            }
            
            update(deltaTime = 1) {
                this.pulse += 0.05 * deltaTime;
                if (this.isCatalystSpawned) {
                    this.catalystSparkleTime += 0.1 * deltaTime;
                }
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                const scale = 1 + Math.sin(this.pulse || 0) * 0.1;
                
                // Check if this element is compatible with player's tail during AlchemyVision
                let alchemyGlow = null;
                if (alchemyVisionActive && playerSnake && playerSnake.alive && playerSnake.elements.length > 0) {
                    const tailElement = playerSnake.elements[playerSnake.elements.length - 1];
                    const distance = Math.hypot(this.x - playerSnake.x, this.y - playerSnake.y);
                    
                    // Only show glows within 300 pixel radius
                    if (distance <= 300) {
                        // Check if this element can combine with tail
                        const combo1 = `${this.type}+${tailElement}`;
                        const combo2 = `${tailElement}+${this.type}`;
                        
                        if (combinations[combo1] || combinations[combo2]) {
                            const result = combinations[combo1] || combinations[combo2];
                            // Check if this is a new discovery
                            if (!discoveredElements.has(result)) {
                                alchemyGlow = 'discovery'; // Golden glow
                            } else {
                                alchemyGlow = 'known'; // Green glow
                            }
                        }
                    }
                }
                
                // Draw appropriate glow effect
                if (alchemyGlow === 'discovery') {
                    // Golden glow for new discoveries
                    const glowSize = ELEMENT_SIZE * 3 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.4)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                } else if (alchemyGlow === 'known') {
                    // Green glow for known combinations
                    const glowSize = ELEMENT_SIZE * 2.5 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    gradient.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(0, 200, 0, 0.3)');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                } else if (this.data && this.data.tier > 0) {
                    // Normal tier-based glow
                    const glowSize = ELEMENT_SIZE * 2 * scale;
                    const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, glowSize);
                    const hue = (this.data.tier * 60) % 360;
                    gradient.addColorStop(0, `hsla(${hue}, 70%, 50%, 0.3)`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(screenX - glowSize, screenY - glowSize, glowSize * 2, glowSize * 2);
                }
                
                // Draw emoji using cache
                const emojiSize = Math.round(ELEMENT_SIZE * 2 * scale);
                const emojiCanvas = getCachedEmoji(this.data ? this.data.emoji : '', emojiSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(emojiCanvas, screenX - emojiCanvas.width / 2, screenY - emojiCanvas.height / 2);
                ctx.restore();
                
                // Draw element name below emoji
                ctx.font = '10px Arial';
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                const name = this.data ? this.data.name : 'Unknown';
                ctx.strokeText(name, screenX, screenY + ELEMENT_SIZE + 5);
                ctx.fillText(name, screenX, screenY + ELEMENT_SIZE + 5);
                
                // Draw catalyst sparkles if this element was spawned by catalyst
                if (this.isCatalystSpawned) {
                    ctx.save();
                    for (let i = 0; i < 4; i++) {
                        const angle = (this.catalystSparkleTime + i * Math.PI / 2) % (Math.PI * 2);
                        const dist = ELEMENT_SIZE + 10 + Math.sin(this.catalystSparkleTime * 2) * 5;
                        const px = screenX + Math.cos(angle) * dist;
                        const py = screenY + Math.sin(angle) * dist;
                        
                        ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add a small star
                        const sparkleCanvas = getCachedEmoji('', 12);
                        ctx.save();
                        ctx.globalAlpha = 0.9;
                        ctx.drawImage(sparkleCanvas, px - sparkleCanvas.width / 2, py - sparkleCanvas.height / 2);
                        ctx.restore();
                    }
                    ctx.restore();
                }
            }
        }
        
        // AlchemyVision power-up class
        class AlchemyVision {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = 0;
                this.rotation = 0;
            }
            
            update() {
                this.pulse += 0.05;
                this.rotation += 0.02;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Purple/gold glow effect
                const glowSize = this.size * 2 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)'); // Gold
                gradient.addColorStop(0.5, 'rgba(147, 0, 211, 0.4)'); // Purple
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Crystal ball emoji
                const crystalSize = Math.round(this.size * 2 * scale);
                const crystalCanvas = getCachedEmoji('', crystalSize);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.drawImage(crystalCanvas, -crystalCanvas.width / 2, -crystalCanvas.height / 2);
                ctx.restore();
                
                // Swirling particles
                for (let i = 0; i < 3; i++) {
                    const angle = (this.rotation * 2) + (i * Math.PI * 2 / 3);
                    const dist = this.size * scale;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(255, 215, 0, 0.8)' : 'rgba(147, 0, 211, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // VoidOrb class
        class VoidOrb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
            }
            
            update() {
                this.pulse += 0.05;
                this.rotation += 0.03;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.1;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Blue glow effect
                const glowSize = this.size * 2 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(0, 150, 255, 0.6)'); // Bright blue
                gradient.addColorStop(0.5, 'rgba(0, 50, 200, 0.4)'); // Dark blue
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Void orb emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Swirling particles
                for (let i = 0; i < 4; i++) {
                    const angle = (this.rotation * 3) + (i * Math.PI / 2);
                    const dist = this.size * scale * 0.8;
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // CatalystGem class
        class CatalystGem {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.pulse = Math.random() * Math.PI * 2;
                this.rotation = 0;
                this.sparkleTime = 0;
            }
            
            update() {
                this.pulse += 0.04;
                this.rotation += 0.02;
                this.sparkleTime += 0.1;
            }
            
            draw() {
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen - tighter culling on mobile
                const margin = isMobile ? 30 : 50;
                if (screenX < -margin || screenX > canvas.width + margin ||
                    screenY < -margin || screenY > canvas.height + margin) return;
                
                const scale = 1 + Math.sin(this.pulse) * 0.15;
                
                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.rotation);
                
                // Orange glow effect
                const glowSize = this.size * 2.5 * scale;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                gradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)'); // Bright orange
                gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)'); // Dark orange
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
                
                // Catalyst gem emoji
                ctx.save(); // Save canvas state for emoji
                ctx.globalAlpha = 1; // Ensure full opacity
                ctx.fillStyle = 'black'; // Set solid color for emoji
                ctx.font = `${this.size * 2 * scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('', 0, 0);
                ctx.restore(); // Restore canvas state
                
                // Sparkle particles
                for (let i = 0; i < 6; i++) {
                    const angle = (this.sparkleTime + i * Math.PI / 3) % (Math.PI * 2);
                    const dist = this.size * scale * (0.8 + Math.sin(this.sparkleTime * 2 + i) * 0.3);
                    const px = Math.cos(angle) * dist;
                    const py = Math.sin(angle) * dist;
                    
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.9)';
                    ctx.beginPath();
                    ctx.arc(px, py, 2 + Math.sin(this.sparkleTime * 3 + i) * 1, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.reset(x, y, vx, vy, color);
            }
            
            reset(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.active = true;
            }
            
            update(deltaTime = 1) {
                if (!this.active) return false;
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                this.life -= 0.02 * deltaTime;
                this.vx *= Math.pow(0.98, deltaTime);
                this.vy *= Math.pow(0.98, deltaTime);
                
                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }
                return true;
            }
            
            draw() {
                if (!this.active) return;
                
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // Object pools for performance
        class ParticlePool {
            constructor(size = 200) {
                this.pool = [];
                this.activeParticles = [];
                
                // Pre-allocate particles
                for (let i = 0; i < size; i++) {
                    this.pool.push(new Particle(0, 0, 0, 0, 'white'));
                }
            }
            
            spawn(x, y, vx, vy, color) {
                let particle = this.pool.pop();
                if (!particle) {
                    // Pool is empty, create new particle
                    particle = new Particle(x, y, vx, vy, color);
                } else {
                    particle.reset(x, y, vx, vy, color);
                }
                this.activeParticles.push(particle);
                return particle;
            }
            
            update(deltaTime = 1) {
                for (let i = this.activeParticles.length - 1; i >= 0; i--) {
                    const particle = this.activeParticles[i];
                    if (!particle.update(deltaTime)) {
                        // Return to pool
                        this.activeParticles.splice(i, 1);
                        this.pool.push(particle);
                    }
                }
            }
            
            draw() {
                this.activeParticles.forEach(particle => {
                    if (isInViewport(particle.x, particle.y, 50)) {
                        particle.draw();
                    }
                });
            }
            
            getActiveCount() {
                return this.activeParticles.length;
            }
        }
        
        // Initialize particle pool
        const particlePool = new ParticlePool(isMobile ? 100 : 200);
        
        // Element pool for performance
        class ElementPool {
            constructor(size = 50) {
                this.pool = [];
                this.activeElements = [];
            }
            
            spawn(type, x, y, isCatalystSpawned = false) {
                let element = this.pool.pop();
                if (!element) {
                    element = new Element(type, x, y, isCatalystSpawned);
                } else {
                    // Reset existing element
                    element.type = type;
                    element.x = x;
                    element.y = y;
                    element.data = elementDatabase[type];
                    if (!element.data) {
                        console.warn(`Element type "${type}" not found in database`);
                        element.data = { emoji: '', name: 'Unknown', tier: 0 };
                    }
                    element.pulse = 0;
                    element.isCatalystSpawned = isCatalystSpawned;
                    element.catalystSparkleTime = 0;
                }
                this.activeElements.push(element);
                return element;
            }
            
            remove(element) {
                const index = this.activeElements.indexOf(element);
                if (index > -1) {
                    this.activeElements.splice(index, 1);
                    this.pool.push(element);
                }
            }
            
            update(deltaTime = 1) {
                this.activeElements.forEach(element => element.update(deltaTime));
            }
            
            draw() {
                this.activeElements.forEach(element => {
                    if (isInViewport(element.x, element.y, ELEMENT_SIZE + 50)) {
                        element.draw();
                    }
                });
            }
            
            getActiveElements() {
                return this.activeElements;
            }
            
            getActiveCount() {
                return this.activeElements.length;
            }
        }
        
        // Initialize element pool
        const elementPool = new ElementPool();
        
        // Shooting Star class
        class ShootingStar {
            constructor() {
                // Random starting position on screen edge
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // Top
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = 0;
                        break;
                    case 1: // Right
                        this.x = WORLD_SIZE;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * WORLD_SIZE;
                        this.y = WORLD_SIZE;
                        break;
                    case 3: // Left
                        this.x = 0;
                        this.y = Math.random() * WORLD_SIZE;
                        break;
                }
                
                // Random angle and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = 15 + Math.random() * 10; // Fast movement
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                
                this.trail = [];
                this.maxTrailLength = 20;
                this.life = 1.0;
                this.fadeSpeed = 0.01; // Slower fade for 1-2 second visibility
            }
            
            update(deltaTime = 1) {
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y, alpha: this.life });
                
                // Limit trail length
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Fade out
                this.life -= this.fadeSpeed * deltaTime;
                
                // Update trail alpha
                this.trail.forEach((point, index) => {
                    point.alpha = (index / this.trail.length) * this.life;
                });
                
                // Check if out of bounds or faded
                return this.life > 0 && this.x > -100 && this.x < WORLD_SIZE + 100 && 
                       this.y > -100 && this.y < WORLD_SIZE + 100;
            }
            
            draw() {
                // Draw trail
                ctx.save();
                this.trail.forEach((point, index) => {
                    const screenX = point.x - camera.x + canvas.width / 2;
                    const screenY = point.y - camera.y + canvas.height / 2;
                    
                    ctx.globalAlpha = point.alpha * 0.5;
                    ctx.fillStyle = '#ffffff';
                    const size = (index / this.trail.length) * 3;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main star
                const screenX = this.x - camera.x + canvas.width / 2;
                const screenY = this.y - camera.y + canvas.height / 2;
                
                ctx.globalAlpha = this.life;
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Helper functions
        function spawnElement(type = null, x = null, y = null) {
            if (!type) {
                // Use tier-based spawning if new system is available
                if (window.elementLoader) {
                    const rand = Math.random();
                    let selectedElement;
                    
                    if (rand < 0.7) {
                        // 70% chance for tier 0 (basic) elements
                        const tier0Elements = window.elementLoader.getElementsByTier(0);
                        selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                    } else if (rand < 0.9) {
                        // 20% chance for tier 1 elements
                        const tier1Elements = window.elementLoader.getElementsByTier(1);
                        if (tier1Elements.length > 0) {
                            selectedElement = tier1Elements[Math.floor(Math.random() * tier1Elements.length)];
                        } else {
                            // Fallback to tier 0
                            const tier0Elements = window.elementLoader.getElementsByTier(0);
                            selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                        }
                    } else {
                        // 10% chance for tier 2+ elements (if discovered)
                        const allElements = window.elementLoader.getAllElements();
                        const higherTierElements = allElements.filter(e => e.tier >= 2 && discoveredElements.has(e.key));
                        if (higherTierElements.length > 0) {
                            selectedElement = higherTierElements[Math.floor(Math.random() * higherTierElements.length)];
                        } else {
                            // Fallback to tier 1 or 0
                            const tier1Elements = window.elementLoader.getElementsByTier(1);
                            if (tier1Elements.length > 0) {
                                selectedElement = tier1Elements[Math.floor(Math.random() * tier1Elements.length)];
                            } else {
                                const tier0Elements = window.elementLoader.getElementsByTier(0);
                                selectedElement = tier0Elements[Math.floor(Math.random() * tier0Elements.length)];
                            }
                        }
                    }
                    
                    type = selectedElement.key;
                } else {
                    // Fallback to old system
                    const rand = Math.random();
                    if (rand < 0.7) {
                        // Basic element
                        const basics = ['fire', 'water', 'earth', 'air'];
                        type = basics[Math.floor(Math.random() * basics.length)];
                    } else {
                        // Any discovered element
                        const available = Object.keys(elementDatabase);
                        type = available[Math.floor(Math.random() * available.length)];
                    }
                }
            }
            
            // Random position if not specified
            if (!x || !y) {
                x = 100 + Math.random() * (WORLD_SIZE - 200);
                y = 100 + Math.random() * (WORLD_SIZE - 200);
            }
            
            elementPool.spawn(type, x, y);
        }
        
        function createCombinationParticles(x, y) {
            const particleCount = isMobile ? 10 : 20; // Reduced for mobile
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particlePool.spawn(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    `hsl(${Math.random() * 360}, 70%, 50%)`
                );
            }
        }
        
        function createDeathParticles(x, y, snakeLength = 5) {
            // Scale particle count and speed based on snake size
            const baseParticles = isMobile ? 10 : 20;
            const particleCount = Math.min(baseParticles + Math.floor(snakeLength / (isMobile ? 4 : 2)), isMobile ? 30 : 100); // Reduced for mobile
            const speedMultiplier = 1 + (snakeLength / 50); // Bigger snakes = faster explosion
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * speedMultiplier;
                particlePool.spawn(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    '#ff0000'
                );
            }
            
            // Add some larger, slower particles for bigger snakes
            if (snakeLength > 20) {
                const largeParticleCount = Math.min(Math.floor(snakeLength / 10), 20);
                for (let i = 0; i < largeParticleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random() * 3 + 1) * speedMultiplier;
                    particlePool.spawn(
                        x, y,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        '#ff6600'
                    );
                }
            }
        }
        
        function showCombinationMessage(elem1, elem2, result, isNew) {
            const elem1Data = elementDatabase[elem1];
            const elem2Data = elementDatabase[elem2];
            const resultData = elementDatabase[result];
            
            let message = `${elem1Data.emoji} + ${elem2Data.emoji} = ${resultData.emoji} ${resultData.name}`;
            if (isNew) {
                message = `New Discovery! ${message}`;
                // Update discovery log for new discoveries
                lastDiscoveredElement = result;
                updateDiscoveryLog();
                // Add to discovery feed
                addDiscoveryToFeed(resultData, `${elem1Data.emoji} ${elem1Data.name} + ${elem2Data.emoji} ${elem2Data.name}`);
            } else {
                message = `Combo! ${message}`;
            }
            
            showMessage(message, isNew);
        }
        
        function showMessage(text, isDiscovery) {
            const popup = document.getElementById('recentDiscovery');
            popup.innerHTML = text;
            popup.className = isDiscovery ? 'show' : 'show combo';
            popup.style.opacity = '1';
            
            // Clear any existing timeout
            if (popup.hideTimeout) {
                clearTimeout(popup.hideTimeout);
            }
            
            // Set new timeout
            popup.hideTimeout = setTimeout(() => {
                popup.style.opacity = '0';
                popup.className = '';
            }, 3000);
        }
        
        // Victory popup function
        function showVictoryScreen(type, target) {
            const overlay = document.getElementById('victoryOverlay');
            const scoreDisplay = document.getElementById('victoryScore');
            const discoveryDisplay = document.getElementById('victoryDiscoveries');
            const timeDisplay = document.getElementById('victoryTime');
            const loreDisplay = document.getElementById('victoryLore');
            
            // Calculate game time
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            
            // Set stats
            scoreDisplay.textContent = playerSnake.score.toLocaleString();
            discoveryDisplay.textContent = `${discoveryCount} / ${elementLoader.elements.size}`;
            timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Set lore message based on victory type
            const loreMessages = {
                discovery: [
                    `You have mastered the art of elemental fusion, discovering ${target} unique combinations. The universe bows to your alchemical prowess!`,
                    `Through countless experiments, you've unlocked ${target} elemental secrets. Your name shall be etched in the annals of discovery!`,
                    `The elements themselves whisper your name. ${target} discoveries mark you as a true Alchemist of the Infinite!`
                ],
                points: [
                    `With ${playerSnake.score.toLocaleString()} points, you've proven your mastery over the elemental realm. The serpent of infinity coils in reverence!`,
                    `Your score of ${playerSnake.score.toLocaleString()} echoes through the void. You are the undisputed champion of the elemental dance!`,
                    `${playerSnake.score.toLocaleString()} points! The very fabric of reality trembles at your achievement. You are legend incarnate!`
                ]
            };
            
            const messages = loreMessages[type] || [`Victory achieved with ${playerSnake.score.toLocaleString()} points!`];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            loreDisplay.textContent = randomMessage;
            
            // Show overlay
            overlay.style.display = 'flex';
            gameRunning = false;
            
            // Play victory sound if available
            if (eatSounds.length > 0 && !musicMuted) {
                const sound = eatSounds[0];
                sound.currentTime = 0;
                sound.volume = 0.75;
                sound.play().catch(e => console.log('Could not play victory sound'));
            }
        }
        
        // Add discovery to the feed (MMO chat-style)
        function addDiscoveryToFeed(element, recipe) {
            const feed = document.getElementById('discoveryFeed');
            const message = document.createElement('div');
            message.className = 'discovery-message';
            
            let recipeText = recipe || '';
            if (element.recipe && element.recipe.length === 2) {
                const elem1 = elementDatabase[element.recipe[0]];
                const elem2 = elementDatabase[element.recipe[1]];
                if (elem1 && elem2) {
                    recipeText = `${elem1.emoji} ${elem1.name} + ${elem2.emoji} ${elem2.name}`;
                }
            }
            
            message.innerHTML = `
                <span class="emoji">${element.emoji}</span>
                <div class="discovery-text">
                    <div class="discovery-name">${element.name}</div>
                    ${recipeText ? `<div class="discovery-combo">${recipeText}</div>` : ''}
                </div>
            `;
            
            feed.appendChild(message);
            
            // Auto-scroll to bottom
            feed.scrollTop = feed.scrollHeight;
            
            // Limit messages to prevent memory issues
            while (feed.children.length > 20) {
                feed.removeChild(feed.firstChild);
            }
        }
        
        function updateLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            
            // Sort snakes based on game mode
            let sortedSnakes = [...snakes].filter(s => s.alive);
            
            if (gameMode === 'discovery') {
                // Sort by discoveries, then by score
                sortedSnakes.sort((a, b) => {
                    if (b.discoveries !== a.discoveries) {
                        return b.discoveries - a.discoveries;
                    }
                    return b.score - a.score;
                });
            } else {
                // Sort by score
                sortedSnakes.sort((a, b) => b.score - a.score);
            }
            
            // Mark the leader
            snakes.forEach(s => s.isLeader = false);
            if (sortedSnakes.length > 0) {
                sortedSnakes[0].isLeader = true;
            }
            
            // Display top 5 with MMO-style formatting
            leaderboardList.innerHTML = '';
            sortedSnakes.slice(0, 5).forEach((snake, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                
                if (index === 0) {
                    div.classList.add('leader');
                }
                if (snake.isPlayer) {
                    div.classList.add('player');
                }
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'leaderboard-name';
                nameSpan.textContent = (index === 0 ? ' ' : '') + snake.name;
                
                const statsDiv = document.createElement('div');
                statsDiv.className = 'leaderboard-stats';
                statsDiv.innerHTML = `
                    <div>${Math.floor(snake.score).toLocaleString()} pts</div>
                    <div>${snake.discoveries || 0} discoveries</div>
                `;
                
                div.appendChild(nameSpan);
                div.appendChild(statsDiv);
                leaderboardList.appendChild(div);
            });
        }
        
        function updateDiscoveryLog() {
            const list = document.getElementById('discoveryList');
            list.innerHTML = '';
            
            // Get all discovered elements and sort by tier (highest first)
            const discovered = Array.from(discoveredElements)
                .filter(key => {
                    const element = elementDatabase[key];
                    return element && element.tier > 0;
                })
                .sort((a, b) => {
                    const elemA = elementDatabase[a];
                    const elemB = elementDatabase[b];
                    // Sort by tier descending, then alphabetically
                    if (elemB.tier !== elemA.tier) {
                        return elemB.tier - elemA.tier;
                    }
                    return a.localeCompare(b);
                });
            
            discovered.forEach(elementKey => {
                const element = elementDatabase[elementKey];
                if (element) {
                    const div = document.createElement('div');
                    div.className = 'discovery-item';
                    
                    // Highlight if this is the newest discovery
                    if (elementKey === lastDiscoveredElement) {
                        div.classList.add('new');
                    }
                    
                    div.innerHTML = `
                        <div class="emoji">${element.emoji}</div>
                        <div class="info">
                            <div class="name">${element.name}</div>
                            <div class="tier">Tier ${element.tier}</div>
                        </div>
                    `;
                    list.appendChild(div);
                }
            });
            
            // Update count in header
            const header = document.querySelector('#discoveryLog h3');
            if (header) {
                header.textContent = `Discoveries (${discovered.length})`;
            }
        }
        
        // Update boost bar separately for real-time updates
        function updateBoostBar() {
            if (!playerSnake) return;
            
            const boostFill = document.getElementById('boostBarFill');
            if (!boostFill) return;
            
            // Calculate stamina percentage
            const staminaPercent = Math.max(0, Math.min(100, (playerSnake.stamina / playerSnake.maxStamina) * 100));
            
            // Force immediate style update
            boostFill.style.width = staminaPercent + '%';
            
            // Force browser to recalculate styles
            boostFill.offsetWidth;
            
            // Change color based on stamina level
            if (staminaPercent <= 20) {
                boostFill.className = 'boost-bar-fill low';
            } else if (playerSnake.isBoosting) {
                boostFill.className = 'boost-bar-fill boosting';
            } else {
                boostFill.className = 'boost-bar-fill';
            }
        }
        
        function updateUI() {
            if (!playerSnake) return;
            
            // Update player info box
            document.getElementById('playerScore').textContent = Math.floor(playerSnake.score).toLocaleString();
            
            // Update discoveries count
            const discoveryCount = discoveredElements.size - 4; // Subtract base elements
            document.getElementById('playerDiscoveries').textContent = discoveryCount;
            
            // Update high score display if current score is higher
            if (playerSnake.score > highScore) {
                highScore = playerSnake.score;
                localStorage.setItem('highScore', Math.floor(highScore).toString());
            }
            
            // Update game time
            const gameTime = Date.now() - gameStartTime;
            const minutes = Math.floor(gameTime / 60000);
            const seconds = Math.floor((gameTime % 60000) / 1000);
            document.getElementById('playerTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Update best rank (only after 60 seconds to make it meaningful)
            const bestRankElement = document.getElementById('playerBestRank');
            if (gameTime >= 60000) { // 60 seconds
                const playerRank = snakes.filter(s => s.alive).findIndex(s => s === playerSnake) + 1;
                if (playerRank > 0 && (bestRank === 0 || playerRank < bestRank)) {
                    bestRank = playerRank;
                    bestRankElement.textContent = `#${bestRank}`;
                }
            } else {
                // Show placeholder before 60 seconds
                bestRankElement.textContent = '-';
            }
            
            // Update kills
            document.getElementById('playerKills').textContent = playerSnake.kills;
            
            // Update AlchemyVision timer
            const timerElement = document.getElementById('alchemyVisionTimer');
            if (alchemyVisionActive && alchemyVisionTimer > 0) {
                timerElement.style.display = 'block';
                const seconds = Math.ceil(alchemyVisionTimer / 1000);
                document.getElementById('alchemyTime').textContent = seconds;
            } else {
                timerElement.style.display = 'none';
            }
            
            // Update boost bar
            updateBoostBar();
            
            // Check victory condition
            if (gameMode === 'discovery' && discoveryCount >= gameTarget) {
                showVictoryScreen('discovery', gameTarget);
            } else if (gameMode === 'points' && playerSnake.score >= gameTarget) {
                showVictoryScreen('points', gameTarget);
            }
            
            // Update leaderboard
            updateLeaderboard();
            
            // Update element collection bar (MMO skill bar style)
            const elementBar = document.getElementById('elementBar');
            elementBar.innerHTML = '';
            
            // Create slots for the full capacity
            for (let i = 0; i < playerSnake.elementCapacity; i++) {
                const div = document.createElement('div');
                div.className = 'element-slot';
                
                if (i < playerSnake.elements.length) {
                    // Filled slot with element
                    const elementType = playerSnake.elements[i];
                    const element = elementDatabase[elementType];
                    if (element) {
                        div.classList.add('filled');
                        // Highlight the tail element (last element)
                        if (i === playerSnake.elements.length - 1 && playerSnake.elements.length > 1) {
                            div.classList.add('tail-element');
                        }
                        div.innerHTML = `<div class="emoji">${element.emoji}</div><div class="element-name">${element.name}</div>`;
                        div.title = element.name;
                    }
                } else {
                    // Empty slot
                    div.classList.add('empty');
                }
                
                elementBar.appendChild(div);
            }
        }
        
        function checkCollisions() {
            for (const snake of snakes) {
                if (!snake.alive) continue;
                
                // Check element collisions
                const activeElements = elementPool.getActiveElements();
                for (const element of activeElements) {
                    const dist = Math.hypot(element.x - snake.x, element.y - snake.y);
                    if (dist < SEGMENT_SIZE + ELEMENT_SIZE) {
                        snake.consume(element);
                    }
                }
                
                // Check AlchemyVision power-up collision (player only)
                if (snake.isPlayer) {
                    for (let i = alchemyVisionPowerUps.length - 1; i >= 0; i--) {
                        const powerUp = alchemyVisionPowerUps[i];
                        const dist = Math.hypot(powerUp.x - snake.x, powerUp.y - snake.y);
                        if (dist < SEGMENT_SIZE + powerUp.size) {
                            // Activate Alchemy Vision
                            alchemyVisionActive = true;
                            alchemyVisionTimer = ALCHEMY_VISION_DURATION;
                            
                            // Remove collected power-up
                            alchemyVisionPowerUps.splice(i, 1);
                            
                            // Play collection sound if available
                            if (window.eatSound) {
                                window.eatSound.play().catch(() => {});
                            }
                            
                            // Show notification
                            showMessage(' Alchemy Vision Activated! 30s<br><small style="opacity: 0.8">Your eyes are opened to see all combinations</small>', 'success');
                            break; // Only collect one at a time
                        }
                    }
                }
                
                // Check Void Orb collision (all snakes can collect)
                for (let i = voidOrbs.length - 1; i >= 0; i--) {
                    const orb = voidOrbs[i];
                    const dist = Math.hypot(orb.x - snake.x, orb.y - snake.y);
                    if (dist < SEGMENT_SIZE + orb.size) {
                        // Consume the void orb
                        if (snake.elements.length > 0) {
                            const elementCount = snake.elements.length;
                            const points = elementCount * 100;
                            snake.score += points;
                            snake.elements = []; // Clear all elements
                            
                            // Visual feedback
                            if (snake.isPlayer) {
                                showMessage(` Void consumed! +${points} points<br><small style="opacity: 0.8">Your elements have been purged to the void</small>`, 'info');
                                if (window.eatSound) {
                                    window.eatSound.play().catch(() => {});
                                }
                            }
                            
                            // Create particle effect
                            for (let j = 0; j < 15; j++) {
                                const angle = (j / 15) * Math.PI * 2;
                                const speed = 2 + Math.random() * 3;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(orb.x, orb.y, vx, vy, 'rgba(100, 200, 255, 0.8)');
                            }
                        }
                        
                        // Remove void orb
                        voidOrbs.splice(i, 1);
                        break;
                    }
                }
                
                // Check Catalyst Gem collision (all snakes can collect)
                for (let i = catalystGems.length - 1; i >= 0; i--) {
                    const gem = catalystGems[i];
                    const dist = Math.hypot(gem.x - snake.x, gem.y - snake.y);
                    if (dist < SEGMENT_SIZE + gem.size) {
                        // Only activate if snake has elements
                        if (snake.elements.length > 0) {
                            const tailElement = snake.elements[snake.elements.length - 1];
                            
                            // Find all compatible elements
                            const compatibleElements = [];
                            for (const [combo, result] of Object.entries(combinations)) {
                                const [elem1, elem2] = combo.split('+');
                                if (elem1 === tailElement) {
                                    compatibleElements.push(elem2);
                                } else if (elem2 === tailElement) {
                                    compatibleElements.push(elem1);
                                }
                            }
                            
                            // Spawn up to 4 compatible elements
                            const spawnCount = Math.min(4, compatibleElements.length);
                            if (spawnCount > 0 && snake.isPlayer) {
                                // Spawn elements around the player
                                for (let j = 0; j < spawnCount; j++) {
                                    const angle = (j / spawnCount) * Math.PI * 2;
                                    const distance = 100 + Math.random() * 100;
                                    const spawnX = snake.x + Math.cos(angle) * distance;
                                    const spawnY = snake.y + Math.sin(angle) * distance;
                                    
                                    // Pick a random compatible element (allowing duplicates)
                                    const elementType = compatibleElements[Math.floor(Math.random() * compatibleElements.length)];
                                    
                                    // Create the element with catalyst sparkle effect
                                    elementPool.spawn(elementType, spawnX, spawnY, true);
                                }
                                
                                showMessage(` Catalyst activated! Spawned ${spawnCount} compatible elements<br><small style="opacity: 0.8">New elements have resonated into existence</small>`, 'success');
                            } else if (spawnCount > 0 && !snake.isPlayer) {
                                // AI snakes get points instead
                                snake.score += 200;
                            }
                            
                            // Visual feedback
                            if (window.eatSound) {
                                window.eatSound.play().catch(() => {});
                            }
                            
                            // Create particle effect
                            for (let j = 0; j < 20; j++) {
                                const angle = (j / 20) * Math.PI * 2;
                                const speed = 3 + Math.random() * 4;
                                const vx = Math.cos(angle) * speed;
                                const vy = Math.sin(angle) * speed;
                                particlePool.spawn(gem.x, gem.y, vx, vy, 'rgba(255, 165, 0, 0.8)');
                            }
                        }
                        
                        // Remove catalyst gem
                        catalystGems.splice(i, 1);
                        break;
                    }
                }
                
                // Check snake collisions (skip if invincible)
                if (snake.invincibilityTimer > 0) continue;
                
                for (const otherSnake of snakes) {
                    if (snake === otherSnake || !otherSnake.alive) continue;
                    
                    // Check head collision with other snake's body
                    for (let i = 3; i < otherSnake.segments.length; i++) {
                        const segment = otherSnake.segments[i];
                        const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);
                        if (dist < SEGMENT_SIZE) {
                            snake.explode(otherSnake);
                            break;
                        }
                    }
                    
                    // Check head-to-head collision
                    if (snake.alive && otherSnake.alive) {
                        const headDist = Math.hypot(otherSnake.x - snake.x, otherSnake.y - snake.y);
                        if (headDist < SEGMENT_SIZE) {
                            // Smaller snake explodes, or both if same size
                            if (snake.length < otherSnake.length) {
                                snake.explode(otherSnake);
                            } else if (otherSnake.length < snake.length) {
                                otherSnake.explode(snake);
                            } else {
                                // Same size - both explode, no points awarded
                                snake.die();
                                otherSnake.die();
                            }
                        }
                    }
                }
            }
        }
        
        function drawBackground() {
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0a0a1a');
            gradient.addColorStop(1, '#1a0a2a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw static stars (before grid so they appear behind)
            ctx.save();
            staticStars.forEach(star => {
                const screenX = star.x - camera.x + canvas.width / 2;
                const screenY = star.y - camera.y + canvas.height / 2;
                
                // Skip if off-screen
                if (screenX < -10 || screenX > canvas.width + 10 ||
                    screenY < -10 || screenY > canvas.height + 10) return;
                
                ctx.globalAlpha = star.opacity;
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();
            
            // Draw shooting stars
            shootingStars.forEach(star => star.draw());
            
            // Grid
            ctx.strokeStyle = 'rgba(138, 43, 226, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const offsetX = camera.x % gridSize;
            const offsetY = camera.y % gridSize;
            
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = -offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw world borders with nebula effect
            const borderThickness = 50; // Increased for gradient effect
            const leftBorder = -camera.x + canvas.width / 2;
            const rightBorder = WORLD_SIZE - camera.x + canvas.width / 2;
            const topBorder = -camera.y + canvas.height / 2;
            const bottomBorder = WORLD_SIZE - camera.y + canvas.height / 2;
            
            // Pulsating glow intensity
            const glowIntensity = 0.7 + Math.sin(animationTime * 2) * 0.3;
            
            // Create nebula gradient function
            function createNebulaGradient(x0, y0, x1, y1) {
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, `rgba(147, 51, 234, ${glowIntensity})`); // purple
                gradient.addColorStop(0.3, `rgba(236, 72, 153, ${glowIntensity * 0.8})`); // pink
                gradient.addColorStop(0.6, `rgba(59, 130, 246, ${glowIntensity * 0.6})`); // blue
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // fade to transparent
                return gradient;
            }
            
            // Left border nebula
            if (leftBorder > -borderThickness) {
                const borderWidth = Math.max(borderThickness, leftBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, borderWidth, 0);
                ctx.fillRect(0, 0, borderWidth, canvas.height);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(Math.max(10, leftBorder), 0);
                ctx.lineTo(Math.max(10, leftBorder), canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Right border nebula
            if (rightBorder < canvas.width + borderThickness) {
                ctx.fillStyle = createNebulaGradient(canvas.width, 0, rightBorder, 0);
                ctx.fillRect(rightBorder, 0, canvas.width - rightBorder, canvas.height);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rightBorder, 0);
                ctx.lineTo(rightBorder, canvas.height);
                ctx.stroke();
                ctx.restore();
            }
            
            // Top border nebula
            if (topBorder > -borderThickness) {
                const borderHeight = Math.max(borderThickness, topBorder);
                ctx.fillStyle = createNebulaGradient(0, 0, 0, borderHeight);
                ctx.fillRect(0, 0, canvas.width, borderHeight);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, Math.max(10, topBorder));
                ctx.lineTo(canvas.width, Math.max(10, topBorder));
                ctx.stroke();
                ctx.restore();
            }
            
            // Bottom border nebula
            if (bottomBorder < canvas.height + borderThickness) {
                ctx.fillStyle = createNebulaGradient(0, canvas.height, 0, bottomBorder);
                ctx.fillRect(0, bottomBorder, canvas.width, canvas.height - bottomBorder);
                
                // Add danger glow
                ctx.save();
                ctx.shadowBlur = 20 * glowIntensity;
                ctx.shadowColor = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = `rgba(255, 0, 0, ${glowIntensity * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, bottomBorder);
                ctx.lineTo(canvas.width, bottomBorder);
                ctx.stroke();
                ctx.restore();
            }
            
            // Draw border particles
            borderParticles.forEach(particle => {
                // Only draw particles that are visible on screen
                if (particle.edge === 'left' && leftBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'right' && rightBorder < canvas.width + borderThickness + 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'top' && topBorder > -borderThickness - 20) {
                    particle.draw(ctx);
                } else if (particle.edge === 'bottom' && bottomBorder < canvas.height + borderThickness + 20) {
                    particle.draw(ctx);
                }
            });
        }
        
        // Game functions
        function initializeStaticStars() {
            staticStars = [];
            // Reduce stars on mobile for better performance
            const starCount = isMobile ? 50 : 200; // Much fewer stars on mobile
            
            for (let i = 0; i < starCount; i++) {
                staticStars.push({
                    x: Math.random() * WORLD_SIZE,
                    y: Math.random() * WORLD_SIZE,
                    size: Math.random() * 2 + 1, // 1-3px
                    opacity: Math.random() * 0.2 + 0.1, // 0.1-0.3 opacity
                    color: Math.random() > 0.5 ? '#ffffff' : '#e0e8ff' // white or pale blue
                });
            }
        }
        
        function initializeBorderParticles() {
            borderParticles = [];
            
            // Create particles along each border
            const particleSpacing = 30;
            
            // Left border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(Math.random() * 30, y, 'left'));
                }
            }
            
            // Right border particles
            for (let y = 0; y < canvas.height; y += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(canvas.width - Math.random() * 30, y, 'right'));
                }
            }
            
            // Top border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, Math.random() * 30, 'top'));
                }
            }
            
            // Bottom border particles
            for (let x = 0; x < canvas.width; x += particleSpacing) {
                if (borderParticles.length < MAX_BORDER_PARTICLES) {
                    borderParticles.push(new BorderParticle(x, canvas.height - Math.random() * 30, 'bottom'));
                }
            }
        }
        
        function startGame() {
            // Clear all game state to ensure fresh start
            snakes = [];
            elements = [];
            particles = [];
            voidOrbs = [];
            catalystGems = [];
            alchemyVisionPowerUps = [];
            
            // Reset discoveries (keep only base elements)
            discoveredElements = new Set(['fire', 'water', 'earth', 'air']);
            
            // Reset game variables
            lastDiscoveredElement = null;
            alchemyVisionActive = false;
            alchemyVisionTimer = 0;
            bestRank = 0;
            playerSnake = null;
            
            // Reset game loop timing variables
            lastTime = 0;
            accumulator = 0;
            frameCount = 0;
            lastFpsUpdate = 0;
            
            // Reset spawn timers
            lastAlchemyVisionSpawn = Date.now();
            lastVoidOrbSpawn = Date.now();
            lastCatalystGemSpawn = Date.now();
            
            // Clear discovery feed
            const discoveryFeed = document.getElementById('discoveryFeed');
            if (discoveryFeed) {
                discoveryFeed.innerHTML = '';
            }
            
            // Start fresh game
            gameStarted = true;
            gameStartTime = Date.now();
            
            // Create player snake
            playerSnake = new Snake(WORLD_SIZE / 2, WORLD_SIZE / 2, true);
            snakes.push(playerSnake);
            
            // Create AI snakes
            for (let i = 0; i < 5; i++) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            
            
            // Spawn initial elements
            for (let i = 0; i < 50; i++) {
                spawnElement();
            }
            
            // Initialize music and sound effects
            initMusic();
            initSoundEffects();
            
            // Update discovery log
            updateDiscoveryLog();
            
            // Initialize border particles
            initializeBorderParticles();
            
            // Initialize static stars
            initializeStaticStars();
            
            gameLoop();
        }
        
        function togglePause() {
            if (!gameStarted) return;
            paused = !paused;
            document.getElementById('pauseOverlay').style.display = paused ? 'flex' : 'none';
            
            // Update music button state
            if (paused) {
                // Update music controls if they exist
                const muteButton = document.getElementById('muteButton');
                if (muteButton) {
                    muteButton.textContent = musicMuted ? ' Unmute' : ' Mute';
                }
                const volumeSlider = document.getElementById('volumeSlider');
                if (volumeSlider) {
                    volumeSlider.value = musicVolume * 100;
                }
                const volumeDisplay = document.getElementById('volumeDisplay');
                if (volumeDisplay) {
                    volumeDisplay.textContent = Math.round(musicVolume * 100) + '%';
                }
                
                // Update skin selection UI
                calculateAvailableUnlocks();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Update high score display
                document.getElementById('highScoreDisplay').textContent = Math.floor(highScore).toLocaleString();
                
                // Populate discovery journal
                populateDiscoveryJournal();
            }
        }
        
        window.resumeGame = function() {
            paused = false;
            document.getElementById('pauseOverlay').style.display = 'none';
        }
        
        // Tab switching for pause menu
        window.switchTab = function(tabName) {
            // Update button states
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            if (tabName === 'skins') {
                document.getElementById('skinsTab').classList.add('active');
            } else if (tabName === 'journal') {
                document.getElementById('journalTab').classList.add('active');
            }
        }
        
        // Build skin selection UI
        function buildSkinGrid() {
            const grid = document.getElementById('skinGrid');
            if (!grid) {
                console.error('Skin grid element not found!');
                return;
            }
            grid.innerHTML = '';
            
            const allSkins = Object.keys(skinMetadata).filter(skin => skin !== 'snake-default-green');
            allSkins.unshift('snake-default-green'); // Put default first
            
            allSkins.forEach(skinId => {
                const skinData = skinMetadata[skinId];
                const div = document.createElement('div');
                div.className = 'skin-item';
                
                // Add appropriate classes
                if (skinId === currentPlayerSkin) {
                    div.classList.add('current');
                }
                
                if (!skinData.unlocked) {
                    if (availableUnlocks > 0) {
                        div.classList.add('unlockable');
                    } else {
                        div.classList.add('locked');
                    }
                }
                
                // Build content
                const img = document.createElement('img');
                img.className = 'skin-image';
                img.src = `skins/${skinId}.png`;
                img.alt = skinData.name;
                img.onerror = function() {
                    console.error(`Failed to load skin image: skins/${skinId}.png`);
                    // Try with .webp extension as fallback
                    this.src = `skins/${skinId}.webp`;
                    this.onerror = function() {
                        console.error(`Failed to load skin image with both .png and .webp: ${skinId}`);
                    };
                };
                
                const name = document.createElement('div');
                name.className = 'skin-name';
                name.textContent = skinData.name;
                
                div.appendChild(img);
                div.appendChild(name);
                
                // Add unlock icon if applicable
                if (!skinData.unlocked) {
                    const icon = document.createElement('div');
                    icon.className = 'skin-unlock-icon';
                    icon.textContent = availableUnlocks > 0 ? '' : '';
                    div.appendChild(icon);
                }
                
                // Click handler
                div.onclick = () => selectSkin(skinId);
                
                grid.appendChild(div);
            });
        }
        
        // Handle skin selection
        function selectSkin(skinId) {
            const skinData = skinMetadata[skinId];
            
            if (skinData.unlocked) {
                // Already unlocked - just select it
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${skinId}.png`;
                }
                saveSkinData();
                buildSkinGrid();
            } else if (availableUnlocks > 0) {
                // Unlock the skin
                skinData.unlocked = true;
                unlockedSkins.add(skinId);
                availableUnlocks--;
                
                // Select the newly unlocked skin
                currentPlayerSkin = skinId;
                if (playerSnake) {
                    playerSnake.skin = skinId;
                }
                // Update player portrait
                const portrait = document.getElementById('playerPortrait');
                if (portrait) {
                    portrait.src = `skins/${skinId}.png`;
                }
                
                saveSkinData();
                updateUnlockDisplay();
                buildSkinGrid();
                
                // Show unlock message
                showMessage(`Unlocked: ${skinData.name}!`, true);
            }
        }
        
        // Update unlock display
        function updateUnlockDisplay() {
            const display = document.getElementById('availableUnlocks');
            if (display) {
                display.textContent = `Available Unlocks: ${availableUnlocks}`;
                if (availableUnlocks > 0) {
                    display.style.color = '#4ecdc4';
                } else {
                    display.style.color = '#AAA';
                }
            }
        }
        
        // Populate discovery journal with discovered elements
        function populateDiscoveryJournal() {
            const grid = document.getElementById('discoveryGrid');
            if (!grid) {
                console.error('Discovery grid element not found!');
                return;
            }
            
            grid.innerHTML = '';
            
            // Use allTimeDiscoveries for persistent journal
            const sortedDiscoveries = Array.from(allTimeDiscoveries.entries()).sort((a, b) => {
                const nameA = elementDatabase[a[0]]?.name || a[0];
                const nameB = elementDatabase[b[0]]?.name || b[0];
                return nameA.localeCompare(nameB);
            });
            
            sortedDiscoveries.forEach(([elementKey, recipe]) => {
                const elementData = elementDatabase[elementKey];
                if (!elementData) return;
                
                const div = document.createElement('div');
                div.className = 'discovery-item';
                div.dataset.name = elementData.name.toLowerCase();
                div.dataset.recipe = recipe.toLowerCase();
                
                // Element emoji/symbol
                const symbol = document.createElement('div');
                symbol.className = 'element-symbol';
                symbol.textContent = elementData.emoji;
                
                // Element name
                const name = document.createElement('div');
                name.className = 'element-name';
                name.textContent = elementData.name;
                
                // Recipe tooltip
                const recipeTooltip = document.createElement('div');
                recipeTooltip.className = 'recipe';
                recipeTooltip.textContent = recipe;
                
                div.appendChild(symbol);
                div.appendChild(name);
                div.appendChild(recipeTooltip);
                
                grid.appendChild(div);
            });
        }
        
        // filterDiscoveries function removed - search bar no longer present
        
        // Fixed timestep constants
        const FIXED_TIMESTEP = 1000 / 60; // 60 FPS fixed timestep (16.67ms)
        const MAX_UPDATES = 5; // Prevent spiral of death
        
        function gameLoop(currentTime) {
            if (!gameStarted) return;
            
            requestAnimationFrame(gameLoop);
            
            if (paused) return;
            
            // Initialize lastTime on first frame
            if (lastTime === 0) {
                lastTime = currentTime;
                return;
            }
            
            // Calculate frame time
            if (!isFinite(currentTime)) {
                console.error('currentTime is not finite:', currentTime);
                return;
            }
            const frameTime = Math.min(currentTime - lastTime, 250); // Cap at 250ms (4 FPS min)
            lastTime = currentTime;
            
            // Add to accumulator
            accumulator += frameTime;
            
            // Check for NaN
            if (!isFinite(accumulator) || !isFinite(frameTime)) {
                console.error('Accumulator or frameTime became NaN! frameTime:', frameTime, 'currentTime:', currentTime, 'lastTime:', lastTime, 'accumulator:', accumulator);
                accumulator = 0;
                lastTime = currentTime;
                return;
            }
            
            // Calculate FPS
            frameCount++;
            if (currentTime - lastFpsUpdate > 1000) { // Update every second
                currentFPS = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
                
                // Update FPS display
                const fpsElement = document.getElementById('fpsCounter');
                if (fpsElement) {
                    fpsElement.textContent = `FPS: ${currentFPS}`;
                }
            }
            
            // Update animation time for border effects
            animationTime = currentTime * 0.001; // Convert to seconds
            
            // Fixed timestep updates
            let updates = 0;
            while (accumulator >= FIXED_TIMESTEP && updates < MAX_UPDATES) {
                // Update game objects with fixed timestep (1.0 = one 60fps frame)
                snakes.forEach(snake => snake.update(1.0));
                elementPool.update(1.0);
                particlePool.update(1.0);
                
                // Update border particles
                borderParticles.forEach(particle => particle.update(1.0));
                
                // Update shooting stars
                shootingStars = shootingStars.filter(star => star.update(1.0));
                
                // Spawn shooting star occasionally (10-15 seconds)
                if (currentTime - lastShootingStarTime > (10000 + Math.random() * 5000) && shootingStars.length === 0) {
                    shootingStars.push(new ShootingStar());
                    lastShootingStarTime = currentTime;
                }
                
                // Check collisions
                checkCollisions();
                
                // Remove dead snakes (except the current player if they're respawning)
                snakes = snakes.filter(snake => snake.alive || (snake.isPlayer && snake === playerSnake));
                
                // Spawn new elements occasionally
                if (Math.random() < 0.04 && elementPool.getActiveCount() < 150) {
                    spawnElement();
                }
                
                // Update AlchemyVision timer
                if (alchemyVisionActive) {
                    alchemyVisionTimer -= FIXED_TIMESTEP;
                    if (alchemyVisionTimer <= 0) {
                        alchemyVisionActive = false;
                        alchemyVisionTimer = 0;
                        // Clear any remaining power-ups when one expires
                        alchemyVisionPowerUps = [];
                    }
                }
                
                accumulator -= FIXED_TIMESTEP;
                updates++;
            }
            
            // Spawn new AI snakes if needed
            const aiSnakes = snakes.filter(s => !s.isPlayer && s.alive).length;
            if (aiSnakes < 5) {
                const x = 200 + Math.random() * (WORLD_SIZE - 400);
                const y = 200 + Math.random() * (WORLD_SIZE - 400);
                snakes.push(new Snake(x, y, false));
            }
            
            // Update UI
            updateUI();
            
            // Update boost bar every frame for real-time feedback
            updateBoostBar();
            
            // Calculate interpolation factor for smooth rendering
            const interpolation = accumulator / FIXED_TIMESTEP;
            
            // Update camera to follow player with interpolation
            if (playerSnake && playerSnake.alive && playerSnake.segments.length > 0) {
                const head = playerSnake.segments[0];
                
                // Interpolate player position for camera
                let playerX = playerSnake.x;
                let playerY = playerSnake.y;
                
                if (playerSnake.prevX !== undefined && playerSnake.prevY !== undefined) {
                    playerX = playerSnake.prevX + (playerSnake.x - playerSnake.prevX) * interpolation;
                    playerY = playerSnake.prevY + (playerSnake.y - playerSnake.prevY) * interpolation;
                }
                
                // Ensure camera coordinates stay within reasonable bounds to prevent overflow
                camera.x = Math.max(0, Math.min(WORLD_SIZE, playerX));
                camera.y = Math.max(0, Math.min(WORLD_SIZE, playerY));
                
                // Additional check for NaN or Infinity
                if (!isFinite(camera.x)) camera.x = WORLD_SIZE / 2;
                if (!isFinite(camera.y)) camera.y = WORLD_SIZE / 2;
            }
            
            // Draw everything
            drawBackground();
            
            // Draw elements (element pool handles viewport culling)
            elementPool.draw();
            
            // Draw AlchemyVision power-ups (with viewport culling)
            alchemyVisionPowerUps.forEach(powerUp => {
                if (isInViewport(powerUp.x, powerUp.y, 100)) {
                    powerUp.draw();
                }
            });
            
            // Draw Void Orbs (with viewport culling)
            voidOrbs.forEach(orb => {
                if (isInViewport(orb.x, orb.y, 100)) {
                    orb.draw();
                }
            });
            
            // Draw Catalyst Gems (with viewport culling)
            catalystGems.forEach(gem => {
                if (isInViewport(gem.x, gem.y, 100)) {
                    gem.draw();
                }
            });
            
            // Draw snakes (they already have internal viewport culling)
            snakes.forEach(snake => snake.draw(interpolation));
            
            // Draw particles (particle pool handles viewport culling)
            particlePool.draw();
        }
        
        // Initialize mobile controls
        function initMobileControls() {
            if (!isMobile) return;
            
            // Add mobile class to body
            document.body.classList.add('mobile');
            
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            const boostBtn = document.getElementById('boostButton');
            
            let joystickTouch = null;
            
            // Joystick controls
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (joystickTouch === null && e.changedTouches.length > 0) {
                    joystickTouch = e.changedTouches[0].identifier;
                    joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    joystickBase.x = rect.left + rect.width / 2;
                    joystickBase.y = rect.top + rect.height / 2;
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touch.identifier === joystickTouch) {
                        const dx = touch.clientX - joystickBase.x;
                        const dy = touch.clientY - joystickBase.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const maxDistance = 40; // Max knob travel distance
                        
                        let knobX = dx;
                        let knobY = dy;
                        
                        if (distance > maxDistance) {
                            knobX = (dx / distance) * maxDistance;
                            knobY = (dy / distance) * maxDistance;
                        }
                        
                        // Update knob position
                        knob.style.left = `${50 + (knobX / 60) * 50}%`;
                        knob.style.top = `${50 + (knobY / 60) * 50}%`;
                        
                        // Update mouse angle for game controls
                        if (distance > 10) { // Dead zone
                            mouseAngle = Math.atan2(dy, dx);
                        }
                        break;
                    }
                }
            });
            
            const resetJoystick = () => {
                joystickActive = false;
                joystickTouch = null;
                knob.style.left = '50%';
                knob.style.top = '50%';
            };
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouch) {
                        resetJoystick();
                        break;
                    }
                }
            });
            
            joystick.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                resetJoystick();
            });
            
            // Boost button controls
            boostBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                mouseDown = true;
                boostBtn.classList.add('active');
            });
            
            boostBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            boostBtn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                mouseDown = false;
                boostBtn.classList.remove('active');
            });
            
            // Prevent scrolling on game canvas
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            });
        }
        
        // Initialize
        Promise.all([loadElements(), loadSnakeNames()]).then(() => {
            console.log('Game ready!');
            
            // Sync discovered elements from new system if available
            if (window.elementLoader && window.elementCompatibility) {
                // Load previously discovered elements
                const savedDiscovered = window.elementCompatibility.loadDiscoveredElements();
                if (savedDiscovered && savedDiscovered.size > 0) {
                    // Merge with existing discovered elements
                    for (const elementKey of savedDiscovered) {
                        discoveredElements.add(elementKey);
                    }
                    console.log(`Loaded ${savedDiscovered.size} discovered elements from new system`);
                }
            }
            
            // Load skin data
            loadSkinData();
            preloadSkins();
            
            // Load all-time discoveries
            loadAllTimeDiscoveries();
            
            // Initialize mobile controls if needed
            initMobileControls();
        });
        
        // Stars animation for splash and game mode screens
        (function() {
            const splashCanvas = document.getElementById('splashStarsCanvas');
            const splashCtx = splashCanvas.getContext('2d');
            const gameModeCanvas = document.getElementById('gameModeStarsCanvas');
            const gameModeCtx = gameModeCanvas.getContext('2d');
            
            // Resize canvases
            function resizeCanvases() {
                splashCanvas.width = window.innerWidth;
                splashCanvas.height = window.innerHeight;
                gameModeCanvas.width = window.innerWidth;
                gameModeCanvas.height = window.innerHeight;
            }
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
            
            // Stars array (shared between both screens)
            const stars = [];
            const shootingStars = [];
            let lastShootingStarTime = 0;
            
            // Initialize stars
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2 + 0.5,
                    opacity: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                });
            }
            
            // Shooting star class for splash
            class SplashShootingStar {
                constructor() {
                    // Start from screen edge
                    const edge = Math.floor(Math.random() * 4);
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    switch(edge) {
                        case 0: // Top
                            this.x = Math.random() * width;
                            this.y = -10;
                            break;
                        case 1: // Right
                            this.x = width + 10;
                            this.y = Math.random() * height;
                            break;
                        case 2: // Bottom
                            this.x = Math.random() * width;
                            this.y = height + 10;
                            break;
                        case 3: // Left
                            this.x = -10;
                            this.y = Math.random() * height;
                            break;
                    }
                    
                    // Aim towards screen center area
                    const targetX = width * (0.3 + Math.random() * 0.4);
                    const targetY = height * (0.3 + Math.random() * 0.4);
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    const speed = 3 + Math.random() * 2;
                    
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.trail = [];
                    this.maxTrailLength = 30;
                    this.life = 1.0;
                }
                
                update() {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.01;
                    
                    return this.life > 0 && this.x > -50 && this.x < window.innerWidth + 50 && 
                           this.y > -50 && this.y < window.innerHeight + 50;
                }
                
                draw(ctx) {
                    // Draw trail
                    ctx.save();
                    this.trail.forEach((point, index) => {
                        const alpha = (index / this.trail.length) * this.life * 0.3;
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#ffffff';
                        const size = (index / this.trail.length) * 2;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw star
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Animation loop
            function animateStars(timestamp) {
                // Check which screen is active
                const splashActive = document.getElementById('splashScreen').style.display !== 'none' && 
                                   document.getElementById('splashScreen').style.opacity !== '0';
                const gameModeActive = document.getElementById('gameModeSelect').style.display !== 'none';
                
                if (!splashActive && !gameModeActive) {
                    requestAnimationFrame(animateStars);
                    return;
                }
                
                // Determine which canvas to draw on
                const activeCanvas = splashActive ? splashCanvas : gameModeCanvas;
                const activeCtx = splashActive ? splashCtx : gameModeCtx;
                
                // Clear canvas
                activeCtx.clearRect(0, 0, activeCanvas.width, activeCanvas.height);
                
                // Draw static stars with twinkling
                stars.forEach(star => {
                    star.opacity += Math.sin(timestamp * star.twinkleSpeed) * 0.05;
                    star.opacity = Math.max(0.1, Math.min(0.8, star.opacity));
                    
                    activeCtx.globalAlpha = star.opacity;
                    activeCtx.fillStyle = '#ffffff';
                    activeCtx.beginPath();
                    activeCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    activeCtx.fill();
                });
                
                // Update and draw shooting stars
                shootingStars.forEach((star, index) => {
                    if (!star.update()) {
                        shootingStars.splice(index, 1);
                    } else {
                        star.draw(activeCtx);
                    }
                });
                
                // Spawn new shooting star occasionally
                if (timestamp - lastShootingStarTime > 3000 + Math.random() * 4000) {
                    shootingStars.push(new SplashShootingStar());
                    lastShootingStarTime = timestamp;
                }
                
                activeCtx.globalAlpha = 1;
                requestAnimationFrame(animateStars);
            }
            
            // Start animation
            requestAnimationFrame(animateStars);
        })();
        
        // Try to play music on first user interaction
        document.addEventListener('click', function playMusicOnInteraction() {
            if (currentTrack && currentTrack.paused && gameStarted) {
                currentTrack.play().catch(() => {});
            }
        }, { once: true });
    </script>
</body>
</html>